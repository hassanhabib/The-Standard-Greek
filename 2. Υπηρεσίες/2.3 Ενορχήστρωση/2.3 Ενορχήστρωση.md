# 2.3 Υπηρεσίες Ορχήστρωσης (Πολύπλοκη Λογική Υψηλού Επιπέδου) (Orchestration Services (Complex Higher Order Logic))

## 2.3.0 Εισαγωγή

Οι υπηρεσίες ορχήστρωσης είναι οι συνδυαστές μεταξύ πολλών βασικών ή επεξεργαστικών υπηρεσιών για την εκτέλεση μιας πολύπλοκης λογικής λειτουργίας. Οι βασικές τους ευθύνες είναι πολυ-οντότητας λογικές λειτουργίες και η ανάθεση των εξαρτήσεων αυτών των λειτουργιών σε κατώτερες επεξεργαστικές ή βασικές υπηρεσίες.

Ο πρωταρχικός ρόλος των υπηρεσιών ορχήστρωσης είναι η ενθυλάκωση λειτουργιών που απαιτούν δύο ή τρεις επιχειρηματικές οντότητες.

```csharp
public async ValueTask<LibraryCard> CreateStudentLibraryCardAsync(LibraryCard libraryCard) =>
TryCatch(async () =>
{
    ValidateLibraryCard(libraryCard);

    await this.studentProcessingService
        .VerifyEnrolledStudentExistsAsync(libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
});

```
Στο παραπάνω παράδειγμα, η υπηρεσία `LibraryCardOrchestrationService` καλεί τόσο την `StudentProcessingService` όσο και την `LibraryCardProcessingService` για να εκτελέσει μια πολύπλοκη λειτουργία. Καταρχάς, επαληθεύει την ύπαρξη του φοιτητή για τον οποίο δημιουργούμε μια κάρτα βιβλιοθήκης, και επαληθεύει την εγγραφή του φοιτητή· και δεύτερον, δημιουργεί την κάρτα βιβλιοθήκης.

Η λειτουργία δημιουργίας μιας κάρτας βιβλιοθήκης για έναν δεδομένο φοιτητή δεν μπορεί να εκτελεστεί απλά καλώντας την υπηρεσία κάρτας βιβλιοθήκης· διότι η υπηρεσία κάρτας βιβλιοθήκης (επεξεργασίας ή βάσης) δεν έχει πρόσβαση σε όλες τις λεπτομέρειες για τον φοιτητή. Επομένως, απαιτείται μια λογική συνδυασμού για να διασφαλιστεί ότι υπάρχει ένας κατάλληλος ροή.

Είναι σημαντικό να κατανοήσουμε ότι οι υπηρεσίες ορχήστρωσης απαιτούνται μόνο όταν χρειαζόμαστε να συνδυάσουμε λειτουργίες πολλών οντοτήτων, οι οποίες μπορεί να είναι αρχικές ή υψηλότερης τάξης. Σε ορισμένες αρχιτεκτονικές, οι υπηρεσίες ορχήστρωσης μπορεί ακόμη και να μην υπάρχουν. Αυτό συμβαίνει απλά επειδή κάποιες μικρουπηρεσίες ενδέχεται να είναι υπεύθυνες μόνο για την εφαρμογή λογικής επαλήθευσης και την αποθήκευση και ανάκτηση δεδομένων από την αποθήκη, τίποτε περισσότερο ή λιγότερο.

## 2.3.1 Στον Χάρτη

Οι υπηρεσίες ορχήστρωσης είναι ένα από τα βασικά στοιχεία της επιχειρηματικής λογικής σε οποιοδήποτε σύστημα, τοποθετημένο ανάμεσα σε υπηρεσίες μονάδας οντότητας (όπως επεξεργασία ή βάση) και υπηρεσίες προηγμένης λογικής όπως οι υπηρεσίες συντονισμού, οι υπηρεσίες συνάθροισης ή απλώς εκθέτες όπως ελεγκτές, στοιχεία web ή οτιδήποτε άλλο. Παρακάτω παρέχουμε μια επισκόπηση υψηλού επιπέδου για το πού μπορεί να βρίσκονται οι υπηρεσίες ορχήστρωσης:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118414675-e4fc8b80-b65a-11eb-91c8-94f67c6e68ed.png" />
    </p>
<br />

Όπως φαίνεται παραπάνω, οι υπηρεσίες ενορχήστρωσης έχουν αρκετές εξαρτήσεις και καταναλωτές. Είναι η πυρήνας της λογικής οποιουδήποτε λογισμικού. Στη δεξιά πλευρά, μπορείτε να δείτε τις εξαρτήσεις μιας υπηρεσίας ορχήστρωσης. Δεδομένου ότι μια υπηρεσία επεξεργασίας είναι προαιρετική ανάλογα με το αν απαιτείται μια λογική υψηλότερης τάξης ή όχι - οι υπηρεσίες ορχήστρωσης μπορούν επίσης να συνδυάσουν πολλές υπηρεσίες θεμελίωσης.

Η ύπαρξη μιας υπηρεσίας ενορχήστρωσης απαιτεί την ύπαρξη μιας υπηρεσίας επεξεργασίας. Αλλά αυτό δεν ισχύει πάντα. Υπάρχουν καταστάσεις όπου όλες οι υπηρεσίες ενορχήστρωσης χρειάζεται να ολοκληρώσουν ένα επιχειρηματικό ρεύμα για να αλληλεπιδράσουν με λειτουργικότητα επιπέδου πρωτεύοντος.

Ωστόσο, μια υπηρεσία ενορχήστρωσης μπορεί να έχει πολλούς καταναλωτές, όπως οι υπηρεσίες συντονισμού (ορχηστρωτές των ορχηστρωτών), υπηρεσίες συνάθροισης ή απλώς ένας εκθέτης. Οι εκθέτες είναι σαν ελεγκτές, υπηρεσίες προβολής, στοιχεία διεπαφής χρήστη (UI) ή μια άλλη υπηρεσία θεμελίωσης ή επεξεργασίας στην περίπτωση που τοποθετούνται μηνύματα πίσω σε μια ουρά - το οποίο θα συζητήσουμε περαιτέρω στο πρότυπο μας.

## 2.3.2 Χαρακτηριστικά

Γενικά, οι υπηρεσίες ορχήστρωσης ασχολούνται με τον συνδυασμό λειτουργιών μονάδας οντότητας πρωτεύοντος επιπέδου ή υψηλότερης τάξης για την εκτέλεση ενός επιτυχημένου ροής. Μπορείτε όμως επίσης να τα θεωρήσετε ως τη "κόλλα" που ενώνει πολλές λειτουργίες μονάδας οντότητας μαζί.

### 2.3.2.0 Γλώσσα

Όπως και οι υπηρεσίες επεξεργασίας, η γλώσσα που χρησιμοποιείται στις υπηρεσίες ορχήστρωσης καθορίζει το επίπεδο πολυπλοκότητας και τις δυνατότητες που προσφέρει.
Συνήθως, οι υπηρεσίες ορχήστρωσης συνδυάζουν δύο ή περισσότερες πρωτεύοντες ή υψηλότερης τάξης λειτουργίες από πολλές υπηρεσίες μονάδας οντότητας για την εκτέλεση μιας επιτυχημένης λειτουργίας.

#### 2.3.2.0.0 Γλώσσα Λειτουργιών

Οι υπηρεσίες ορχήστρωσης έχουν μια κοινή χαρακτηριστική σχετικά με τη γλώσσα των λειτουργιών τους. Οι υπηρεσίες ορχήστρωσης είναι ολιστικές στην πλειοψηφία της γλώσσας των λειτουργιών τους. Θα δείτε λειτουργίες όπως `NotifyAllAdmins`, όπου η υπηρεσία ανακτάει όλους τους χρήστες με τύπο διαχειριστή και στη συνέχεια καλεί μια υπηρεσία ειδοποιήσεων για να τους ειδοποιήσει.

Οι υπηρεσίες ορχήστρωσης προσφέρουν λειτουργικότητα που πλησιάζει όλο και περισσότερο την επιχειρηματική γλώσσα από τις πρωτεύουσες τεχνικές λειτουργίες. Μπορεί να δείτε μια σχεδόν ίδια έκφραση σε μια μη τεχνική επιχειρηματική απαίτηση που ταιριάζει με το όνομα μιας λειτουργίας σε μια υπηρεσία ορχήστρωσης. Το ίδιο πρότυπο συνεχίζεται καθώς κάποιος προχωρά σε υψηλότερες και πιο προηγμένες κατηγορίες υπηρεσιών μέσα σε αυτό το πεδίο της επιχειρηματικής λογικής.

#### 2.3.2.0.1 Διέλευση (Pass-Through)

Οι υπηρεσίες ορχήστρωσης μπορούν επίσης να λειτουργήσουν ως διέλευση για ορισμένες λειτουργίες. Για παράδειγμα, μια υπηρεσία ορχήστρωσης θα μπορούσε να επιτρέψει το `AddStudentAsync` να μεταδοθεί μέσω της υπηρεσίας για να ενοποιηθεί η πηγή των αλληλεπιδράσεων με το σύστημα στο επίπεδο των εκθετών. Σε αυτήν την περίπτωση, οι υπηρεσίες ορχήστρωσης θα χρησιμοποιήσουν την ίδια ορολογία που μια επεξεργαστική ή θεμελιώδης υπηρεσία μπορεί να χρησιμοποιήσει για τη μεταβίβαση της λειτουργίας.

#### 2.3.2.0.2 Class-Level Language

Οι υπηρεσίες ενορχήστροσης συνδυάζουν κυρίως πολλαπλές λειτουργίες που υποστηρίζουν ένα συγκεκριμένο στοιχείο. Έτσι, εάν το κύριο στοιχείο είναι ο `Student` και τα υπόλοιπα στοιχεία υπάρχουν μόνο για να υποστηρίξουν μια λειτουργία που στοχεύει κυρίως σε ένα στοιχείο `Student` - τότε το όνομα της υπηρεσίας ενορχήστρωσης θα ήταν `StudentOrchestrationService`.

Η επιβολή των συμβάσεων ονοματολογίας διασφαλίζει ότι κάθε υπηρεσία ενορχήστρωσης παραμένει εστιασμένη στην ευθύνη ενός μόνο στοιχείου σχετικά με πολλά άλλα υποστηρικτικά στοιχεία.

Για παράδειγμα, η δημιουργία ενός κάρτας βιβλιοθήκης απαιτεί τη σχολική εγγραφή του φοιτητή που αναφέρεται σε εκείνη την κάρτα βιβλιοθήκης. Σε αυτήν την περίπτωση, το όνομα της υπηρεσίας ενορχήστρωσης θα αντικατοπτρίζει το κύριο στοιχείο της, `LibraryCard`. Το όνομα της υπηρεσίας ενορχήστρωσης θα ήταν, λοιπόν, `StudentOrchestrationService`.

Το αντίθετο ισχύει επίσης. Εάν η εγγραφή ενός φοιτητή σε μια σχολή έχει συνδεδεμένες λειτουργίες όπως η δημιουργία ενός κάρτας βιβλιοθήκης, τότε, σε αυτήν την περίπτωση, πρέπει να υπάρχει μια `StudentOrchestrationService` για να δημιουργηθεί ένας `Student` και όλα τα σχετικά στοιχεία.

Η ίδια ιδέα ισχύει για όλες τις εξαιρέσεις που δημιουργούνται σε μια υπηρεσία ενορχήστρωσης, όπως `StudentOrchestrationValidationException` και `StudentOrchestrationDependencyException`.

### 2.3.2.1 Εξαρτήσεις

Όπως αναφέραμε παραπάνω, οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν ένα ευρύτερο φάσμα εξαρτήσεων σε σύγκριση με τις υπηρεσίες επεξεργασίας και θεμελίωσης, λόγω της προαιρετικότητας των υπηρεσιών επεξεργασίας. Επομένως, οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν εξαρτήσεις που κυμαίνονται από υπηρεσίες θεμελίωσης ή προαιρετικές υπηρεσίες επεξεργασίας μέχρι διασταυρούμενες υπηρεσίες όπως καταγραφή καταγραφής ή άλλοι διαμεσολαβητές χρησιμότητας.

#### 2.3.2.1.0 Ισορροπία Εξαρτήσεων (Πρότυπο Florance)

Ένα θεμελιώδες κανόνα που διέπει τη συνέπεια και την ισορροπία των υπηρεσιών ενορχήστρωσης είναι το 'Πρότυπο Florance', το οποίο καθορίζει ότι κάθε υπηρεσία ενορχήστρωσης δεν μπορεί να συνδυάζει εξαρτήσεις από διαφορετικές κατηγορίες λειτουργίας.

Αυτό σημαίνει ότι μια υπηρεσία ενορχήστρωσης δεν μπορεί να συνδυάσει υπηρεσίες θεμελίωσης και επεξεργασίας. Οι εξαρτήσεις πρέπει να είναι είτε όλες επεξεργασίας είτε όλες θεμελίωσης. Αυτός ο κανόνας δεν ισχύει για τις εξαρτήσεις διαμεσολαβητών χρησιμότητας, ωστόσο.

Εδώ υπάρχει ένα παράδειγμα μιας μη ισορροπημένης εξάρτησης υπηρεσιών ενορχήστρωσης:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415856-9e5e5f80-b661-11eb-96db-a541f89ccee7.png" />
    </p>
<br />

Απαιτείται μια επιπλέον υπηρεσία επεξεργασίας για να παρέχει ένα πέρασμα προς μια χαμηλότερου επιπέδου υπηρεσία θεμελίωσης για να ισορροπήσει την αρχιτεκτονική - εφαρμόζοντας το 'Πρότυπο Florance' για συμμετρία θα μετασχηματίσει την αρχιτεκτονική μας στην ακόλουθη μορφή:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415965-33f9ef00-b662-11eb-8538-59e5c728d308.png" />
    </p>
<br />

Η εφαρμογή του 'Προτύπου Florance' μπορεί να είναι πολύ δαπανηρή αρχικά, καθώς περιλαμβάνει τη δημιουργία μιας εντελώς νέας υπηρεσίας επεξεργασίας (ή πολλαπλών) για να ισορροπήσει την αρχιτεκτονική. Ωστόσο, τα οφέλη του υπερβαίνουν το κόστος από την άποψη της συντηρησιμότητας, της αναγνωσιμότητας και της ευκολίας αντικατάστασης.

#### 2.3.2.1.1 Two-Three

Ο "Κανόνας Δύο-Τρία" είναι ένας κανόνας ελέγχου της πολυπλοκότητας. Αυτός ο κανόνας καθορίζει ότι μια υπηρεσία ενορχήστρωσης δεν πρέπει να έχει περισσότερες από τρεις ή λιγότερες από δύο υπηρεσίες επεξεργασίας ή θεμελίωσης για την εκτέλεση της ενορχήστρωσης. Αυτός ο κανόνας, ωστόσο, δεν ισχύει για τους διαμεσολαβητές χρησιμότητας. Οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν έναν `DateTimeBroker` ή έναν `LoggingBroker` χωρίς καμία περιορισμένη.

Αλλά μια υπηρεσία ενορχήστρωσης δεν πρέπει να έχει έναν διαμεσολαβητή οντότητας, όπως έναν `StorageBroker` ή έναν `QueueBroker`, που τροφοδοτεί απευθείας τον πυρήνα του επιχειρηματικού επιπέδου οποιασδήποτε υπηρεσίας.

Αυτός ο κανόνας, όπως και τα περισσότερα από τα μοτίβα και τα έννοια στο Πρότυπο, εμπνέεται από τη φύση. Μπορείτε να δείτε πώς τα δένδρα διχοτομούνται σε δύο και τρία - το ίδιο συμβαίνει για τους κεραυνούς, τα αιμοφόρα αγγεία και τόσες άλλες δημιουργίες γύρω μας, μέσα μας και πάνω από εμάς ακολουθούν το ίδιο πρότυπο.

<br />
    <p align="center" >
        <img width="50%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard/master/2.%20Services/2.3%20Orchestrations/Resources/2.3.2.1.1%20Two-Three.png" />
    </p>
<br />

Ένα δέντρο κλαδεύει καθώς αναπτύσσεται προς τα πάνω, αλλά και στις ίδιες του τις ρίζες. Και αυτό ισχύει και για τις υπηρεσίες ενορχήστρωσης και ενορχήστρωσης-παρόμοιες. Μπορούν να κλαδευτούν περαιτέρω προς τα πάνω, όπως θα εξηγήσω εδώ σύντομα, αλλά επίσης και προς τα κάτω μέσω προτύπων όπως το πρότυπο Cul-De-Sac.

Ο "Κανόνας Δύο-Τρία" μπορεί να απαιτήσει ένα επίπεδο κανονικοποίησης προς την κατηγορική επιχειρηματική λειτουργία. Ας μιλήσουμε για τους διάφορους μηχανισμούς κανονικοποίησης των υπηρεσιών ενορχήστρωσης.

##### 2.3.2.1.1.0 Πλήρης Κανονικοποίηση

Συχνά υπάρχουν περιπτώσεις όπου η τρέχουσα αρχιτεκτονική οποιασδήποτε δεδομένης υπηρεσίας ενορχήστρωσης καταλήγει με μια υπηρεσία ενορχήστρωσης με τρεις εξαρτήσεις. Και απαιτείται μια νέα υπηρεσία επεξεργασίας ή θεμελίωσης οντότητας για να ολοκληρωθεί μια υπάρχουσα διαδικασία.

Για παράδειγμα, ας υποθέσουμε ότι έχουμε μια `StudentContactOrchestrationService` και αυτή η υπηρεσία έχει εξαρτήσεις που παρέχουν λειτουργικότητα σε επίπεδο αρχής για την`Address`, `Email` και το `Phone` για κάθε φοιτητή. Εδώ υπάρχει μια οπτικοποίηση αυτής της κατάστασης:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101834-f636a500-c0fc-11eb-968b-10ed9a60bac8.png" />
    </p>
<br />


Τώρα, προστίθεται μια νέα απαίτηση, το 'ΚοινωνικόΜέσο', στο 'Φοιτητή', για να συγκεντρωθούν περισσότερες πληροφορίες επικοινωνίας σχετικά με τον τρόπο επικοινωνίας με έναν φοιτητή. Μπορούμε να μπούμε σε κατάσταση πλήρους κανονικοποίησης απλώς βρίσκοντας ένα κοινό σημείο που χωρίζει ισότιμα τις οντότητες πληροφοριών επικοινωνίας. Για παράδειγμα, μπορούμε να χωρίσουμε τις κανονικές πληροφορίες επικοινωνίας έναντι των ψηφιακών πληροφοριών επικοινωνίας, όπως στην `Address` και το `Phone` έναντι του `Email` και του `SocialMedia`. Με αυτόν τον τρόπο, χωρίζουμε τις τέσσερις εξαρτήσεις σε δύο, για κάθε υπηρεσία ενορχήστρωσης, ως εξής:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101983-c6d46800-c0fd-11eb-836a-496d191ef922.png" />
    </p>
<br />


Στο σχήμα παραπάνω, τροποποιήσαμε την υπάρχουσα `StudentContactOrchestrationService` σε `StudentRegularContactOrchestrationService` και αφαιρέσαμε μία από τις εξαρτήσεις της από την `EmailService`.

Επιπροσθέτως, δημιουργήσαμε μια νέα `StudentDigitalContactOrchestrationService` για να έχει δύο εξαρτήσεις από την υπάρχουσα `EmailService` και τη νέα `SocialMediaService`. Ως αποτέλεσμα, χρειαζόμαστε τώρα έναν προηγμένο λογικό επιχειρηματικό επίπεδο, όπως μια υπηρεσία συντονισμού, για να παρέχει πληροφορίες επικοινωνίας φοιτητών σε ροές δεδομένων προς τα άνω.

##### 2.3.2.1.1.1 Η Ημι-Κανονικοποίηση

Η κανονικοποίηση δεν είναι πάντα τόσο απλή όπως το παράδειγμα παραπάνω, ειδικά όταν μια πυρήνας οντότητας πρέπει να υπάρχει πριν δημιουργηθούν ή συμπληρωθούν πρόσθετες πληροφορίες για σχετικές οντότητες.

Για παράδειγμα, ας υποθέσουμε ότι έχουμε μια `StudentRegistrationOrchestrationService` που εξαρτάται από τις `StudentProcessingService`, `LibraryCardProcessingService`  και `BookProcessingService` ως εξής:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120099527-c41f4600-c0f0-11eb-8702-1439f966d9dc.png" />
    </p>
<br />

Αλλά τώρα, χρειαζόμαστε μια νέα υπηρεσία για τη διαχείριση των immunization των φοιτητών, ως `ImmunizationProcessingService`. Χρειαζόμαστε όλες τις τέσσερις υπηρεσίες, αλλά ήδη έχουμε μια `StudentRegistrationOrchestrationService` που έχει τρεις εξαρτήσεις. Σε αυτό το σημείο, απαιτείται μια ημι-κανονικοποίηση για την επαναζυμώση της αρχιτεκτονικής για να τηρηθεί ο "Κανόνας Δύο-Τρία" και, τελικά, να ελεγχθεί η πολυπλοκότητα.

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100296-ea46e500-c0f4-11eb-888a-ed6668e9ffdb.png" />
    </p>
<br />


Σε αυτήν την περίπτωση, απαιτείται περαιτέρω κανονικοποίηση ή διαίρεση για να επαναζυμώσει την αρχιτεκτονική. Πρέπει να σκεφτούμε έννοιες για το κοινό έδαφος μεταξύ των αρχέτυπων οντοτήτων σε μια διαδικασία εγγραφής φοιτητή. Οι απαιτήσεις του φοιτητή περιλαμβάνουν ταυτότητα, υγεία και υλικά. Σε αυτό το σενάριο, μπορούμε να συνδυάσουμε το `LibraryCard` και το `Book` υπό την ίδια υπηρεσία ενορχήστρωσης, αφού τα βιβλία και οι βιβλιοθήκες σχετίζονται κάπως. Έτσι, θα είχαμε την `StudentLibraryOrchestrationService`, και για την άλλη υπηρεσία θα είχαμε την `StudentHealthOrchestrationService` ως εξής:

Σε αυτήν την περίπτωση, απαιτείται περαιτέρω κανονικοποίηση ή διαίρεση για την επαναζυμώσει της αρχιτεκτονικής. Πρέπει να σκεφτούμε έννοιες για το κοινό έδαφος μεταξύ των αρχέτυπων οντοτήτων σε μια διαδικασία εγγραφής φοιτητή. Οι απαιτήσεις του φοιτητή περιλαμβάνουν ταυτότητα, υγεία και υλικά. Σε αυτό το σενάριο, μπορούμε να συνδυάσουμε το `LibraryCard` και το `Book` υπό την ίδια υπηρεσία ενορχήστρωσης, καθώς τα βιβλία και οι βιβλιοθήκες σχετίζονται κάπως. Έτσι, θα είχαμε την `StudentLibraryOrchestrationService`, και για την άλλη υπηρεσία θα είχαμε την `StudentHealthOrchestrationService` όπως παρακάτω:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100597-68f05200-c0f6-11eb-9ccc-ae1c963f6de5.png" />
    </p>
 <br />

Για να ολοκληρωθεί η διαδικασία εγγραφής με ένα νέο μοντέλο, μια υπηρεσία συντονισμού πρέπει να περάσει προηγμένη επιχειρησιακή λογική για να συνδυάσει αυτές τις οντότητες. Ωστόσο, θα παρατηρήσετε ότι κάθε υπηρεσία ενορχήστρωσης έχει μια περιττή εξάρτηση από την `StudentProcessingService` για να διασφαλίσει ότι δεν υπάρχει εικονική εξάρτηση από οποιαδήποτε άλλη υπηρεσία ενορχήστρωσης, δημιουργώντας / εξασφαλίζοντας την ύπαρξη ενός εγγραφής φοιτητή.

Οι εικονικές εξαρτήσεις είναι πολύ δύσκολες. Είναι μια κρυφή σύνδεση μεταξύ δύο υπηρεσιών οποιασδήποτε κατηγορίας, όπου μια υπηρεσία υποθέτει αυτομάτως ότι μια συγκεκριμένη οντότητα θα δημιουργηθεί και θα είναι παρούσα. Οι εικονικές εξαρτήσεις είναι πολύ επικίνδυνες και απειλούν την κατάλληλη αυτονομία οποιασδήποτε υπηρεσίας. Η ανίχνευση εικονικών εξαρτήσεων στα πρώιμα στάδια του σχεδιασμού και της ανάπτυξης μπορεί να είναι μια δύσκολη αλλά απαραίτητη διαδικασία για να εξασφαλίσει ότι υπάρχει μια καθαρή, Κανονισμένη αρχιτεκτονική.

Όπως οι αλλαγές στο μοντέλο απαιτούν μεταναστεύσεις δομής βάσης δεδομένων και επιπλέον λογική και επικυρώσεις, η νέα απαίτηση για μια νέα οντότητα μπορεί να απαιτήσει την αναδιάρθρωση μιας υπάρχουσας αρχιτεκτονικής ή την επέκτασή της σε μια νέα έκδοση, ανάλογα με το ποιο στάδιο λαμβάνει το σύστημα αυτές τις νέες απαιτήσεις.

Μπορεί να είναι πολύ ελκυστικό να προσθέσετε μια ακόμα εξάρτηση σε μια υπάρχουσα υπηρεσία ενορχήστρωσης, αλλά αυτό είναι το σημείο όπου το σύστημα αρχίζει να αποκλίνει από το "Το Πρότυπο". Και αυτό είναι όταν το σύστημα αρχίζει να γίνεται ένα αδύναμο σύστημα που δυσκολεύεται να συντηρηθεί. Αλλά, πιο σημαντικά, αυτό το σενάριο δοκιμάζει τις αρχές σχεδίασης και τα πρότυπα της τεχνογνωσίας των μηχανικών που συμμετέχουν στον σχεδιασμό και την ανάπτυξη του συστήματος.

##### 2.3.2.1.1.2 Χωρίς Κανονικοποίηση

Πιστεύω ότι τα πάντα, παντού, κάπως συνδέονται. Ωστόσο, υπάρχουν σενάρια όπου είναι δύσκολο να επιτευχθούν υψηλότερα επίπεδα κανονικοποίησης. Μερικές φορές, μπορεί να είναι ακατανόητο για το μυαλό να ομαδοποιήσει πολλές υπηρεσίες κάτω από μια υπηρεσία ενορχήστρωσης.

Επειδή είναι αρκετά δύσκολο για το μυαλό μου να σκεφτεί ένα παράδειγμα για πολλαπλές οντότητες που δεν έχουν καμία σύνδεση μεταξύ τους, καθώς πιστεύω ανεξίτηλα ότι αυτό δεν θα μπορούσε να υπάρξει. Θα βασιστώ σε μερικές φανταστικές οντότητες για να απεικονίσω ένα πρόβλημα. Έτσι, ας υποθέσουμε ότι υπάρχουν οι `AService` και `BService` που ορχηστροποιούνται μαζί με μια `XService`. Η ύπαρξη της `XService` είναι σημαντική για να διασφαλιστεί ότι και οι δύο `A` και `B` μπορούν να δημιουργηθούν με την εγγύηση ότι υπάρχει μια πυρήνας οντότητας `X`.

Τώρα, ας υποθέσουμε ότι απαιτείται η προσθήκη μιας νέας υπηρεσίας `CService` στο μείγμα για να ολοκληρωθεί η υπάρχουσα ροή. Έτσι, τώρα έχουμε τέσσερις διαφορετικές εξαρτήσεις κάτω από μια υπηρεσία ενορχήστρωσης, και η διαίρεση είναι υποχρεωτική. Επειδή δεν υπάρχει καμία σχέση μεταξύ των `A`, `B` και `C`, μια προσέγγιση 'Χωρίς Κανονικοποίηση' γίνεται η μοναδική επιλογή για να υλοποιηθεί ένα νέο σχέδιο όπως παρακάτω:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120102975-4d8b4400-c102-11eb-9582-6f95d17227e7.png" />
    </p>
 <br />

Κάθε μία από τις παραπάνω πρωταρχικές υπηρεσίες θα ορχηστροποιηθεί με μια πυρήνας υπηρεσία `X` και στη συνέχεια θα συγκεντρωθούν υπό μια υπηρεσία συντονισμού. Το παραπάνω περιστατικό είναι το χειρότερο δυνατό σενάριο, όπου η κανονικοποίηση οποιουδήποτε μεγέθους είναι αδύνατη. Σημειώστε ότι ο συντάκτης αυτού του Προτύπου δεν μπόρεσε να προσφέρει ένα ρεαλιστικό παράδειγμα ανάλογο με τα υπόλοιπα, για να σας δείξει πόσο σπάνιο είναι να αντιμετωπίσετε αυτήν την κατάσταση. Έτσι, ας αποτελέσει η προσέγγιση 'Χωρίς Κανονικοποίηση' την πολύ τελευταία σας λύση εάν εξαντληθούν οι επιλογές σας.

##### 2.3.2.1.1.3 Σημαντική Ανάλυση

Ανεξάρτητα από τον τύπο της κανονικοποίησης που ακολουθείτε, πρέπει να διασφαλίσετε ότι οι ομαδοποιημένες υπηρεσίες σας αντιπροσωπεύουν ένα κοινό νόημα. Για παράδειγμα, η σύνδεση μιας `StudentProcessingService` και μιας `LibraryProcessingService` πρέπει να απαιτεί μια λειτουργική κοινοτικότητα. Ένα καλό παράδειγμα αυτού θα ήταν η `StudentRegistrationOrchestrationService`, για παράδειγμα. Η διαδικασία εγγραφής απαιτεί την προσθήκη ενός νέου εγγραφής φοιτητή και τη δημιουργία κάρτας βιβλιοθήκης για τον ίδιο ακριβώς φοιτητή.

Η υλοποίηση υπηρεσιών ενορχήστρωσης χωρίς την διασταύρωση μεταξύ δύο ή τριών οντοτήτων ανά λειτουργία καταστρέφει τον σκοπό της ύπαρξης μιας υπηρεσίας ενορχήστρωσης. Αυτή η συνθήκη ικανοποιείται εάν έχει συμβεί τουλάχιστον μία διασταύρωση μεταξύ δύο οντοτήτων. Μια υπηρεσία ενορχήστρωσης μπορεί να έχει και άλλες λειτουργίες 'Προώθησης' όπου προωθούμε συγκεκριμένες διαδικασίες από τις επεξεργαστικές ή θεμελιώδεις πηγές τους εάν ταιριάζουν με την ίδια σύμβαση.

Ένα παράδειγμα:

```csharp
public class StudentOrchestrationService
{
    public async ValueTask<Student> RegisterStudentAsync(Student student)
    {
        Student addedStudent =
            await this.studentProcessingService.AddStudentAsync(student);
    
        LibraryCard libraryCard = 
            await this.libraryCardPorcessingService.AddLibraryCardAsync(
                addedStudent.Id);

        return addedStudent;
    }


    public async ValueTask<Student> ModifyStudentAsync(Student student) =>
        await this.studentProcessingService.ModifyStudentAsync(student);
}
```

Στο παραπάνω παράδειγμα, η `StudentOrchestrationService`  μας είχε μια διαδικασία ενορχήστρωσης που συνδύαζε την προσθήκη ενός φοιτητή και τη δημιουργία ενός κάρτας βιβλιοθήκης για αυτόν τον φοιτητή. Ωστόσο, επιπλέον, προσφέρει επίσης μια λειτουργία 'Προώθησης' για μια διαδικασία επεξεργασίας χαμηλού επιπέδου για την τροποποίηση ενός φοιτητή.

Οι διαδικασίες 'Προώθησης' πρέπει να έχουν την ίδια σύμβαση με τις άλλες διαδικασίες σε οποιαδήποτε υπηρεσία ενορχήστρωσης. Η αρχή μας της 'Καθαρής Σύμβασης' διατάζει ότι οποιαδήποτε υπηρεσία πρέπει να επιτρέπει την ίδια σύμβαση ως είσοδο και έξοδο ή πρωτογενείς τύπους.

### 2.3.2.2 Contracts
Οι υπηρεσίες ενορχήστρωσης μπορεί να συνδυάζουν δύο ή τρεις διαφορετικές οντότητες και τις λειτουργίες τους για να επιτύχουν μια υψηλότερη επιχειρησιακή λογική. Υπάρχουν δύο σενάρια για συμβάσεις/μοντέλα υπηρεσιών ενορχήστρωσης: Ένα που παραμένει πιστό στον βασικό σκοπό της πρωταρχικής οντότητας· και ένα που είναι περίπλοκο - μια υπηρεσία ενορχήστρωσης συνδυασμού που προσπαθεί να αποκαλύψει ρητά τις εσωτερικές στόχες της.

Ας μιλήσουμε λεπτομερώς για αυτά τα δύο σενάρια.

#### 2.3.2.2.0 Φυσικές Συμβάσεις
Ορισμένες υπηρεσίες ενορχήστρωσης παραμένουν μονόσκοπες, ακόμη κι αν συνδυάζουν δύο ή τρεις άλλες ρουτίνες υψηλότερης τάξης από πολλαπλές οντότητες. Για παράδειγμα, μια υπηρεσία ενορχήστρωσης που αντιδρά σε μηνύματα από ορισμένη ουρά και στη συνέχεια διατηρεί αυτά τα μηνύματα είναι υπηρεσίες μονόσκοπου και μοναδικής οντότητας ενορχήστρωσης.

Ας ρίξουμε μια ματιά σε αυτό το απόσπασμα κώδικα:

```csharp

public class StudentOrchestrationService
{
    private readonly IStudentEventProcessingService studentEventProcessingService;
    private readonly IStudentProcessingService studentProcessingService;

    public StudentOrchestrationService(
        IStudentEventProcessingService studentEventProcessingService,
        IStudentProcessingService studentProcessingService)
    {
        this.studentEventProcessingService = studentEventProcessingService;
        this.studentProcessingService = studentProcessingService;
        ListenToEvents();
    }

    public void ListenToEvents() =>
        this.studentEventService.ListenToEvent(UpsertStudentAsync);

    public async ValueTask<Student> UpsertStudentAsync(Student student)
    {
        ...
        await this.studentProcessingService.UpsertStudentAsync(student);

        ...
    }
}
```

Στο παραπάνω παράδειγμα, η υπηρεσία ενορχήστρωσης εξακολουθεί να αποκαλύπτει λειτουργίες που τιμούν το φυσικό μοντέλο `Student` και επικοινωνεί εσωτερικά με αρκετές υπηρεσίες που μπορεί να παρέχουν εντελώς διαφορετικά μοντέλα. Αυτά είναι τα σενάρια όπου μια μεμονωμένη οντότητα έχει έναν κύριο σκοπό και όλες οι άλλες υπηρεσίες είναι υπηρεσίες υποστήριξης για να διασφαλιστεί μια επιτυχημένη ροή για αυτήν την οντότητα.

Στο παράδειγμά μας, οι υπηρεσίες ενορχήστρωσης "ακούν" μια ουρά για νέα μηνύματα φοιτητών, στη συνέχεια χρησιμοποιούν αυτό το γεγονός για να διατηρήσουν οποιουσδήποτε νεοεισερχόμενους φοιτητές στο σύστημα. Έτσι, η σύμβαση `Student` είναι η ίδια γλώσσα που η υπηρεσία ενορχήστρωσης χρησιμοποιεί ρητά ως μοντέλο για να επικοινωνήσει με υπηρεσίες/εκθέτες ροής προς τα πάνω ή άλλους.

Ωστόσο, υπάρχουν και άλλα σενάρια όπου μια μεμονωμένη οντότητα δεν είναι ο μόνος σκοπός/στόχος για μια υπηρεσία ενορχήστρωσης. Ας μιλήσουμε για αυτό αναλυτικά.

#### 2.3.2.2.1 Εικονικές Συμβάσεις
Σε ορισμένα σενάρια, μια υπηρεσία ενορχήστρωσης μπορεί να απαιτείται να δημιουργήσει μη-φυσικές συμβάσεις για να ολοκληρώσει μια συγκεκριμένη λειτουργία. Για παράδειγμα, να λάβουμε μια υπηρεσία ενορχήστρωσης που απαιτείται να διατηρήσει μια ανάρτηση στα κοινωνικά μέσα που περιέχει μια εικόνα. Η απαίτηση εδώ είναι να διατηρήσουμε την εικόνα σε μια βάση δεδομένων και την πραγματική ανάρτηση (σχόλια, συγγραφείς και άλλα) σε μια διαφορετική πίνακα βάσης δεδομένων σε ένα σχεσιακό μοντέλο.

Το εισερχόμενο μοντέλο μπορεί να είναι σημαντικά διαφορετικό από τα πραγματικά φυσικά μοντέλα. Ας δούμε πώς θα μοιάζει αυτό στον πραγματικό κόσμο.

Σκεφτείτε να έχετε αυτό το μοντέλο:

```csharp
public class MediaPost
{
    public Guid Id {get; set;}
    public string Content {get; set;}
    public DateTimeOffset Date {get; set;}
    public IEnumerable<string> Base64Images {get; set;}
}
```

Η παραπάνω σύμβαση `MediaPost` περιλαμβάνει δύο διαφορετικές φυσικές οντότητες που συνδυάζονται. Η πρώτη είναι η πραγματική ανάρτηση, περιλαμβάνοντας τα `Id`, `Content` και `Date`, και η δεύτερη είναι η λίστα των εικόνων που συνδέονται με αυτήν την ανάρτηση.

Εδώ είναι πώς μια υπηρεσία ενορχήστρωσης θα αντιδρούσε σε αυτό το εισερχόμενο εικονικό μοντέλο:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

public Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

public List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}
```

Ο παραπάνω απόσπασμα κώδικα δείχνει την υπηρεσία ενορχήστρωσης να αποδομεί ένα δοθέν εικονικό μοντέλο/σύμβαση `MediaPost` σε δύο φυσικά μοντέλα. Καθένα από αυτά έχει τη δική του ξεχωριστή υπηρεσία επεξεργασίας που χειρίζεται τη διατήρησή του. Υπάρχουν σενάρια όπου το εικονικό μοντέλο αποδομείται σε ένα μόνο μοντέλο με επιπρόσθετες λεπτομέρειες που χρησιμοποιούνται για τον έλεγχο και την επαλήθευση με τις κάτωρθεν υπηρεσίες επεξεργασίας ή θεμελίωσης.

Υπάρχουν επίσης υβριδικές καταστάσεις όπου το εισερχόμενο εικονικό μοντέλο μπορεί να έχει εμφωλευμένα φυσικά μοντέλα, κάτι που μπορούμε να επιτρέψουμε μόνο με εικονικά μοντέλα. Τα φυσικά μοντέλα πρέπει να παραμένουν αναιμικά (να μην περιέχουν ρουτίνες ή δημιουργούς) και επίπεδα (να μην περιέχουν εμφωλευμένα μοντέλα) σε όλη τη διάρκεια για να ελέγξουμε την πολυπλοκότητα και να εστιάσουμε την ευθύνη.

Συνοψίζοντας, οι υπηρεσίες ενορχήστρωσης μπορούν να δημιουργούν τις δικές τους συμβάσεις. Αυτές οι συμβάσεις μπορεί να είναι φυσικές ή εικονικές. Και μια εικονική σύμβαση μπορεί να είναι μια συνδυασμένη μορφή ενός ή πολλών φυσικών (ή εμφωλευμένων εικονικών) συμβάσεων ή απλώς να έχει το δικό της επίπεδο σχεδιασμό όσον αφορά τις ιδιότητες.

### 2.3.2.2 Αδιέξοδο (Cul-De-Sac)
Μερικές φορές, οι υπηρεσίες ενορχήστρωσης και οι αντίστοιχες (συντονισμός, διαχείριση κλπ.) ενδέχεται να μην χρειάζονται μια συνιστώσα εκθέτη (π.χ. ελεγκτή). Αυτό συμβαίνει επειδή αυτές οι υπηρεσίες μπορεί να λειτουργούν ως ακροατές για συγκεκριμένα γεγονότα και να επικοινωνούν το γεγονός πίσω σε μια υπηρεσία επεξεργασίας ή θεμελίωσης στο ίδιο επίπεδο όπου ξεκίνησε ή λήφθηκε το γεγονός.

Για παράδειγμα, τα εισερχόμενα μηνύματα μπορούν να λαμβάνονται από μια συνδρομή σε μια υπηρεσία γεγονότων ή μια ουρά. Σε αυτήν την περίπτωση, η είσοδος για αυτές τις υπηρεσίες δεν είναι απαραίτητα μέσω μιας συνιστώσας εκθέτη πλέον. Φανταστείτε να δημιουργείτε μια απλή εφαρμογή όπου ειδοποιείται με μηνύματα από μια ουρά και στη συνέχεια αντιστοιχεί αυτά τα μηνύματα σε ένα τοπικό μοντέλο για να τα διατηρήσει στην αποθήκευση. Σε αυτήν την περίπτωση, η υπηρεσία ενορχήστρωσης θα μοιάζει κάπως όπως παρακάτω:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/144501231-11ea13c9-81fa-4730-8840-a891a1d9edde.png" />
    </p>
 <br />

Η υπηρεσία `StudentEventOrchestrationService` ακούει για μηνύματα για νέους φοιτητές που έρχονται και αμέσως τα μετατρέπει σε μοντέλα που μπορούν να αποθηκευτούν στη βάση δεδομένων.

Εδώ υπάρχει ένα παράδειγμα:

Ας ξεκινήσουμε με ένα μονάδικο τεστ για αυτό το πρότυπο όπως ακολούθως:
 ```csharp
[Fact]
public void ShouldListenToProfileEvents()
{
    // given . when
    this.profileEventOrchestrationService.ListenToProfileEvents();

    // then
    this.profileEventServiceMock.Verify(service =>
        service.ListenToProfileEvent(
            this.profileEventOrchestrationService.ProcessProfileEventAsync),
                Times.Once);

    this.profileEventService.VerifyNoOtherCalls();
    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

[Fact]
public async Task ShouldAddProfileAsync()
{
    // given
    ProfileEvent randomProfileEvent =
        CreateRandomProfileEvent();

    ProfileEvent inputProfileEvent =
        randomProfileEvent;

    this.profileServiceMock.Setup(service =>
        service.AddProfileAsync(inputProfileEvent.Profile));

    // when
    await this.profileEventOrchestrationService
        .ProcessProfileEventAsync(inputProfileEvent);

    // then
    this.profileServiceMock.Verify(service =>
        service.AddProfileAsync(inputProfileEvent.Profile),
            Times.Once);

    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.profileEventServiceMock.VerifyNoOtherCalls();
}
 ```

Το τεστ εδώ υποδεικνύει ότι πρέπει να πραγματοποιηθεί πρώτα η ακρόαση ενός γεγονότος, και στη συνέχεια η λογική διατήρησης στην υπηρεσία φοιτητή πρέπει να ταιριάζει με το αποτέλεσμα της αντιστοίχισης ενός εισερχόμενου μηνύματος σε έναν δοσμένο φοιτητή.

Ας προσπαθήσουμε να κάνουμε αυτό το τεστ να περάσει.

 ```csharp
public partial class ProfileEventOrchestrationService : IProfileEventOrchestrationService
{
    private readonly IProfileEventService profileEventService;
    private readonly IProfileService profileService;
    private readonly ILoggingBroker loggingBroker;

    public ProfileEventOrchestrationService(
        IProfileEventProcessingService profileEventService,
        IProfileProcessingService profileService,
        ILoggingBroker loggingBroker)
    {
        this.profileEventService = profileEventService;
        this.profileService = profileService;
        this.loggingBroker = loggingBroker;
    }

    public void ListenToProfileEvents() =>
    TryCatch(() =>
    {
        this.profileEventService.ListenToProfileEvent(
            ProcessProfileEventAsync);
    });

    public ValueTask ProcessProfileEventAsync(ProfileEvent profileEvent) =>
    TryCatch(async () =>
    {
        ...

        await this.profileService.AddProfileAsync(profileEvent.Profile);
    });
}
 ```

Στο παραπάνω παράδειγμα, ο κατασκευαστής της υπηρεσίας ενορχήστρωσης εγγράφεται στα γεγονότα που θα προέρχονται από την υπηρεσία γεγονότων `StudentEventService`. Όταν συμβεί ένα γεγονός, η υπηρεσία ενορχήστρωσης θα καλέσει τη λειτουργία `ProcessingIncomingStudentMessageAsync` για να διατηρήσει τον εισερχόμενο φοιτητή στη βάση δεδομένων μέσω μιας υπηρεσίας θεμελίωσης ή επεξεργασίας στο ίδιο επίπεδο με την υπηρεσία γεγονότων.

Αυτό το πρότυπο ή χαρακτηριστικό ονομάζεται Cul-De-Sac (τυφλή αδιέξοδο). Ένα εισερχόμενο μήνυμα θα στρίψει και θα κατευθυνθεί σε διαφορετική κατεύθυνση για μια διαφορετική εξάρτηση. Αυτό το πρότυπο είναι τυπικό σε μεγάλες επιχειρηματικές εφαρμογές, όπου η τελική συνέπεια ενσωματώνεται για να διασφαλίσει ότι το σύστημα μπορεί να κλιμακωθεί και να γίνει ανθεκτικό υπό έντονη κατανάλωση. Αυτό το πρότυπο αποτρέπει επίσης κακόβουλες επιθέσεις κατά των σημείων ΑΠΙ σας, καθώς επιτρέπει την επεξεργασία μηνυμάτων ουράς ή γεγονότων όταν η υπηρεσία είναι έτοιμη να τα επεξεργαστεί. Θα συζητήσουμε τις λεπτομέρειες στην ενότητα 'The Standard Architecture'.

## 2.3.3 Ευθύνες
Οι υπηρεσίες ενορχήστρωσης παρέχουν προηγμένη επιχειρηματική λογική. Διαχειρίζονται τον συντονισμό πολλαπλών ροών για πολλές οντότητες/μοντέλα για να ολοκληρώσουν μια μόνο ροή. Ας συζητήσουμε αναλυτικά ποιες είναι αυτές οι ευθύνες:

### 2.3.3.0 Προηγμένη Λογική

Οι υπηρεσίες ενορχήστρωσης δεν μπορούν να υπάρχουν χωρίς να συνδυάζουν πολλαπλές διαδικασίες από πολλές οντότητες. Αυτές οι οντότητες μπορεί να διαφέρουν στη φύση τους, αλλά να μοιράζονται μια κοινή ροή ή σκοπό. Για παράδειγμα, ένα μοντέλο `LibraryCard` είναι θεμελιωδώς διαφορετικό από ένα μοντέλο `Student`. Ωστόσο, μοιράζονται έναν κοινό σκοπό σχετικά με τη διαδικασία εγγραφής φοιτητή. Η προσθήκη μιας εγγραφής φοιτητή απαιτείται για την εγγραφή ενός φοιτητή, αλλά η ανάθεση ενός κάρτ-βιβλιοθήκης σε αυτόν τον φοιτητή απαιτείται για μια επιτυχημένη διαδικασία εγγραφής φοιτητή.

Οι υπηρεσίες ενορχήστρωσης διασφαλίζουν ότι οι σωστές διαδικασίες για κάθε οντότητα είναι ενσωματωμένες, αλλά επίσης διασφαλίζουν ότι αυτές οι διαδικασίες καλούνται με τη σωστή σειρά. Επιπλέον, οι υπηρεσίες ενορχήστρωσης είναι υπεύθυνες για την ανατροπή μιας αποτυχημένης λειτουργίας. Αυτά τα τρία στοιχεία αποτελούν μια προσπάθεια ενορχήστρωσης ανάμεσα σε πολλές διαδικασίες, οντότητες ή συμβόλαια.

Ας μιλήσουμε γι' αυτά αναλυτικά.

#### 2.3.3.0.0 Flow Combinations
Μιλήσαμε νωρίτερα για τις υπηρεσίες ενορχήστρωσης που συνδυάζουν πολλές διαδικασίες για την επίτευξη ενός κοινού σκοπού ή μιας μόνης ροής. Αυτό το χαρακτηριστικό των υπηρεσιών ενορχήστρωσης μπορεί να λειτουργήσει τόσο ως ένα θεμελιώδες χαρακτηριστικό όσο και ως μια ευθύνη. Μια υπηρεσία ενορχήστρωσης που δε συνδυάζει τουλάχιστον μια διαδικασία που συνδυάζει δύο ή τρεις οντότητες δε θεωρείται ως υπηρεσία ενορχήστρωσης. Η ενσωμάτωση με πολλές υπηρεσίες χωρίς έναν κοινό σκοπό είναι μια πιο κατάλληλη ορισμένη για τις υπηρεσίες Συγκέντρωσης (Aggregation), τις οποίες θα συζητήσουμε αργότερα σε αυτό το κεφάλαιο για τις υπηρεσίες.

Αλλά μέσα στη συνδυασμένη ροή έρχεται η ενοποίηση της συμβατικής διεπαφής. Το αποκαλώ αντιστοίχιση και διακλάδωση. Αντιστοίχιση ενός εισερχόμενου μοντέλου σε πολλά μοντέλα χαμηλότερης ροής, και στη συνέχεια διακλάδωση της ευθύνης ανάμεσα σε αυτές τις υπηρεσίες.

Όπως και στις προηγούμενες υπηρεσίες, κατά τη διάρκεια του συνδυασμού της ροής τους, οι υπηρεσίες ενορχήστρωσης φέρουν ευθύνη για τη διασφάλιση της αγνότητας των αποκαλυφθεισών συμβολαιογραφικών περιεχομένων εισόδου και εξόδου, κάτι που γίνεται λίγο πιο περίπλοκο όταν συνδυάζονται πολλά μοντέλα. Οι υπηρεσίες ενορχήστρωσης θα συνεχίσουν να είναι υπεύθυνες για τον αντιστοίχιση των εισερχόμενων συμβολαιογραφικών περιεχομένων στις αντίστοιχες υπηρεσίες κάτω ρεύματος. Θα αντιστοιχίζουν επίσης τα αποτελέσματα που επιστρέφονται από αυτές τις υπηρεσίες πίσω στο ενοποιημένο μοντέλο.

Ας φέρουμε πίσω ένα προηγούμενο απόσπασμα κώδικα για να επισημάνουμε αυτήν την πτυχή:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

private Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

private List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}

private MediaPost MapToMediaPost(Post post, List<Media> medias)
{
    return new MediaPost
    {
        Id = post.Id,
        Content = post.Content,
        Date = post.CreatedDate,
        Base64Images = medias.Select(media => media.Image)
    }
}
```

Όπως μπορείτε να δείτε στο παραπάνω παράδειγμα, η αντιστοίχιση και η κλαδοποίηση δεν συμβαίνουν μόνο κατά την είσοδο. Πρέπει να γίνει και αντίστροφη ενέργεια κατά την έξοδο. Είναι παραβίαση του Προτύπου να επιστρέφετε το ίδιο αντικείμενο εισόδου που δόθηκε. Αυτό αφαιρεί οποιαδήποτε ορατότητα για πιθανές αλλαγές στο αίτημα εισόδου κατά τη διάρκεια της διατήρησης. Η διπλή αντιστοίχιση πρέπει να αντικαταστήσει την ανάγκη αναφοράς του εισερχόμενου αιτήματος για να διασφαλιστεί ότι δεν έχουν συμβεί απρόσμενες εσωτερικές αλλαγές.

Σημειώστε ότι η διαχωρισμένη λογική αντιστοίχισης σε ένα ανεξάρτητο αρχείο κλάσης (aspect/partial class file) συνίσταται επίσης. Κάτι σαν `StudentOrchestrationService`.Mappings.cs για να διασφαλιστεί ότι το μόνο πράγμα που παραμένει είναι η επιχειρηματική λογική της ενορχήστρωσης.

#### 2.3.3.0.1 Σειρά Κλήσης
Η σειρά κλήσης των διαδικασιών μπορεί να είναι κρίσιμη για οποιαδήποτε διαδικασία ενορχήστρωσης. Για παράδειγμα, μια κάρτα βιβλιοθήκης δεν μπορεί να δημιουργηθεί εκτός αν πρώτα δημιουργηθεί ένα αρχείο φοιτητή. Η επιβολή της σειράς εδώ μπορεί να διακλαδωθεί σε δύο διαφορετικούς τύπους. Ας μιλήσουμε λίγο για αυτούς εδώ.

##### 2.3.3.0.1.0 Φυσική Σειρά
Η φυσική σειρά εδώ αναφέρεται σε συγκεκριμένες ροές που δεν μπορούν να εκτελεστούν εκτός εάν ανακτηθούν ή διατηρηθούν προαπαιτούμενες παράμετροι εισόδου. Για παράδειγμα, φανταστείτε μια κατάσταση όπου μια κάρτα βιβλιοθήκης δεν μπορεί να δημιουργηθεί εκτός εάν ανακτηθεί πρώτα ο μοναδικός αναγνωριστικός κωδικός του φοιτητή. Σε αυτήν την περίπτωση, δεν πρέπει να ανησυχούμε για το να ελέγξουμε ότι ορισμένες διαδικασίες κλήθηκαν στη σωστή σειρά, καθώς αυτό συμβαίνει φυσικά με τη ροή.

Εδώ υπάρχει ένα παράδειγμα κώδικα για αυτήν την κατάσταση:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    Student student = await this.studentProcessingService
        .RetrieveStudentByIdAsync(libraryCard.StudentId));

    return await this.libraryCardProcessingService
        .CreateLibraryCardAsync(libraryCard, student.Name);
}
```

Στο παράδειγμα παραπάνω, η ύπαρξη του ονόματος ενός φοιτητή είναι απαραίτητη για τη δημιουργία μιας κάρτας βιβλιοθήκης. Επομένως, η σειρά των κλήσεων εδώ προκύπτει φυσικά ως μέρος της ροής χωρίς επιπρόσθετη προσπάθεια.

Ας μιλήσουμε τώρα για τον δεύτερο τύπο σειράς - την Επιβεβλημένη Σειρά.

##### 2.3.3.0.1.1 Επιβεβλημένη Σειρά

Φανταστείτε το ίδιο παράδειγμα που παραθέσαμε προηγουμένως, αλλά αντί να απαιτεί ένα όνομα φοιτητή για τη δημιουργία ενός βιβλιοθηκονόμου, απαιτεί μόνο το `Id` του φοιτητή που έχει ήδη καταχωρηθεί στο εισερχόμενο μοντέλο αιτήματος. Κάτι σαν το εξής:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    await this.studentProcessingService.VerifyEnlistedStudentExistAsync(
        libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
}
```

Να εξασφαλίσουμε ότι υπάρχει ένας εγγεγραμμένος και επαληθευμένος φοιτητής προτού δημιουργηθεί μια κάρτα βιβλιοθήκης μπορεί να αποτελέσει μια πρόκληση, καθώς δεν υπάρχει εξάρτηση μεταξύ της τιμής επιστροφής μιας διαδικασίας και των παραμέτρων εισόδου της επόμενης. Με άλλα λόγια, δεν υπάρχει κάτι που η λειτουργία `VerifyEnlistedStudentExistAsync` επιστρέφει που να ενδιαφέρει τη λειτουργία `CreateLibraryCardAsync` σε όρους παραμέτρων εισόδου.

Σε αυτήν την περίπτωση, πρέπει να εφαρμοστεί ένας τύπος επιβεβλημένης σειράς μέσω ενοτέρων δοκιμών. Μια δοκιμή μονάδας για αυτήν τη διαδικασία θα απαιτεί τόσο τον έλεγχο ότι η εξάρτηση έχει κληθεί με τις σωστές παραμέτρους όσο και ότι καλούνται με τη σωστή σειρά. Ας δούμε πώς θα εφαρμοζόταν αυτό:

```csharp
[Fact]
public async Task ShouldCreateLibraryCardAsync()
{
    // given
    Student someStudent = CreateRandomStudent();
    LibraryCard randomLibraryCard = CreateRandomLibraryCard();
    LibraryCard inputLibraryCard = randomLibraryCard;
    LibraryCard createdLibraryCard = inputLibraryCard;
    LibraryCard expectedLibraryCard = inputLibraryCard.DeepClone();
    Guid studentId = inputLibraryCard.StudentId;
    var mockSequence = new MockSequence();

    this.studentProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.VerifyEnlistedStudentExistAsync(studentId))
            .Returns(someStudent);

    this.libraryCardProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.CreateLibraryCardAsync(inputLibraryCard))
            .ReturnsAsync(createdLibraryCard);

    // when
    LibraryCard actualLibraryCard = await this.libraryCardOrchestrationService
        .CreateLibraryCardAsync(inputLibraryCard);

    // then
    actualLibraryCard.Should().BeEquivalentTo(expectedLibraryCard);

    this.studentProcessingServiceMock.Verify(service =>
        service.VerifyEnlistedStudentExistAsync(studentId),
            Times.Once);

    this.libraryCardProcessingServiceMock.Verify(service =>
        service.CreateLibraryCardAsync(inputLibraryCard),
            Times.Once);

    this.studentProcessingServiceMock.VerifyNoOtherCalls();
    this.libraryCardProcessingServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

```

Από το παραπάνω παράδειγμα, το πλαίσιο προσομοίωσης (mock framework) χρησιμοποιείται εδώ για να διασφαλίσει ότι μια συγκεκριμένη σειρά επιβάλλεται κατά την κλήση αυτών των εξαρτήσεων. Με αυτόν τον τρόπο επιβάλλουμε μια συγκεκριμένη υλοποίηση εντός κάθε μεθόδου, για να διασφαλίσουμε ότι οι εξαρτήσεις που δεν συνδέονται φυσικά καλούνται σε ακολουθία με την επιθυμητή σειρά.

Είναι πιθανότερο το είδος της σειράς να κλίνει περισσότερο προς την επιβεβλημένη παρά προς τη φυσική όταν οι υπηρεσίες ενορχήστρωσης φθάνουν στο μέγιστο αριθμό των εξαρτήσεων.

#### 2.3.3.0.2 Αντιστοίχιση Εξαιρέσεων (Εγκλωβισμός & Απελευθέρωση)
Αυτή η ευθύνη είναι πολύ παρόμοια με τον συνδυασμό ροής (flow combinations). Με τη διαφορά ότι σε αυτήν την περίπτωση, οι υπηρεσίες ενορχήστρωσης ενοποιούν όλες τις εξαιρέσεις που μπορεί να προκύψουν από οποιαδήποτε από τις εξαρτήσεις της σε ένα ενοποιημένο κατηγορικό μοντέλο εξαιρέσεων. Ας ξεκινήσουμε με μια εικονογράφηση του πώς μπορεί να φαίνεται αυτή η αντιστοίχιση:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/145294325-0818a2dd-a017-43af-b1f0-fa5c93a9218c.png" />
    </p>
 <br />

Στην παραπάνω εικόνα, θα παρατηρήσετε ότι οι εξαιρέσεις επικύρωσης και εξαιρέσεις εξαρτήσεων, που εκτοξεύονται από τις κατώτερες υπηρεσίες εξαρτημένων, αντιστοιχούν σε μία ενοποιημένη εξαρτημένη εξαίρεση στο επίπεδο της ενορχήστρωσης. Αυτή η πρακτική επιτρέπει στους ανωτέρους καταναλωτές της ίδιας υπηρεσίας ενορχήστρωσης να καθορίσουν την επόμενη πορεία βάσει ενός κατηγορικού τύπου εξαίρεσης αντί για τέσσερις ή στην περίπτωση τριών εξαρτήσεων θα ήταν έξι κατηγορικές εξαρτήσεις.

Ας ξεκινήσουμε με ένα αποτυχημένο τεστ για να υλοποιήσουμε την ιδέα μας εδώ:

```csharp
public static TheoryData DependencyValidationExceptions()
{
    string exceptionMessage = GetRandomMessage();
    var innerException = new Xeption(exceptionMessage);

    var studentValidationException =
        new StudentValidationException(
            message: "Student validation error occurred, fix errors and try again.",
            innerException);

    var studentDependencyValidationException =
        new StudentDependencyValidationException(
            message: "Student dependency validation error occurred, fix errors and try again.",
            innerException);

    var libraryCardValidationException =
        new LibraryCardValidationException(
            message: "Library card validation error occurred, fix errors and try again.",
            innerException);

    var libraryCardDependencyValidationException =
        new LibraryCardDependencyValidationException(
            message: "Library card dependency validation error occurred, fix errors and try again.",
            innerException);

    return new TheoryData<Xeption>
    {
        studentValidationException,
        studentDependencyValidationException,
        libraryCardValidationException,
        libraryCardDependencyValidationException
    };
}


[Theory]
[MemberData(nameof(DependencyValidationExceptions))]
public async Task ShouldThrowDependencyValidationExceptionOnCreateIfDependencyValidationErrorOccursAndLogItAsync(
    Xeption dependencyValidationException)
{
    // given
    Student someStudent = CreateRandomStudent();

    var expectedStudentOrchestrationDependencyValidationException =
        new StudentOrchestrationDependencyValidationException(
            message: "Student dependency validation error occurred, fix errors and try again",
            dependencyValidationException.InnerException as Xeption);

    this.studentServiceMock.Setup(service =>
        service.AddStudentAsync(It.IsAny<Student>()))
            .ThrowsAsync(dependencyValidationException);

    // when
    ValueTask<Student> addStudentTask =
        await this.studentOrchestrationService.AddStudentAsync(someStudent);

    StudentOrchestrationDependencyValidationException
        actualStudentOrchestrationDependencyValidationException =
                await Assert.ThrowsAsync<StudentOrchestrationDependencyValidationException>(
                    addStudentTask.AsTask);

    // then
    actualStudentOrchestrationDependencyValidationException.Should()
        .BeEquivalentTo(expectedStudentOrchestrationDependencyValidationException);

    this.studentServiceMock.Verify(service =>
        service.AddStudentAsync(It.IsAny<Student>()),
            Times.Once);

    this.loggingBrokerMock.Verify(broker =>
        broker.LogError(It.Is(SameExceptionAs(
            expectedStudentOrchestrationDependencyValidationException))),
                Times.Once);

    this.libraryCardServiceMock.Verify(service =>
        service.AddLibraryCard(It.IsAny<Guid>()),
            Times.Once);

    this.studentServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.libraryCardServiceMock.VerifyNoOtherCalls();
}
```

Παραπάνω, επιβεβαιώνουμε ότι οποιοδήποτε από τα τέσσερα τύπους εξαιρέσεων μας αντιστοιχίζεται σε μια `StudentOrchestrationDependencyValidationException`. Διατηρούμε την αρχική τοπική εξαίρεση ως εσωτερική εξαίρεση. Αλλά σε αυτό το επίπεδο ξετυλίγουμε την κατηγορική εξαίρεση για να διατηρήσουμε το αρχικό πρόβλημα καθώς πηγαίνουμε ανώτερα.

Αυτές οι εξαιρέσεις αντιστοιχίζονται υπό μια εξαίρεση εξάρτησης επικύρωσης επειδή προέρχονται από μια εξάρτηση ή μια εξάρτηση ενός downstream. Για παράδειγμα, αν μια υπηρεσία αποθήκευσης εκτοξεύσει μια εξαίρεση που είναι μια εξαίρεση επικύρωσης εξάρτησης (κάτι σαν `DuplicateKeyException`). Η γειτονική υπηρεσία του broker θα το αντιστοιχίσει σε μια τοπική `StudentAlreadyExistException` και στη συνέχεια θα εγκλωβιστεί αυτή η εξαίρεση σε μια κατηγορική εξαίρεση τύπου `StudentDependencyValidationException`. Όταν αυτή η εξαίρεση διαδίδεται ανώτερα στην επεξεργασία ή σε μια υπηρεσία ορχήστρωσης, χάνουμε την κατηγορική εξαίρεση καθώς την έχουμε ήδη καταγράψει στο σωστό επίπεδο της αντιστοίχισης. Στη συνέχεια, συνεχίζουμε να ενσωματώνουμε αυτήν την τοπική εξαίρεση κάτω από την τρέχουσα εξαίρεση εξάρτησης επικύρωσης.

Ας προσπαθήσουμε να περάσουμε αυτό το τεστ:

```csharp
public partial class StudentOrchestrationService
{
    private delegate ValueTask<Student> ReturningStudentFunction();

    private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
    {
        try
        {
            return await returningStudentFunction();
        }
        catch (StudentValidationException studentValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentValidationException);
        }
        catch (StudentDependencyValidationException studentDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentDependencyValidationException);
        }
        catch (LibraryCardValidationException libraryCardValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardValidationException);
        }
        catch (LibraryCardDependencyValidationException libraryCardDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardDependencyValidationException);
        }
    }

    private StudentOrchestrationDependencyValidationException CreateAndLogDependencyValidationException(Xeption exception)
    {
        var studentOrchestrationDependencyValidationException =
            new StudentOrchestrationDependencyValidationException(exception.innerException as Xeption);

        this.loggingBroker.LogError(studentOrchestrationDependencyValidationException);

        throw studentOrchestrationDependencyValidationException;
    }
}
```

Τώρα μπορούμε να χρησιμοποιήσουμε το TryCatch ως εξής:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () => 
{
    ...
    Student addedStudent = await this.studentService.AddStudentAsync(student);
    LibraryCard libraryCard = await this.libraryCard.AddLibraryCard(addedStudent.Id);

    return addedStudent;  
});
```

Μπορείτε να δείτε στην υλοποίηση ότι χαρτογραφήσαμε όλους τους τέσσερις διαφορετικούς τύπους εξωτερικών εξαιρέσεων επικύρωσης ροών κάτω από μία κατηγορική εξαίρεση και στη συνέχεια διατηρήσαμε την εσωτερική εξαίρεση για καθεμία από αυτές.

Η ίδια αρχή ισχύει και για τις εξαιρέσεις εξάρτησης. Οι εξαιρέσεις εξάρτησης μπορεί να προέρχονται τόσο από υπηρεσίες όσο και από εξαρτήσεις των υπηρεσιών ροών κάτω από. Για παράδειγμα, στο παραπάνω παράδειγμα, η κλήση μιας υπηρεσίας φοιτητή μπορεί να προκαλέσει τις εξαιρέσεις `StudentDependencyException` και `StudentServiceException`. Αυτές οι κατηγορικές εξαιρέσεις θα αποσυμπλεγματοποιηθούν από το επίπεδο της κατηγορικής εξαίρεσης και θα τυλιχθούν στο επίπεδο τοπικής εξαίρεσης σε μία νέα ενοποιημένη κατηγορική εξαίρεση σε επίπεδο οργάνωσης υπό το όνομα `StudentOrchestrationDependencyException`. Το ίδιο ισχύει και για όλες τις άλλες κατηγορικές εξαιρέσεις εξάρτησης, όπως η `LibraryCardDependencyException` και η `LibraryCardServiceException`.

Είναι κρίσιμο να αποσυμπλεκτούν και να τυλιχθούν οι τοπικές εξαιρέσεις από τις ροές υπηρεσιών κάτω από κατηγορικές εξαιρέσεις στο τρέχον επίπεδο της υπηρεσίας για να διασφαλιστεί η συνέπεια με το επίπεδο των εκθετών. Αυτές οι εξαιρέσεις μπορούν να χειριστούν και να αντιστοιχιστούν εύκολα σε ό,τι δικτυακό χαρακτήρα καθορίζει το εξαρτώμενο στοιχείο. Στην περίπτωση ενός εξαρτώμενου στοιχείου τύπου API Controller, η αντιστοίχιση θα παράγει κωδικούς κατάστασης HTTP. Στην περίπτωση στοιχείων εξάρτησης χρήστη, θα αντιστοιχιστεί σε κείμενο που είναι κατανοητό για τους τελικούς χρήστες.

Θα συζητήσουμε περαιτέρω προς τα πάνω σε αυτό το Πρότυπο πότε να αποκαλύψουμε τα λεπτομερή στοιχεία των εσωτερικών εξαιρέσεων όπου δεν απαιτείται από τους τελικούς χρήστες να λάβουν κάποια ενέργεια, το οποίο είναι αποκλειστικό για τις εξαιρέσεις εξάρτησης και υπηρεσίας.

## 2.3.4 Παραλλαγές
Οι υπηρεσίες ενορχήστρωσης διαφέρουν ανάλογα με το πού βρίσκονται στη συνολική χαμηλού επιπέδου αρχιτεκτονική. Για παράδειγμα, μια υπηρεσία ενορχήστρωσης που εξαρτάται από κατωτέρω υπηρεσίες ενορχήστρωσης ονομάζεται Υπηρεσία Συντονισμού. Μια υπηρεσία ενορχήστρωσης που εργάζεται με πολλαπλές υπηρεσίες συντονισμού ως εξαρτήσεις ονομάζεται Υπηρεσία Διαχείρισης. Αυτές οι παραλλαγές είναι μια υπηρεσία ενορχήστρωσης σε επιπέδο επιχειρηματικής λογικής υπεροχής.

 ### 2.3.4.0 Επίπεδα Παραλλαγών
Ας ρίξουμε μια ματιά στις δυνατές παραλλαγές για τις υπηρεσίες ορχηστρικής και πού θα βρίσκονταν:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147461598-e7fe6b48-976a-4787-bd97-11e7faf131ee.png" />
    </p>
 <br />

Στην προσωπική μου εμπειρία, σπάνια χρειάστηκε να καταφύγω σε μια υπηρεσία διαχείρισης της Uber. Η ιδέα του περιορισμού εδώ όσον αφορά τις εξαρτήσεις και τις παραλλαγές των υπηρεσιών ομοιογενοποίησης είναι να βοηθήσει τους μηχανικούς να αναθεωρήσουν την πολυπλοκότητα της λογικής τους. Ωστόσο, πρέπει να αναγνωρίσουμε ότι υπάρχουν καταστάσεις όπου η πολυπλοκότητα είναι απόλυτη αναγκαιότητα. Ως εκ τούτου, οι υπηρεσίες Uber-Management υπάρχουν ως μια επιλογή.

Ο παρακάτω πίνακας θα πρέπει να καθοδηγήσει τη διαδικασία ανάπτυξης παραλλαγών των υπηρεσιών ορχήστρωσης βάσει του επιπέδου:

| Variant								|   Dependencies            		| Consumers								    | Complexity |
|------------------------				|---------------------------		| ------------------------------------------| -----------|
| Orchestrations Services				| Foundation or Processing Services | Coordination Services     			    | Low    	 |
| Coordination Services				    | Orchestration Services 			| Management Services       			    | Medium     |
| Management Services					| Coordination Services          	| Uber Management Services			        | High       |
| Uber Management Services      		| Management Services               | Aggregation, Views or Exposer Components	| Very High	 |

Η λειτουργία πέρα ​​από τις υπηρεσίες διαχείρισης της Uber με τρόπο ορχήστρωσης θα απαιτούσε μια βαθύτερη συζήτηση και μια σοβαρή εξέταση της συνολικής αρχιτεκτονικής. Μελλοντικές εκδόσεις του Προτύπου μπορεί να ασχοληθούν με αυτό το ζήτημα σε αυτό που αποκαλώ "The Lake House," αλλά αυτό είναι εκτός του πεδίου εφαρμογής αυτής της έκδοσης του Προτύπου.

 ### 2.3.4.1 Unit of Work
 Με τις παραλλαγές των υπηρεσιών ενορχηστρωσης, συνιστώ ανεπιφύλακτα να παραμείνετε πιστοί στην έννοια της μονάδας εργασίας. Κάθε αίτημα μπορεί να εκτελεί μία και μόνο μία λειτουργία, συμπεριλαμβανομένων των προαπαιτούμενων ενεργειών. Για παράδειγμα, εάν πρέπει να εγγράψετε έναν μαθητή σε μια σχολή, μπορεί να χρειαστεί να προσθέσετε έναν κηδεμόνα, πληροφορίες επικοινωνίας και άλλες λεπτομέρειες. Η δημιουργία γεγονότων για αυτές τις ενέργειες μπορεί να μειώσει σημαντικά την πολυπλοκότητα της ροής και να μειώσει τον κίνδυνο αποτυχιών στις κατωτέρω υπηρεσίες.

Εδώ υπάρχει μια απεικόνιση για μια πολύπλοκη μονονηχαριστή προσέγγιση:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147462984-84e6dabd-bf27-413a-8e79-2659a24c37c0.png" />
    </p>
 <br />

Η παραπάνω λύση είναι μια λειτουργική λύση για την εγγραφή ενός φοιτητή. Χρειαζόμασταν να συμπεριλάβουμε πληροφορίες γονέων, κάρτες βιβλιοθήκης, μαθήματα, κλπ. Αυτές οι εξαρτήσεις μπορούν να διασπαστούν σε γεγονότα, επιτρέποντας σε άλλες υπηρεσίες να συνεχίσουν εκεί όπου οι υπηρεσίες με μονοκλωνική νήματα τελειώνουν για να συνεχίσουν τη διαδικασία εγγραφής. Κάτι τέτοιο:

  <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147463233-466a055f-ce95-4911-92cd-7b173b2a37df.png" />
    </p>
  <br />

Παραπάνω, το εισερχόμενο αίτημα μετατρέπεται σε γεγονότα, όπου κάθε από αυτά τα γεγονότα θα ειδοποιήσει τις υπηρεσίες τους ορχήστρωσης με μονόκλωνο μοτίβο, όπως συζητήθηκε στο τμήμα 2.3.2.2. Αυτό σημαίνει ότι ένα μοναδικό νήμα δεν είναι πλέον υπεύθυνο για την επιτυχία κάθε εξάρτησης στο σύστημα. Αντ' αυτού, κάθε διαμεσολαβητής που ακούει για γεγονότα θα χειρίζεται τη διαδικασία του σε ένα απλοποιημένο τρόπο.

Αυτή η προσέγγιση δεν εγγυάται μια άμεση απόκριση επιτυχίας ή αποτυχίας προς τον αιτούντα. Είναι ένα μοτίβο ενδεχόμενης συνέπειας όπου ο πελάτης θα λάβει ένα μήνυμα "Αποδεκτό" ή το αντίστοιχο με βάση το πρωτόκολλο επικοινωνίας για να τον ενημερώσει ότι μια διαδικασία έχει ξεκινήσει. Παραμένει, ωστόσο, ότι δεν υπάρχει εγγύηση για τα αποτελέσματα μέχρις ότου εκτελεστεί όλη η λογική των γεγονότων.

  Σημειώστε ότι μπορούμε να προσθέσουμε μια επιπλέον στρώση ανθεκτικότητας σε αυτά τα γεγονότα αποθηκεύοντάς τα προσωρινά σε συστατικά παρόμοια με ουρές ή προσωρινές αποθηκεύσεις με βάση τη μείζον σημασία της επιχείρησης.

Ωστόσο, μια προσέγγιση ενδεχόμενης συνέπειας δεν είναι πάντα μια καλή λύση εάν ο πελάτης στην άλλη πλευρά αναμένει μια απόκριση, ειδικά σε κρίσιμες καταστάσεις όπου απαιτείται άμεση απόκριση. Μία λύση σε αυτό το πρόβλημα είναι οι ουρές Fire-n-Observe, τις οποίες θα συζητήσουμε στη μελλοντική έκδοση του πρότυπου "The Standard".
  
[*] [Introduction to Orchestration Services](https://www.youtube.com/watch?v=OP6HcIpXduE)

[*] [Cul-De-Sac Pattern for Orchestration Services](https://www.youtube.com/watch?v=C8Sm1kSKF1o)

[*] [Cul-De-Sac Pattern for Coordination Services](https://www.youtube.com/watch?v=8KZIw_IJC0U)
