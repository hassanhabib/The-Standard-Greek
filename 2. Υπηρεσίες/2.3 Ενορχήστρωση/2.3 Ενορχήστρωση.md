# 2.3 Υπηρεσίες Ορχήστρωσης (Πολύπλοκη Λογική Υψηλού Επιπέδου) (Orchestration Services (Complex Higher Order Logic))

## 2.3.0 Εισαγωγή

Οι υπηρεσίες ορχήστρωσης είναι οι συνδυαστές μεταξύ πολλών βασικών ή επεξεργαστικών υπηρεσιών για την εκτέλεση μιας πολύπλοκης λογικής λειτουργίας. Οι βασικές τους ευθύνες είναι πολυ-οντότητας λογικές λειτουργίες και η ανάθεση των εξαρτήσεων αυτών των λειτουργιών σε κατώτερες επεξεργαστικές ή βασικές υπηρεσίες.

Ο πρωταρχικός ρόλος των υπηρεσιών ορχήστρωσης είναι η ενθυλάκωση λειτουργιών που απαιτούν δύο ή τρεις επιχειρηματικές οντότητες.

```csharp
public async ValueTask<LibraryCard> CreateStudentLibraryCardAsync(LibraryCard libraryCard) =>
TryCatch(async () =>
{
    ValidateLibraryCard(libraryCard);

    await this.studentProcessingService
        .VerifyEnrolledStudentExistsAsync(libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
});

```
Στο παραπάνω παράδειγμα, η υπηρεσία `LibraryCardOrchestrationService` καλεί τόσο την `StudentProcessingService` όσο και την `LibraryCardProcessingService` για να εκτελέσει μια πολύπλοκη λειτουργία. Καταρχάς, επαληθεύει την ύπαρξη του φοιτητή για τον οποίο δημιουργούμε μια κάρτα βιβλιοθήκης, και επαληθεύει την εγγραφή του φοιτητή· και δεύτερον, δημιουργεί την κάρτα βιβλιοθήκης.

Η λειτουργία δημιουργίας μιας κάρτας βιβλιοθήκης για έναν δεδομένο φοιτητή δεν μπορεί να εκτελεστεί απλά καλώντας την υπηρεσία κάρτας βιβλιοθήκης· διότι η υπηρεσία κάρτας βιβλιοθήκης (επεξεργασίας ή βάσης) δεν έχει πρόσβαση σε όλες τις λεπτομέρειες για τον φοιτητή. Επομένως, απαιτείται μια λογική συνδυασμού για να διασφαλιστεί ότι υπάρχει ένας κατάλληλος ροή.

Είναι σημαντικό να κατανοήσουμε ότι οι υπηρεσίες ορχήστρωσης απαιτούνται μόνο όταν χρειαζόμαστε να συνδυάσουμε λειτουργίες πολλών οντοτήτων, οι οποίες μπορεί να είναι αρχικές ή υψηλότερης τάξης. Σε ορισμένες αρχιτεκτονικές, οι υπηρεσίες ορχήστρωσης μπορεί ακόμη και να μην υπάρχουν. Αυτό συμβαίνει απλά επειδή κάποιες μικρουπηρεσίες ενδέχεται να είναι υπεύθυνες μόνο για την εφαρμογή λογικής επαλήθευσης και την αποθήκευση και ανάκτηση δεδομένων από την αποθήκη, τίποτε περισσότερο ή λιγότερο.

## 2.3.1 Στον Χάρτη

Οι υπηρεσίες ορχήστρωσης είναι ένα από τα βασικά στοιχεία της επιχειρηματικής λογικής σε οποιοδήποτε σύστημα, τοποθετημένο ανάμεσα σε υπηρεσίες μονάδας οντότητας (όπως επεξεργασία ή βάση) και υπηρεσίες προηγμένης λογικής όπως οι υπηρεσίες συντονισμού, οι υπηρεσίες συνάθροισης ή απλώς εκθέτες όπως ελεγκτές, στοιχεία web ή οτιδήποτε άλλο. Παρακάτω παρέχουμε μια επισκόπηση υψηλού επιπέδου για το πού μπορεί να βρίσκονται οι υπηρεσίες ορχήστρωσης:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118414675-e4fc8b80-b65a-11eb-91c8-94f67c6e68ed.png" />
    </p>
<br />

Όπως φαίνεται παραπάνω, οι υπηρεσίες ενορχήστρωσης έχουν αρκετές εξαρτήσεις και καταναλωτές. Είναι η πυρήνας της λογικής οποιουδήποτε λογισμικού. Στη δεξιά πλευρά, μπορείτε να δείτε τις εξαρτήσεις μιας υπηρεσίας ορχήστρωσης. Δεδομένου ότι μια υπηρεσία επεξεργασίας είναι προαιρετική ανάλογα με το αν απαιτείται μια λογική υψηλότερης τάξης ή όχι - οι υπηρεσίες ορχήστρωσης μπορούν επίσης να συνδυάσουν πολλές υπηρεσίες θεμελίωσης.

Η ύπαρξη μιας υπηρεσίας ενορχήστρωσης απαιτεί την ύπαρξη μιας υπηρεσίας επεξεργασίας. Αλλά αυτό δεν ισχύει πάντα. Υπάρχουν καταστάσεις όπου όλες οι υπηρεσίες ενορχήστρωσης χρειάζεται να ολοκληρώσουν ένα επιχειρηματικό ρεύμα για να αλληλεπιδράσουν με λειτουργικότητα επιπέδου πρωτεύοντος.

Ωστόσο, μια υπηρεσία ενορχήστρωσης μπορεί να έχει πολλούς καταναλωτές, όπως οι υπηρεσίες συντονισμού (ορχηστρωτές των ορχηστρωτών), υπηρεσίες συνάθροισης ή απλώς ένας εκθέτης. Οι εκθέτες είναι σαν ελεγκτές, υπηρεσίες προβολής, στοιχεία διεπαφής χρήστη (UI) ή μια άλλη υπηρεσία θεμελίωσης ή επεξεργασίας στην περίπτωση που τοποθετούνται μηνύματα πίσω σε μια ουρά - το οποίο θα συζητήσουμε περαιτέρω στο πρότυπο μας.

## 2.3.2 Χαρακτηριστικά

Γενικά, οι υπηρεσίες ορχήστρωσης ασχολούνται με τον συνδυασμό λειτουργιών μονάδας οντότητας πρωτεύοντος επιπέδου ή υψηλότερης τάξης για την εκτέλεση ενός επιτυχημένου ροής. Μπορείτε όμως επίσης να τα θεωρήσετε ως τη "κόλλα" που ενώνει πολλές λειτουργίες μονάδας οντότητας μαζί.

### 2.3.2.0 Γλώσσα

Όπως και οι υπηρεσίες επεξεργασίας, η γλώσσα που χρησιμοποιείται στις υπηρεσίες ορχήστρωσης καθορίζει το επίπεδο πολυπλοκότητας και τις δυνατότητες που προσφέρει.
Συνήθως, οι υπηρεσίες ορχήστρωσης συνδυάζουν δύο ή περισσότερες πρωτεύοντες ή υψηλότερης τάξης λειτουργίες από πολλές υπηρεσίες μονάδας οντότητας για την εκτέλεση μιας επιτυχημένης λειτουργίας.

#### 2.3.2.0.0 Γλώσσα Λειτουργιών

Οι υπηρεσίες ορχήστρωσης έχουν μια κοινή χαρακτηριστική σχετικά με τη γλώσσα των λειτουργιών τους. Οι υπηρεσίες ορχήστρωσης είναι ολιστικές στην πλειοψηφία της γλώσσας των λειτουργιών τους. Θα δείτε λειτουργίες όπως `NotifyAllAdmins`, όπου η υπηρεσία ανακτάει όλους τους χρήστες με τύπο διαχειριστή και στη συνέχεια καλεί μια υπηρεσία ειδοποιήσεων για να τους ειδοποιήσει.

Οι υπηρεσίες ορχήστρωσης προσφέρουν λειτουργικότητα που πλησιάζει όλο και περισσότερο την επιχειρηματική γλώσσα από τις πρωτεύουσες τεχνικές λειτουργίες. Μπορεί να δείτε μια σχεδόν ίδια έκφραση σε μια μη τεχνική επιχειρηματική απαίτηση που ταιριάζει με το όνομα μιας λειτουργίας σε μια υπηρεσία ορχήστρωσης. Το ίδιο πρότυπο συνεχίζεται καθώς κάποιος προχωρά σε υψηλότερες και πιο προηγμένες κατηγορίες υπηρεσιών μέσα σε αυτό το πεδίο της επιχειρηματικής λογικής.

#### 2.3.2.0.1 Διέλευση (Pass-Through)

Οι υπηρεσίες ορχήστρωσης μπορούν επίσης να λειτουργήσουν ως διέλευση για ορισμένες λειτουργίες. Για παράδειγμα, μια υπηρεσία ορχήστρωσης θα μπορούσε να επιτρέψει το `AddStudentAsync` να μεταδοθεί μέσω της υπηρεσίας για να ενοποιηθεί η πηγή των αλληλεπιδράσεων με το σύστημα στο επίπεδο των εκθετών. Σε αυτήν την περίπτωση, οι υπηρεσίες ορχήστρωσης θα χρησιμοποιήσουν την ίδια ορολογία που μια επεξεργαστική ή θεμελιώδης υπηρεσία μπορεί να χρησιμοποιήσει για τη μεταβίβαση της λειτουργίας.

#### 2.3.2.0.2 Class-Level Language

Οι υπηρεσίες ενορχήστροσης συνδυάζουν κυρίως πολλαπλές λειτουργίες που υποστηρίζουν ένα συγκεκριμένο στοιχείο. Έτσι, εάν το κύριο στοιχείο είναι ο `Student` και τα υπόλοιπα στοιχεία υπάρχουν μόνο για να υποστηρίξουν μια λειτουργία που στοχεύει κυρίως σε ένα στοιχείο `Student` - τότε το όνομα της υπηρεσίας ενορχήστρωσης θα ήταν `StudentOrchestrationService`.

Η επιβολή των συμβάσεων ονοματολογίας διασφαλίζει ότι κάθε υπηρεσία ενορχήστρωσης παραμένει εστιασμένη στην ευθύνη ενός μόνο στοιχείου σχετικά με πολλά άλλα υποστηρικτικά στοιχεία.

Για παράδειγμα, η δημιουργία ενός κάρτας βιβλιοθήκης απαιτεί τη σχολική εγγραφή του φοιτητή που αναφέρεται σε εκείνη την κάρτα βιβλιοθήκης. Σε αυτήν την περίπτωση, το όνομα της υπηρεσίας ενορχήστρωσης θα αντικατοπτρίζει το κύριο στοιχείο της, `LibraryCard`. Το όνομα της υπηρεσίας ενορχήστρωσης θα ήταν, λοιπόν, `StudentOrchestrationService`.

Το αντίθετο ισχύει επίσης. Εάν η εγγραφή ενός φοιτητή σε μια σχολή έχει συνδεδεμένες λειτουργίες όπως η δημιουργία ενός κάρτας βιβλιοθήκης, τότε, σε αυτήν την περίπτωση, πρέπει να υπάρχει μια `StudentOrchestrationService` για να δημιουργηθεί ένας `Student` και όλα τα σχετικά στοιχεία.

Η ίδια ιδέα ισχύει για όλες τις εξαιρέσεις που δημιουργούνται σε μια υπηρεσία ενορχήστρωσης, όπως `StudentOrchestrationValidationException` και `StudentOrchestrationDependencyException`.

### 2.3.2.1 Εξαρτήσεις

Όπως αναφέραμε παραπάνω, οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν ένα ευρύτερο φάσμα εξαρτήσεων σε σύγκριση με τις υπηρεσίες επεξεργασίας και θεμελίωσης, λόγω της προαιρετικότητας των υπηρεσιών επεξεργασίας. Επομένως, οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν εξαρτήσεις που κυμαίνονται από υπηρεσίες θεμελίωσης ή προαιρετικές υπηρεσίες επεξεργασίας μέχρι διασταυρούμενες υπηρεσίες όπως καταγραφή καταγραφής ή άλλοι διαμεσολαβητές χρησιμότητας.

#### 2.3.2.1.0 Ισορροπία Εξαρτήσεων (Πρότυπο Florance)

Ένα θεμελιώδες κανόνα που διέπει τη συνέπεια και την ισορροπία των υπηρεσιών ενορχήστρωσης είναι το 'Πρότυπο Florance', το οποίο καθορίζει ότι κάθε υπηρεσία ενορχήστρωσης δεν μπορεί να συνδυάζει εξαρτήσεις από διαφορετικές κατηγορίες λειτουργίας.

Αυτό σημαίνει ότι μια υπηρεσία ενορχήστρωσης δεν μπορεί να συνδυάσει υπηρεσίες θεμελίωσης και επεξεργασίας. Οι εξαρτήσεις πρέπει να είναι είτε όλες επεξεργασίας είτε όλες θεμελίωσης. Αυτός ο κανόνας δεν ισχύει για τις εξαρτήσεις διαμεσολαβητών χρησιμότητας, ωστόσο.

Εδώ υπάρχει ένα παράδειγμα μιας μη ισορροπημένης εξάρτησης υπηρεσιών ενορχήστρωσης:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415856-9e5e5f80-b661-11eb-96db-a541f89ccee7.png" />
    </p>
<br />

Απαιτείται μια επιπλέον υπηρεσία επεξεργασίας για να παρέχει ένα πέρασμα προς μια χαμηλότερου επιπέδου υπηρεσία θεμελίωσης για να ισορροπήσει την αρχιτεκτονική - εφαρμόζοντας το 'Πρότυπο Florance' για συμμετρία θα μετασχηματίσει την αρχιτεκτονική μας στην ακόλουθη μορφή:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415965-33f9ef00-b662-11eb-8538-59e5c728d308.png" />
    </p>
<br />

Η εφαρμογή του 'Προτύπου Florance' μπορεί να είναι πολύ δαπανηρή αρχικά, καθώς περιλαμβάνει τη δημιουργία μιας εντελώς νέας υπηρεσίας επεξεργασίας (ή πολλαπλών) για να ισορροπήσει την αρχιτεκτονική. Ωστόσο, τα οφέλη του υπερβαίνουν το κόστος από την άποψη της συντηρησιμότητας, της αναγνωσιμότητας και της ευκολίας αντικατάστασης.

#### 2.3.2.1.1 Two-Three

Ο "Κανόνας Δύο-Τρία" είναι ένας κανόνας ελέγχου της πολυπλοκότητας. Αυτός ο κανόνας καθορίζει ότι μια υπηρεσία ενορχήστρωσης δεν πρέπει να έχει περισσότερες από τρεις ή λιγότερες από δύο υπηρεσίες επεξεργασίας ή θεμελίωσης για την εκτέλεση της ενορχήστρωσης. Αυτός ο κανόνας, ωστόσο, δεν ισχύει για τους διαμεσολαβητές χρησιμότητας. Οι υπηρεσίες ενορχήστρωσης μπορεί να έχουν έναν `DateTimeBroker` ή έναν `LoggingBroker` χωρίς καμία περιορισμένη.

Αλλά μια υπηρεσία ενορχήστρωσης δεν πρέπει να έχει έναν διαμεσολαβητή οντότητας, όπως έναν `StorageBroker` ή έναν `QueueBroker`, που τροφοδοτεί απευθείας τον πυρήνα του επιχειρηματικού επιπέδου οποιασδήποτε υπηρεσίας.

Αυτός ο κανόνας, όπως και τα περισσότερα από τα μοτίβα και τα έννοια στο Πρότυπο, εμπνέεται από τη φύση. Μπορείτε να δείτε πώς τα δένδρα διχοτομούνται σε δύο και τρία - το ίδιο συμβαίνει για τους κεραυνούς, τα αιμοφόρα αγγεία και τόσες άλλες δημιουργίες γύρω μας, μέσα μας και πάνω από εμάς ακολουθούν το ίδιο πρότυπο.

<br />
    <p align="center" >
        <img width="50%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard/master/2.%20Services/2.3%20Orchestrations/Resources/2.3.2.1.1%20Two-Three.png" />
    </p>
<br />

Ένα δέντρο κλαδεύει καθώς αναπτύσσεται προς τα πάνω, αλλά και στις ίδιες του τις ρίζες. Και αυτό ισχύει και για τις υπηρεσίες ενορχήστρωσης και ενορχήστρωσης-παρόμοιες. Μπορούν να κλαδευτούν περαιτέρω προς τα πάνω, όπως θα εξηγήσω εδώ σύντομα, αλλά επίσης και προς τα κάτω μέσω προτύπων όπως το πρότυπο Cul-De-Sac.

Ο "Κανόνας Δύο-Τρία" μπορεί να απαιτήσει ένα επίπεδο κανονικοποίησης προς την κατηγορική επιχειρηματική λειτουργία. Ας μιλήσουμε για τους διάφορους μηχανισμούς κανονικοποίησης των υπηρεσιών ενορχήστρωσης.

##### 2.3.2.1.1.0 Πλήρης Κανονικοποίηση

Συχνά υπάρχουν περιπτώσεις όπου η τρέχουσα αρχιτεκτονική οποιασδήποτε δεδομένης υπηρεσίας ενορχήστρωσης καταλήγει με μια υπηρεσία ενορχήστρωσης με τρεις εξαρτήσεις. Και απαιτείται μια νέα υπηρεσία επεξεργασίας ή θεμελίωσης οντότητας για να ολοκληρωθεί μια υπάρχουσα διαδικασία.

Για παράδειγμα, ας υποθέσουμε ότι έχουμε μια `StudentContactOrchestrationService` και αυτή η υπηρεσία έχει εξαρτήσεις που παρέχουν λειτουργικότητα σε επίπεδο αρχής για την`Address`, `Email` και το `Phone` για κάθε φοιτητή. Εδώ υπάρχει μια οπτικοποίηση αυτής της κατάστασης:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101834-f636a500-c0fc-11eb-968b-10ed9a60bac8.png" />
    </p>
<br />


Τώρα, προστίθεται μια νέα απαίτηση, το 'ΚοινωνικόΜέσο', στο 'Φοιτητή', για να συγκεντρωθούν περισσότερες πληροφορίες επικοινωνίας σχετικά με τον τρόπο επικοινωνίας με έναν φοιτητή. Μπορούμε να μπούμε σε κατάσταση πλήρους κανονικοποίησης απλώς βρίσκοντας ένα κοινό σημείο που χωρίζει ισότιμα τις οντότητες πληροφοριών επικοινωνίας. Για παράδειγμα, μπορούμε να χωρίσουμε τις κανονικές πληροφορίες επικοινωνίας έναντι των ψηφιακών πληροφοριών επικοινωνίας, όπως στην `Address` και το `Phone` έναντι του `Email` και του `SocialMedia`. Με αυτόν τον τρόπο, χωρίζουμε τις τέσσερις εξαρτήσεις σε δύο, για κάθε υπηρεσία ενορχήστρωσης, ως εξής:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101983-c6d46800-c0fd-11eb-836a-496d191ef922.png" />
    </p>
<br />


Στο σχήμα παραπάνω, τροποποιήσαμε την υπάρχουσα `StudentContactOrchestrationService` σε `StudentRegularContactOrchestrationService` και αφαιρέσαμε μία από τις εξαρτήσεις της από την `EmailService`.

Επιπροσθέτως, δημιουργήσαμε μια νέα `StudentDigitalContactOrchestrationService` για να έχει δύο εξαρτήσεις από την υπάρχουσα `EmailService` και τη νέα `SocialMediaService`. Ως αποτέλεσμα, χρειαζόμαστε τώρα έναν προηγμένο λογικό επιχειρηματικό επίπεδο, όπως μια υπηρεσία συντονισμού, για να παρέχει πληροφορίες επικοινωνίας φοιτητών σε ροές δεδομένων προς τα άνω.

##### 2.3.2.1.1.1 Η Ημι-Κανονικοποίηση

Η κανονικοποίηση δεν είναι πάντα τόσο απλή όπως το παράδειγμα παραπάνω, ειδικά όταν μια πυρήνας οντότητας πρέπει να υπάρχει πριν δημιουργηθούν ή συμπληρωθούν πρόσθετες πληροφορίες για σχετικές οντότητες.

Για παράδειγμα, ας υποθέσουμε ότι έχουμε μια `StudentRegistrationOrchestrationService` που εξαρτάται από τις `StudentProcessingService`, `LibraryCardProcessingService`  και `BookProcessingService` ως εξής:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120099527-c41f4600-c0f0-11eb-8702-1439f966d9dc.png" />
    </p>
<br />

Αλλά τώρα, χρειαζόμαστε μια νέα υπηρεσία για τη διαχείριση των immunization των φοιτητών, ως `ImmunizationProcessingService`. Χρειαζόμαστε όλες τις τέσσερις υπηρεσίες, αλλά ήδη έχουμε μια `StudentRegistrationOrchestrationService` που έχει τρεις εξαρτήσεις. Σε αυτό το σημείο, απαιτείται μια ημι-κανονικοποίηση για την επαναζυμώση της αρχιτεκτονικής για να τηρηθεί ο "Κανόνας Δύο-Τρία" και, τελικά, να ελεγχθεί η πολυπλοκότητα.

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100296-ea46e500-c0f4-11eb-888a-ed6668e9ffdb.png" />
    </p>
<br />


Σε αυτήν την περίπτωση, απαιτείται περαιτέρω κανονικοποίηση ή διαίρεση για να επαναζυμώσει την αρχιτεκτονική. Πρέπει να σκεφτούμε έννοιες για το κοινό έδαφος μεταξύ των αρχέτυπων οντοτήτων σε μια διαδικασία εγγραφής φοιτητή. Οι απαιτήσεις του φοιτητή περιλαμβάνουν ταυτότητα, υγεία και υλικά. Σε αυτό το σενάριο, μπορούμε να συνδυάσουμε το `LibraryCard` και το `Book` υπό την ίδια υπηρεσία ενορχήστρωσης, αφού τα βιβλία και οι βιβλιοθήκες σχετίζονται κάπως. Έτσι, θα είχαμε την `StudentLibraryOrchestrationService`, και για την άλλη υπηρεσία θα είχαμε την `StudentHealthOrchestrationService` ως εξής:

Σε αυτήν την περίπτωση, απαιτείται περαιτέρω κανονικοποίηση ή διαίρεση για την επαναζυμώσει της αρχιτεκτονικής. Πρέπει να σκεφτούμε έννοιες για το κοινό έδαφος μεταξύ των αρχέτυπων οντοτήτων σε μια διαδικασία εγγραφής φοιτητή. Οι απαιτήσεις του φοιτητή περιλαμβάνουν ταυτότητα, υγεία και υλικά. Σε αυτό το σενάριο, μπορούμε να συνδυάσουμε το `LibraryCard` και το `Book` υπό την ίδια υπηρεσία ενορχήστρωσης, καθώς τα βιβλία και οι βιβλιοθήκες σχετίζονται κάπως. Έτσι, θα είχαμε την `StudentLibraryOrchestrationService`, και για την άλλη υπηρεσία θα είχαμε την `StudentHealthOrchestrationService` όπως παρακάτω:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100597-68f05200-c0f6-11eb-9ccc-ae1c963f6de5.png" />
    </p>
 <br />

Για να ολοκληρωθεί η διαδικασία εγγραφής με ένα νέο μοντέλο, μια υπηρεσία συντονισμού πρέπει να περάσει προηγμένη επιχειρησιακή λογική για να συνδυάσει αυτές τις οντότητες. Ωστόσο, θα παρατηρήσετε ότι κάθε υπηρεσία ενορχήστρωσης έχει μια περιττή εξάρτηση από την `StudentProcessingService` για να διασφαλίσει ότι δεν υπάρχει εικονική εξάρτηση από οποιαδήποτε άλλη υπηρεσία ενορχήστρωσης, δημιουργώντας / εξασφαλίζοντας την ύπαρξη ενός εγγραφής φοιτητή.

Οι εικονικές εξαρτήσεις είναι πολύ δύσκολες. Είναι μια κρυφή σύνδεση μεταξύ δύο υπηρεσιών οποιασδήποτε κατηγορίας, όπου μια υπηρεσία υποθέτει αυτομάτως ότι μια συγκεκριμένη οντότητα θα δημιουργηθεί και θα είναι παρούσα. Οι εικονικές εξαρτήσεις είναι πολύ επικίνδυνες και απειλούν την κατάλληλη αυτονομία οποιασδήποτε υπηρεσίας. Η ανίχνευση εικονικών εξαρτήσεων στα πρώιμα στάδια του σχεδιασμού και της ανάπτυξης μπορεί να είναι μια δύσκολη αλλά απαραίτητη διαδικασία για να εξασφαλίσει ότι υπάρχει μια καθαρή, Κανονισμένη αρχιτεκτονική.

Όπως οι αλλαγές στο μοντέλο απαιτούν μεταναστεύσεις δομής βάσης δεδομένων και επιπλέον λογική και επικυρώσεις, η νέα απαίτηση για μια νέα οντότητα μπορεί να απαιτήσει την αναδιάρθρωση μιας υπάρχουσας αρχιτεκτονικής ή την επέκτασή της σε μια νέα έκδοση, ανάλογα με το ποιο στάδιο λαμβάνει το σύστημα αυτές τις νέες απαιτήσεις.

Μπορεί να είναι πολύ ελκυστικό να προσθέσετε μια ακόμα εξάρτηση σε μια υπάρχουσα υπηρεσία ορχηστροποίησης, αλλά αυτό είναι το σημείο όπου το σύστημα αρχίζει να αποκλίνει από το "Το Πρότυπο". Και αυτό είναι όταν το σύστημα αρχίζει να γίνεται ένα αδύναμο σύστημα που δυσκολεύεται να συντηρηθεί. Αλλά, πιο σημαντικά, αυτό το σενάριο δοκιμάζει τις αρχές σχεδίασης και τα πρότυπα της τεχνογνωσίας των μηχανικών που συμμετέχουν στον σχεδιασμό και την ανάπτυξη του συστήματος.

##### 2.3.2.1.1.2 No-Normalization

I believe that everything, everywhere, somehow is connected. Yet, there are scenarios where higher levels of normalization are challenging to achieve. Sometimes it might be incomprehensible for the mind to group multiple services under one orchestration service.

Because it's pretty hard for my mind to come up with an example for multiple entities that have no connection to each other, as I genuinely believe it couldn't exist. I'm going to rely on some fictional entities to visualize a problem. So let's assume there are `AService` and `BService` orchestrated together with an `XService`. The existence of `XService` is important to ensure that both `A` and `B` can be created with an assurance that a core entity `X` does exist.

Now, let's say a new service `CService` is required to be added to the mix to complete the existing flow. So, now we have four different dependencies under one orchestration service, and a split is mandatory. Since there's no relationship whatsoever between `A`, `B`, and `C`, a 'No-Normalization' approach becomes the only option to realize a new design as follows:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120102975-4d8b4400-c102-11eb-9582-6f95d17227e7.png" />
    </p>
 <br />

Each of the above primitive services will be orchestrated with a core service `X` and then gathered under a coordination service. This case above is the worst-case scenario, where normalization of any size is impossible. Note that the author of this Standard couldn't come up with a realistic example unlike any others to show you how rare it is to run into that situation, so let a 'No-Normalization' approach be your very last solution if you run out of options.

##### 2.3.2.1.1.3 Meaningful Breakdown
Regardless of the type of normalization you follow, you must ensure that your grouped services represent a common meaning. For instance, putting together a `StudentProcessingService` and `LibraryProcessingService` must require a functional commonality. A good example of that would be `StudentRegistrationOrchestrationService`, for instance. The registration process requires adding a new student record and creating a library card for that very same student.

Implementing orchestration services without intersection between two or three entities per operation defeats the whole purpose of having an orchestration service. This condition is satisfied if at least one intersection between two entities has occurred. An orchestration service may have other 'Pass-Through' operations where we propagate certain routines from their processing or foundation origins if they match the same contract.

Here's an example:

```csharp
public class StudentOrchestrationService
{
    public async ValueTask<Student> RegisterStudentAsync(Student student)
    {
        Student addedStudent =
            await this.studentProcessingService.AddStudentAsync(student);
    
        LibraryCard libraryCard = 
            await this.libraryCardPorcessingService.AddLibraryCardAsync(
                addedStudent.Id);

        return addedStudent;
    }


    public async ValueTask<Student> ModifyStudentAsync(Student student) =>
        await this.studentProcessingService.ModifyStudentAsync(student);
}
```

In the example above, our `StudentOrchestrationService` had an orchestration routine that combined adding a student and creating a library card for that student. But additionally, it also offers a 'Pass-Through' function for a low-level processing service routine to modify a student.

'Pass-Through' routines must have the same contract as the other routines in any orchestration service. Our 'Pure Contract' principle dictates that any service should allow the same contract as input and output or primitive types.

### 2.3.2.2 Contracts
Orchestration services may combine two or three different entities and their operations to achieve an higher business logic. There are two scenarios for contract/models for orchestration services: One that stays true to the primary entity's purpose; and one that is complex - a combinator orchestration service that tries to expose its inner target entities explicitly.

Let's talk about these two scenarios in detail.

#### 2.3.2.2.0 Physical Contracts
Some orchestration services are still single-purposed even though they may combine two or three other higher-order routines from multiple entities. For instance, an orchestration service that reacts to messages from some queue then persists these messages are single-purposed and single-entity orchestration services.

Let's take a look at this code snippet:

```csharp

public class StudentOrchestrationService
{
    private readonly IStudentEventProcessingService studentEventProcessingService;
    private readonly IStudentProcessingService studentProcessingService;

    public StudentOrchestrationService(
        IStudentEventProcessingService studentEventProcessingService,
        IStudentProcessingService studentProcessingService)
    {
        this.studentEventProcessingService = studentEventProcessingService;
        this.studentProcessingService = studentProcessingService;
        ListenToEvents();
    }

    public void ListenToEvents() =>
        this.studentEventService.ListenToEvent(UpsertStudentAsync);

    public async ValueTask<Student> UpsertStudentAsync(Student student)
    {
        ...
        await this.studentProcessingService.UpsertStudentAsync(student);

        ...
    }
}
```

In the above example, the orchestration service still exposes functionality that honors the physical model `Student` and internally communicates with several services that may provide completely different models. These are the scenarios where a single entity has a primary purpose, and all other services are supporting services to ensure a successful flow for that entity.

In our example, the orchestration services _listen_ to a queue for new student messages, then use that event to persist any incoming new students in the system. So the physical contract `Student` is the same language the orchestration service explicitly uses as a model to communicate with upper stream services/exposers or others.

But there are other scenarios where a single entity is not the only purpose/target for an orchestration service. Let's talk about that in detail.

#### 2.3.2.2.1 Virtual Contracts
In some scenarios, an orchestration service may be required to create non-physical contracts to complete a particular operation. For instance, consider an orchestration service required to persist a social media post containing a picture. The requirement here is to persist the picture in one database and the actual post (comments, authors, and others) into a different database table in a relational model.

The incoming model might be significantly different from the actual physical models. Let's see what that would look like in the real world.

Consider having this model:

```csharp
public class MediaPost
{
    public Guid Id {get; set;}
    public string Content {get; set;}
    public DateTimeOffset Date {get; set;}
    public IEnumerable<string> Base64Images {get; set;}
}
```

The above contract `MediaPost` contains two different physical entities combined. The first is the actual post, including the `Id`, `Content`, and `Date`, and the second is the list of images attached to that very post.

Here's how an orchestration service would react to this incoming virtual model:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

public Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

public List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}
```

The above code snippet shows the orchestration service deconstructing a given virtual model/contract `MediaPost` into two physical models. Each one has its separate processing service that handles its persistence. There are scenarios where the virtual model gets deconstructed into one single model with additional details used for validation and verification with downstream processing or foundation services.

There are also hybrid situations where the incoming virtual model may have nested physical models, which is something we can only allow with virtual models. Physical models shall stay anemic (contains no routines or constructors) and flat (contains no nested models) at all times to control complexity and focus responsibility.

In summary, Orchestration services may create their own contracts. These contracts may be physical or virtual. And a virtual contract may be a combination of one or many physical (or nested virtual) contracts or simply has it's own flat design in terms of properties.

### 2.3.2.2 Cul-De-Sac
Sometimes, Orchestration services and their equivalent (coordination, management, etc.) may not need an exposer component (controller, for instance). That's because these services may be listeners to specific events and communicate the event back into a Processing or a Foundation service at the same level where the event started or was received.

For example, incoming messages can be received from a subscription to an event service or a queue. In this case, the input for these services isn't necessarily through an exposer component anymore. Imagine building a simple application where it gets notified with messages from a queue and then maps these messages into some local model to persist it in storage. In this case, the orchestration service would look something like the following:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/144501231-11ea13c9-81fa-4730-8840-a891a1d9edde.png" />
    </p>
 <br />

 The `StudentEventOrchestrationService` listens to messages for new students coming in and immediately converts that into models that can be persisted in the database.

 Here's an example:

 Let's start with a unit test for this pattern as follows:
 ```csharp
[Fact]
public void ShouldListenToProfileEvents()
{
    // given . when
    this.profileEventOrchestrationService.ListenToProfileEvents();

    // then
    this.profileEventServiceMock.Verify(service =>
        service.ListenToProfileEvent(
            this.profileEventOrchestrationService.ProcessProfileEventAsync),
                Times.Once);

    this.profileEventService.VerifyNoOtherCalls();
    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

[Fact]
public async Task ShouldAddProfileAsync()
{
    // given
    ProfileEvent randomProfileEvent =
        CreateRandomProfileEvent();

    ProfileEvent inputProfileEvent =
        randomProfileEvent;

    this.profileServiceMock.Setup(service =>
        service.AddProfileAsync(inputProfileEvent.Profile));

    // when
    await this.profileEventOrchestrationService
        .ProcessProfileEventAsync(inputProfileEvent);

    // then
    this.profileServiceMock.Verify(service =>
        service.AddProfileAsync(inputProfileEvent.Profile),
            Times.Once);

    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.profileEventServiceMock.VerifyNoOtherCalls();
}
 ```

 The test here indicates an event listening has to occur first, then persistence logic in the student service must match the outcome of mapping an incoming message to a given student.

 Let's try to make this test pass.

 ```csharp
public partial class ProfileEventOrchestrationService : IProfileEventOrchestrationService
{
    private readonly IProfileEventService profileEventService;
    private readonly IProfileService profileService;
    private readonly ILoggingBroker loggingBroker;

    public ProfileEventOrchestrationService(
        IProfileEventProcessingService profileEventService,
        IProfileProcessingService profileService,
        ILoggingBroker loggingBroker)
    {
        this.profileEventService = profileEventService;
        this.profileService = profileService;
        this.loggingBroker = loggingBroker;
    }

    public void ListenToProfileEvents() =>
    TryCatch(() =>
    {
        this.profileEventService.ListenToProfileEvent(
            ProcessProfileEventAsync);
    });

    public ValueTask ProcessProfileEventAsync(ProfileEvent profileEvent) =>
    TryCatch(async () =>
    {
        ...

        await this.profileService.AddProfileAsync(profileEvent.Profile);
    });
}
 ```

In the above example, the constructor of the Orchestration service subscribes to the events that would come from the `StudentEventService`. When an event occurs, the orchestration service will call the `ProcessingIncomingStudentMessageAsync` function to persist the incoming student into the database through a foundation or a processing service at the same level as the event service.

This pattern or characteristic is called the Cul-De-Sac. An incoming message will turn and head in a different direction for a different dependency. This pattern is typical in large enterprise-level applications where eventual consistency is incorporated to ensure the system can scale and become resilient under heavy consumption. This pattern also prevents malicious attacks against your API endpoints since it allows processing queue messages or events whenever the service is ready to process them. We will discuss the details in 'The Standard Architecture.

## 2.3.3 Responsibilities
Orchestration services provide advanced business logic. It orchestrates multiple flows for multiple entities/models to complete a single flow. Let's discuss in detail what these responsibilities are:

### 2.3.3.0 Advanced Logic
Orchestration services cannot exist without combining multiple routines from multiple entities. These entities may differ in nature but share a common flow or purpose. For instance, a `LibraryCard` as a model is fundamentally different from a `Student` model. However, they both share a common purpose regarding the student registration process. Adding a student record is required to register a student, but assigning a library card to that student is required for a successful student registration process.

Orchestration services ensure the correct routines for each entity are integrated, but also ensure these routines are called in the correct order. Additionally, orchestration services are responsible for rolling back a failing operation. These three aspects constitute an orchestration effort across multiple routines, entities, or contracts.

Let's talk about those in detail.

#### 2.3.3.0.0 Flow Combinations
We spoke earlier about orchestration services combining multiple routines to achieve a common purpose or a single flow. This aspect of orchestration services can serve as both a fundamental characteristic and a responsibility. An orchestration service without at least one routine combining two or three entities is not considered an orchestration. Integrating with multiple services without a common purpose is a better-fit definition for Aggregation services which we will discuss later in this services chapter.

But within the flow combination comes the unification of contract. I call it mapping and branching. Mapping an incoming model into multiple lower-stream services models then branching the responsibility across these services.

Just like the previous services, during their flow combination, Orchestration services are responsible for ensuring the purity of the exposed input and output contracts, which becomes a bit more complex when combining multiple models. Orchestration services will continue to be responsible for mapping incoming contracts to their respective downstream services. They will also map back the returned results from these services into the unified model.

Let's bring back a previous code snippet to illustrate that aspect:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

private Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

private List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}

private MediaPost MapToMediaPost(Post post, List<Media> medias)
{
    return new MediaPost
    {
        Id = post.Id,
        Content = post.Content,
        Date = post.CreatedDate,
        Base64Images = medias.Select(media => media.Image)
    }
}
```
As you can see in the above example, the mapping and branching don't just happen on the way in. But a reverse action has to be taken on the way out. It violates The Standard to return the same input object that was passed in. That takes away any visibility on potential changes to the incoming request during persistence. The duplex mapping should substitute the need to dereference the incoming request to ensure no unexpected internal changes have occurred.

Note that breaking out the mapping logic into its own aspect/partial class file is also recommended. Something like `StudentOrchestrationService.Mappings.cs` to ensure the only thing left is orchestration's business logic.

#### 2.3.3.0.1 Call Order
Calling routines in the correct order can be crucial to any orchestration process. For instance, a library card cannot be created unless a student record is created first. Enforcing the order here can split into two different types. Let's talk about those here for a bit.

##### 2.3.3.0.1.0 Natural Order
The natural order here refers to specific flows that cannot be executed unless a prerequisite of input parameters is retrieved or persisted. For instance, imagine a situation where a library card cannot be created unless a student's unique identifier is retrieved first. In this case, we don't have to worry about testing that certain routines were called in the right order because it comes naturally with the flow.

Here's a code example of this situation:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    Student student = await this.studentProcessingService
        .RetrieveStudentByIdAsync(libraryCard.StudentId));

    return await this.libraryCardProcessingService
        .CreateLibraryCardAsync(libraryCard, student.Name);
}
```
In the example above, having a student `Name` is a requirement to create a library card. Therefore, the orchestration of order here comes naturally as part of the flow without additional effort.

Let's talk about the second type of order - Enforced Order.

##### 2.3.3.0.1.1 Enforced Order
Imagine the very same example above, but instead of the library card requiring a student name, it just needs the student `Id` already enclosed in the incoming request model. Something like this:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    await this.studentProcessingService.VerifyEnlistedStudentExistAsync(
        libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
}
```

Ensuring a verified enrolled student exists before creating a library card might become a challenge because there's no dependency between the return value of one routine and the input parameters of the next. In other words, there is nothing that the `VerifyEnlistedStudentExistAsync` function returns that the `CreateLibraryCardAsync` function cares about in terms of input parameters.

In this case here an enforced type of order must be implemented through unit tests. A unit test for this routine would require verifying not just that the dependency has been called with the correct parameters, but also that they are called in the correct _order_ let's take a look at how that would be implemented:

```csharp
[Fact]
public async Task ShouldCreateLibraryCardAsync()
{
    // given
    Student someStudent = CreateRandomStudent();
    LibraryCard randomLibraryCard = CreateRandomLibraryCard();
    LibraryCard inputLibraryCard = randomLibraryCard;
    LibraryCard createdLibraryCard = inputLibraryCard;
    LibraryCard expectedLibraryCard = inputLibraryCard.DeepClone();
    Guid studentId = inputLibraryCard.StudentId;
    var mockSequence = new MockSequence();

    this.studentProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.VerifyEnlistedStudentExistAsync(studentId))
            .Returns(someStudent);

    this.libraryCardProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.CreateLibraryCardAsync(inputLibraryCard))
            .ReturnsAsync(createdLibraryCard);

    // when
    LibraryCard actualLibraryCard = await this.libraryCardOrchestrationService
        .CreateLibraryCardAsync(inputLibraryCard);

    // then
    actualLibraryCard.Should().BeEquivalentTo(expectedLibraryCard);

    this.studentProcessingServiceMock.Verify(service =>
        service.VerifyEnlistedStudentExistAsync(studentId),
            Times.Once);

    this.libraryCardProcessingServiceMock.Verify(service =>
        service.CreateLibraryCardAsync(inputLibraryCard),
            Times.Once);

    this.studentProcessingServiceMock.VerifyNoOtherCalls();
    this.libraryCardProcessingServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

```

From the example above, the mock framework here is being used to ensure a certain order is enforced when calling these dependencies. This way we enforce a certain implementation within any given method to ensure that non-naturally connected dependencies are sequentially called in the intended order.

It's more likely that the type of ordering leans more towards enforced than natural when orchestration services reach the maximum number of dependencies.

#### 2.3.3.0.2 Exceptions Mapping (Wrapping & Unwrapping)
This responsibility is very similar to flow combinations. Except that in this case, orchestration services unify all the exceptions that may occur out of any of its dependencies into one unified categorical exception model. Let's start with an illustration of what that mapping may look like:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/145294325-0818a2dd-a017-43af-b1f0-fa5c93a9218c.png" />
    </p>
 <br />

In the illustration above, you will notice that validation and dependency validation exceptions, thrown from downstream dependency services, map into one unified dependency exception at the orchestration level. This practice allows upstream consumers of that same orchestration service to determine the next course of action based on one categorical exception type instead of four or in the case of three dependencies it would be six categorical dependencies.

Let's start with a failing test to materialize our idea here:

```csharp
public static TheoryData DependencyValidationExceptions()
{
    string exceptionMessage = GetRandomMessage();
    var innerException = new Xeption(exceptionMessage);

    var studentValidationException =
        new StudentValidationException(
            message: "Student validation error occurred, fix errors and try again.",
            innerException);

    var studentDependencyValidationException =
        new StudentDependencyValidationException(
            message: "Student dependency validation error occurred, fix errors and try again.",
            innerException);

    var libraryCardValidationException =
        new LibraryCardValidationException(
            message: "Library card validation error occurred, fix errors and try again.",
            innerException);

    var libraryCardDependencyValidationException =
        new LibraryCardDependencyValidationException(
            message: "Library card dependency validation error occurred, fix errors and try again.",
            innerException);

    return new TheoryData<Xeption>
    {
        studentValidationException,
        studentDependencyValidationException,
        libraryCardValidationException,
        libraryCardDependencyValidationException
    };
}


[Theory]
[MemberData(nameof(DependencyValidationExceptions))]
public async Task ShouldThrowDependencyValidationExceptionOnCreateIfDependencyValidationErrorOccursAndLogItAsync(
    Xeption dependencyValidationException)
{
    // given
    Student someStudent = CreateRandomStudent();

    var expectedStudentOrchestrationDependencyValidationException =
        new StudentOrchestrationDependencyValidationException(
            message: "Student dependency validation error occurred, fix errors and try again",
            dependencyValidationException.InnerException as Xeption);

    this.studentServiceMock.Setup(service =>
        service.AddStudentAsync(It.IsAny<Student>()))
            .ThrowsAsync(dependencyValidationException);

    // when
    ValueTask<Student> addStudentTask =
        await this.studentOrchestrationService.AddStudentAsync(someStudent);

    StudentOrchestrationDependencyValidationException
        actualStudentOrchestrationDependencyValidationException =
                await Assert.ThrowsAsync<StudentOrchestrationDependencyValidationException>(
                    addStudentTask.AsTask);

    // then
    actualStudentOrchestrationDependencyValidationException.Should()
        .BeEquivalentTo(expectedStudentOrchestrationDependencyValidationException);

    this.studentServiceMock.Verify(service =>
        service.AddStudentAsync(It.IsAny<Student>()),
            Times.Once);

    this.loggingBrokerMock.Verify(broker =>
        broker.LogError(It.Is(SameExceptionAs(
            expectedStudentOrchestrationDependencyValidationException))),
                Times.Once);

    this.libraryCardServiceMock.Verify(service =>
        service.AddLibraryCard(It.IsAny<Guid>()),
            Times.Once);

    this.studentServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.libraryCardServiceMock.VerifyNoOtherCalls();
}
```

Above, we verify that any of our four exception types are mapped into a `StudentOrchestrationDependencyValidationException`. We maintain the original localized exception as an inner exception. But we unwrap the categorical exception at this level to maintain the original issue as we go upstream.

These exceptions are mapped under a dependency validation exception because they originate from a dependency or a dependency of a dependency downstream. For instance, if a storage broker throws an exception that is a dependency validation (something like `DuplicateKeyException`). The broker-neighboring service would map that into a localized `StudentAlreadyExistException` and then wrap that exception in a categorical exception of type `StudentDependencyValidationException`. When that exception propagates upstream to Processing or an Orchestration service, we lose the categorical exception as we have already captured it under the right scope of mapping. Then we continue to embed that very localized exception under the current service dependency validation exception.

Let's try to make this test pass:

```csharp
public partial class StudentOrchestrationService
{
    private delegate ValueTask<Student> ReturningStudentFunction();

    private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
    {
        try
        {
            return await returningStudentFunction();
        }
        catch (StudentValidationException studentValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentValidationException);
        }
        catch (StudentDependencyValidationException studentDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentDependencyValidationException);
        }
        catch (LibraryCardValidationException libraryCardValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardValidationException);
        }
        catch (LibraryCardDependencyValidationException libraryCardDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardDependencyValidationException);
        }
    }

    private StudentOrchestrationDependencyValidationException CreateAndLogDependencyValidationException(Xeption exception)
    {
        var studentOrchestrationDependencyValidationException =
            new StudentOrchestrationDependencyValidationException(exception.innerException as Xeption);

        this.loggingBroker.LogError(studentOrchestrationDependencyValidationException);

        throw studentOrchestrationDependencyValidationException;
    }
}
```

Now we can use the `TryCatch` as follows:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () => 
{
    ...
    Student addedStudent = await this.studentService.AddStudentAsync(student);
    LibraryCard libraryCard = await this.libraryCard.AddLibraryCard(addedStudent.Id);

    return addedStudent;  
});
```

You can see in the implementation that we mapped all four different types of external downstream services validation exceptions into one categorical exception and then maintained the inner exception for each one.

The same rule applies to dependency exceptions. Dependency exceptions can be both Service and Dependency exceptions from downstream services. For instance, in the above example, calling a student service may produce `StudentDependencyException` and `StudentServiceException`. These categorical exceptions will be unwrapped from their categorical layer and have their local layer wrapped in one unified new orchestration-level categorical exception under `StudentOrchestrationDependencyException`. The same applies to all other dependency categorical exceptions like `LibraryCardDependencyException` and `LibraryCardServiceException`.

It's crucial to unwrap and wrap localized exceptions from downstream services with categorical exceptions at the current service layer to ensure consistency with the Exposers layer. These exceptions can be easily handled and mapped into whatever the nature of the exposer component dictates. In the case of an Exposer component of type API Controller, the mapping would produce HTTP Status Codes. In the case of UI Exposer components, it would map to text meaningful to end users.

We will discuss further upstream in this Standard when to expose localized inner exceptions details where end-users are not required to take any action, which is exclusive to dependency and service level exceptions.

## 2.3.4 Variations
Orchestration services vary depending on where they stand in the overall low-level architecture. For instance, an Orchestration service depending on downstream orchestration services is called a Coordination Service. An Orchestration service working with multiple Coordination services as dependencies are called a Management Service. These variants are an orchestration service with uber-level business logic.

 ### 2.3.4.0 Variants Levels
Let's take a look at the possible variants for orchestration services and where they would be positioned:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147461598-e7fe6b48-976a-4787-bd97-11e7faf131ee.png" />
    </p>
 <br />

 In my personal experience, I've rarely had to resolve to an Uber Management service. The idea of the limitation here in terms of dependencies and variations of orchestration-like services is to help engineers re-think the complexity of their logic. But admittedly, there are situations where complexity is an absolute necessity. Therefore Uber-Management services exist as an option.

 The following table should guide the process of developing variants of orchestration services based on the level:

| Variant								|   Dependencies            		| Consumers								    | Complexity |
|------------------------				|---------------------------		| ------------------------------------------| -----------|
| Orchestrations Services				| Foundation or Processing Services | Coordination Services     			    | Low    	 |
| Coordination Services				    | Orchestration Services 			| Management Services       			    | Medium     |
| Management Services					| Coordination Services          	| Uber Management Services			        | High       |
| Uber Management Services      		| Management Services               | Aggregation, Views or Exposer Components	| Very High	 |

 Working beyond Uber Management services in an orchestration manner would require a deeper discussion and a serious consideration of the overall architecture. Future versions of The Standard might be able to address this issue in what I call "The Lake House," but that is outside of the scope of this version of The Standard.

 ### 2.3.4.1 Unit of Work
 With the variations of orchestration services, I highly recommend staying true to the unit of work concept. Every request can do one thing and one thing only, including its prerequisites. For instance, if you need to register a student in a school, You may also require adding a guardian, contact information, and other details. Eventing these actions can significantly decrease the complexity of the flow and lower the risk of failures in downstream services.

 Here's a visualization for a complex single-threaded approach:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147462984-84e6dabd-bf27-413a-8e79-2659a24c37c0.png" />
    </p>
 <br />

 The solution above is a working solution for registering a student. We needed to include guardian information, library cards, classes, etc. These dependencies can be broken down into eventing, allowing other services to pick up where the single-threaded services leave off to continue the registration process. Something like this:


  <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147463233-466a055f-ce95-4911-92cd-7b173b2a37df.png" />
    </p>
  <br />

  Above, the incoming request is turned into events, where each of these events would notify its orchestration services in a cul-de-sac pattern as discussed in section 2.3.2.2. That means that a single thread is no longer responsible for the success of each dependency in the system. Instead, every event-listening broker would handle its process in a simplified way.

  This approach does not guarantee an immediate response of success or failure to the requestor. It's an eventual-consistency pattern where the client would get an `Accepted` message or its equivalent based on the communication protocol to let them know that a process has started. Still, there's no guarantee of results until all event logic has been executed.

  Note that we can add an extra layer of resiliency to these events by temporarily storing them in Queue-like components or memory-based temporary storages; depending on the criticality of the business.

  But an eventual consistency approach isn't always a good solution if the client on the other side is waiting for a response, especially in critical situations where an immediate response is required. One solution to this problem is Fire-n-Observe queues, which we will discuss in the future version of The Standard.
  
[*] [Introduction to Orchestration Services](https://www.youtube.com/watch?v=OP6HcIpXduE)

[*] [Cul-De-Sac Pattern for Orchestration Services](https://www.youtube.com/watch?v=C8Sm1kSKF1o)

[*] [Cul-De-Sac Pattern for Coordination Services](https://www.youtube.com/watch?v=8KZIw_IJC0U)
