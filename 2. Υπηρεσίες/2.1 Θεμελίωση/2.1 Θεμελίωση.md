# 2.1 Yπηρεσίες βάσης (Foundation Services) (Broker-Neighboring)

## 2.1.0 Εισαγωγή

Οι υπηρεσίες βάσης αποτελούν το πρώτο σημείο επαφής μεταξύ της επιχειρησιακής λογικής σας και των διαμεσολαβητών.

Γενικά, οι υπηρεσίες γειτονικές προς τους διαμεσολαβητές είναι ένα υβρίδιο της επιχειρησιακής λογικής και ενός abstraction επιπέδου για τις διαδικασίες επεξεργασίας, όπου η υψηλότερη τάξη της επιχειρησιακής λογικής διαδραματίζεται, θα μιλήσουμε περαιτέρω για αυτό όταν αρχίσουμε να εξερευνούμε τις υπηρεσίες επεξεργασίας στο επόμενο κεφάλαιο.

Η βασική ευθύνη των υπηρεσιών που είναι γειτονικές προς τους διαμεσολαβητές είναι να εξασφαλίζουν ότι τα δεδομένα που εισέρχονται και εξέρχονται από το σύστημα επικυρώνονται και ελέγχονται δομικά, λογικά και εξωτερικά.

Μπορείτε επίσης να σκεφτείτε τις υπηρεσίες γειτονικές προς τους διαμεσολαβητές ως ένα επίπεδο επικύρωσης πάνω από τις αρχικές λειτουργίες που ήδη προσφέρουν οι διαμεσολαβητές.

Για παράδειγμα, αν ένας διαμεσολαβητής αποθήκευσης προσφέρει μια μέθοδο `InsertStudentAsync(Student student)`, τότε η υπηρεσία γειτονική προς τους διαμεσολαβητές θα προσφέρει:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
}
```

Αυτό καθιστά τις υπηρεσίες γειτονικές προς τους διαμεσολαβητές τίποτα περισσότερο από ένα επιπλέον επίπεδο επαλήθευσης πάνω από τις υπάρχουσες αρχικές λειτουργίες που προσφέρουν οι διαμεσολαβητές.

## 2.1.1 Στον Χάρτη

Οι υπηρεσίες γειτονικές προς τους διαμεσολαβητές βρίσκονται μεταξύ των διαμεσολαβητών σας και του υπόλοιπου εφαρμογής σας. Στην αριστερή πλευρά μπορεί να υπάρχουν υπηρεσίες υψηλότερης τάξης για την επεξεργασία της επιχειρηματικής λογικής, ενόρχηστρωσης, συντονισμού, συγκέντρωσης ή διαχείρισης, ή απλώς ένας ελεγκτής, ένα στοιχείο διεπαφής χρήστη ή οποιαδήποτε άλλη τεχνολογία που εκθέτει δεδομένα.

<br/>
	<p align=center>
		<img src="https://user-images.githubusercontent.com/1453985/100716772-00eec800-336e-11eb-9064-8bfe2f8e3be2.png" />
	</p>
<br/>

## 2.1.2 Χαρακτηριστικά

Οι υπηρεσίες βάσης ή γειτονικές προς τους διαμεσολαβητές γενικά έχουν πολύ συγκεκριμένα χαρακτηριστικά που ελέγχουν αυστηρά την ανάπτυξή τους και ενσωμάτωσή τους.

Οι υπηρεσίες βάσης γενικά επικεντρώνονται περισσότερο στις επαληθεύσεις από οτιδήποτε άλλο - απλώς επειδή αυτός είναι ο σκοπός τους, να διασφαλίσουν ότι όλα τα εισερχόμενα και εξερχόμενα δεδομένα μέσω του συστήματος είναι σε καλή κατάσταση για να επεξεργαστεί το σύστημα με ασφάλεια χωρίς κανένα ζήτημα.

Εδώ είναι τα χαρακτηριστικά και οι κανόνες που ελέγχουν τις υπηρεσίες γειτονικές προς τους διαμεσολαβητές:

### 2.1.2.0 Αμιγός-Primitive

Οι υπηρεσίες γειτονικές προς τους διαμεσολαβητές δεν επιτρέπεται να συνδυάζουν πολλές primitive λειτουργίες για να πετύχουν μια λειτουργία υψηλότερης τάξης της επιχειρηματικής λογικής.

Για παράδειγμα, οι υπηρεσίες γειτονικές προς τους διαμεσολαβητές δεν μπορούν να προσφέρουν μια λειτουργία upsert, για να συνδυάσουν λειτουργίες `Select` με λειτουργίες `Update` ή `Insert` με βάση το αποτέλεσμα για να διασφαλίσουν ότι μια οντότητα υπάρχει και είναι ενημερωμένη σε οποιαδήποτε αποθήκευση.

Ωστόσο, προσφέρουν ένα περίβλημα επικύρωσης και χειρισμού εξαιρέσεων (και αντιστοίχισης) γύρω από τις κλήσεις εξαρτημένων στοιχείων, εδώ υπάρχει ένα παράδειγμα:

```csharp
public ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Στην παραπάνω μέθοδο, μπορείτε να δείτε την κλήση της συνάρτησης `ValidateStudent` που προηγείται από ένα μπλοκ `TryCatch`.
Το μπλοκ `TryCatch` είναι αυτό που αποκαλώ πρότυπο Ακύρωσης Θορύβου Εξαιρέσεων, το οποίο θα συζητήσουμε σύντομα σε αυτήν ακριβώς την ενότητα.

Αλλά η συνάρτηση επικύρωσης διασφαλίζει ότι κάθε ιδιότητα στα εισερχόμενα δεδομένα επικυρώνεται προτού περάσει μπροστά στην πρωτεϊνική λειτουργία του διαμεσολαβητή, η οποία είναι η `InsertStudentAsync` σε αυτήν τη συγκεκριμένη περίπτωση.

### 2.1.2.1 Ενσωμάτωση Μοναδικής Οντότητας

Οι υπηρεσίες διασφαλίζουν ισχυρά ότι η αρχή της μοναδικής ευθύνης εφαρμόζεται με το να μην ενσωματώνουν με οποιονδήποτε άλλο διαμεσολαβητή οντότητας εκτός από αυτόν που υποστηρίζεται.

Αυτός ο κανόνας δεν ισχύει απαραίτητα για τους διαμεσολαβητές υποστήριξης όπως οι `DateTimeBroker` ή `LoggingBroker`, αφού δεν στοχεύουν ειδικά καμία συγκεκριμένη επιχειρησιακή οντότητα και είναι σχεδόν γενικοί για ολόκληρο το σύστημα.

Για παράδειγμα, μια υπηρεσία `StudentService` μπορεί να ενσωματωθεί με έναν `StorageBroker` όσον αφορά μόνο τη λειτουργικότητα που προσφέρεται από την μερική κλάση στο αρχείο `StorageBroker.Students`.cs.

Οι υπηρεσίες βάσης δεν θα πρέπει να ενσωματώνουν περισσότερους από έναν διαμεσολαβητή οντότητας οικοδομής, καθώς αυτό θα αυξήσει την πολυπλοκότητα της επικύρωσης και της οργάνωσης, πράγμα που υπερβαίνει τον βασικό σκοπό της υπηρεσίας που είναι απλά η επικύρωση. Μεταφέρουμε αυτήν την ευθύνη περαιτέρω στις υπηρεσίες τύπου οργάνωσης για να την αντιμετωπίσουν.

### 2.1.2.2 Επιχειρηματική Γλώσσα (Business Language)

Οι υπηρεσίες γειτονίας με τους μεσίτες χρησιμοποιούν μια αρχαιογνωρισμένη επιχειρησιακή γλώσσα για τις λειτουργίες τους. Για παράδειγμα, ενώ ένας Μεσίτης μπορεί να παρέχει μια μέθοδο με το όνομα `InsertStudentAsync`, το αντίστοιχο στρώμα υπηρεσιών θα ήταν `AddStudentAsync`.

Συνολικά, οι περισσότερες από τις λειτουργίες CRUD πρέπει να μετατραπούν από μια γλώσσα αποθήκευσης σε μια επιχειρησιακή γλώσσα, και το ίδιο ισχύει για μη-αποθήκευση λειτουργίες όπως οι ουρές. Για παράδειγμα, λέμε `PostQueueMessage` για τον μεσίτη ουράς, αλλά στο επίπεδο των επιχειρήσεων πρέπει να λέμε `EnqueueMessage`.

Επειδή οι λειτουργίες CRUD είναι οι πιο κοινές σε κάθε σύστημα, η αντιστοίχισή μας για αυτές τις λειτουργίες CRUD θα είναι ως εξής:

| Brokers | Services |
| ------- | :------: |
| Insert  |   Add    |
| Select  | Retrieve |
| Update  |  Modify  |
| Delete  |  Remove  |

Καθώς προχωράμε προς τις υπηρεσίες υψηλότερης τάξης επιχειρηματικής λογικής, η γλώσσα των μεθόδων που χρησιμοποιούνται θα κλίνει περισσότερο προς μια επιχειρηματική γλώσσα παρά προς μια τεχνολογική γλώσσα, όπως θα δούμε στα επερχόμενα κεφάλαια.

## 2.1.3 Ευθύνες

Οι υπηρεσίες γειτονίας με τους μεσίτες έχουν τρεις πολύ σημαντικούς ρόλους σε κάθε σύστημα.

Ο πρώτος ρόλος είναι να αποσυνδέσουν τις φυσικές λειτουργίες των μεσιτών από το υπόλοιπο σύστημα. Ανεξάρτητα από το εάν ένας μεσίτης αντιπροσωπεύει την επικοινωνία με την τοπική ή εξωτερική αποθήκευση ή ένα API, οι υπηρεσίες γειτονίας με τους μεσίτες θα έχουν πάντα το ίδιο συμβόλαιο/ορολογία που θα αποκαλύψουν σε ανώτερες υπηρεσίες όπως η επεξεργασία, ο συντονισμός ή απλά οι εκθέτες όπως οι ελεγκτές (controllers) ή συστατικά διεπαφές χρήστη (UI components).

Ο δεύτερος και πιο σημαντικός ρόλος είναι να προσφέρουν ένα επίπεδο επικύρωσης πάνω από τις υπάρχουσες πρωτογενείς λειτουργίες που προσφέρει ήδη ένας μεσίτης, για να εξασφαλίσουν ότι τα εισερχόμενα και εξερχόμενα δεδομένα είναι έγκυρα για να επεξεργαστούν ή να αποθηκευτούν από το σύστημα.

Ο τρίτος ρόλος είναι να λειτουργούν ως μεταφραστές για όλα τα άλλα φυσικά μοντέλα και συμβόλαια που μπορεί να χρειαστούν για να ολοκληρωθεί οποιαδήποτε δοθείσα λειτουργία κατά τη διάρκεια της διασύνδεσης με έναν μεσίτη.
Οι υπηρεσίες των θεμελιωδών στοιχείων είναι το τελευταίο σημείο αφαίρεσης μεταξύ του πυρήνα επιχειρηματικής λογικής οποιουδήποτε συστήματος και του υπόλοιπου κόσμου, ας συζητήσουμε αυτούς τους ρόλους αναλυτικά.

### 2.1.3.0 Aφαίρεση (Abstraction)

Η πρώτη και πιο σημαντική ευθύνη για τις υπηρεσίες βάσης / μεσιτείας μεσίτη είναι να διασφαλίζουν την ύπαρξη ενός επιπέδου αφαίρεσης μεταξύ των μεσιτών και του υπόλοιπου συστήματός σας. Αυτή η αφαίρεση είναι απαραίτητη για να διασφαλιστεί ότι το αγνό επίπεδο της επιχειρηματικής λογικής σε κάθε σύστημα είναι λεκτικά και λειτουργικά αδιάφορο για τις εξαρτήσεις που εξαρτώνται το σύστημα για να επικοινωνήσει με τον εξωτερικό κόσμο.

Ας οπτικοποιήσουμε ένα πρακτικό παράδειγμα της παραπάνω αρχής. Ας υποθέσουμε ότι έχουμε ένα `StudentProcessingService` που υλοποιεί μια λειτουργία `UpsertStudentAsync`. Κάπου σε αυτήν την υλοποίηση θα υπάρχει μια εξάρτηση από το `AddStudentAsync` που εκτίθεται και υλοποιείται από κάποια `StudentService` ως υπηρεσία βάσης. Ρίξτε μια ματιά σε αυτό το απόσπασμα:

```csharp
public async ValueTask<Student> UpsertStudentAsync(Student student)
{
	...

	return await this.studentService.AddStudentAsync(student);
}
```

Ο συμβολαιακός όρος μεταξύ μιας υπηρεσίας επεξεργασίας ή ορχήστρας και μιας υπηρεσίας βάσης θα είναι πάντα ο ίδιος ανεξάρτητα από τον τύπο της υλοποίησης ή τον τύπο των μεσιτών που χρησιμοποιεί η υπηρεσία βάσης.
Για παράδειγμα, το `AddStudentAsync` θα μπορούσε να είναι μια κλήση προς μια βάση δεδομένων ή ένα API endpoint ή απλά τοποθέτηση ενός μηνύματος σε μια ουρά. Όλα αυτά δεν επηρεάζουν καθόλου την υλοποίηση της ανωτέρας υπηρεσίας επεξεργασίας. Εδώ υπάρχει ένα παράδειγμα τριών διαφορετικών υλοποιήσεων μιας υπηρεσίας βάσης που δεν θα άλλαζαν καθόλου την υλοποίηση των ανωτέρων υπηρεσιών:

Με έναν μεσίτη αποθήκευσης:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...
	return await this.storageBroker.InsertStudentAsync(student);
}
```

Ή με έναν μεσίτη ουράς:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.queueBroker.EnqueueStudentAsync(student);
}
```

ή με έναν μεσίτη API:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.apiBroker.PostStudentAsync(student);
}
```

εδώ είναι μια οπτικοποίηση αυτής της έννοιας:

<br />

<div align=center>
	<img width="75%" src="https://user-images.githubusercontent.com/1453985/128610577-ee926ee2-a589-4f77-bf9d-dbff63d1c20d.png" />
</div>

<br />

Σε όλες αυτές τις παραπάνω περιπτώσεις, η υποκείμενη υλοποίηση μπορεί να αλλάξει, αλλά το συμβόλαιο θα παραμείνει πάντα το ίδιο για το υπόλοιπο του συστήματος. Θα συζητήσουμε σε μελλοντικά κεφάλαια πώς ο πυρήνας, και αφηρημένη επιχειρηματική λογική του συστήματός σας ξεκινά με τις υπηρεσίες επεξεργασίας και καταλήγει σε υπηρεσίες Διαχείρισης ή Συγκέντρωσης (Aggregation).

#### 2.1.3.0.1 Υλοποίηση

Ας μιλήσουμε για ένα πραγματικό παράδειγμα υλοποίησης μιας απλής λειτουργίας προσθήκης (Add) σε μια υπηρεσία βάσης. Ας υποθέσουμε ότι έχουμε το ακόλουθο συμβόλαιο για την υπηρεσία `StudentService` μας:

```csharp
public IStudentService
{
	ValueTask<Student> AddStudentAsync(Student student);
}
```

Για αρχή, ας συνεχίσουμε και ας γράψουμε ένα αποτυχημένο τεστ για την υπηρεσία μας ως εξής:

```csharp
public async Task ShouldAddStudentAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	Student storageStudent = inputStudent;
	Student expectedStudent = storageStudent.DeepClone();

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(inputStudent))
			.ReturnsAsync(storageStudent);

	// when
	Student actualStudent =
		await this.studentService.AddStudentAsync(inputStudent);

	// then
	actualStudent.Should().BeEquivalentTo(expectedStudent);

	this.storageBroker.Verify(broker =>
		broker.InsertStudentAsync(inputStudent),
			Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
}
```

Στο παραπάνω τεστ, ορίσαμε τέσσερις μεταβλητές με την ίδια τιμή. Κάθε μεταβλητή περιέχει ένα όνομα που ταιριάζει καλύτερα με το πλαίσιο στο οποίο θα χρησιμοποιηθεί. Για παράδειγμα, η inputStudent ταιριάζει καλύτερα στη θέση της εισαγωγικής παραμέτρου, ενώ η storageStudent ταιριάζει καλύτερα σε αυτό που επιστρέφεται από τον μεσίτη αποθήκευσης μετά από μια επιτυχή αποθήκευση του φοιτητή.

Επίσης, τυχαιοποιούμε τις εισόδους και τις εξόδους σε όλα τα τεστ για να διασφαλίσουμε ότι το τεστ επικεντρώνεται σε συγκεκριμένη λειτουργική συμπεριφορά. Υπάρχουν περιπτώσεις όπου απαιτείται να δοκιμάσουμε για συγκεκριμένη τιμή ή σύνολο τιμών. Αλλά αυτό πρέπει να έχει ισχυρή δικαιολογία για να το κάνουμε.

Είναι εύκολο να "απατήσουμε" τα τεστ ώστε να αναφέρουν μια επιτυχημένη λειτουργία χρησιμοποιώντας συγκεκριμένες εισαγωγικές παραμέτρους ή τιμές εξόδου. Η τυχαιοποίηση είναι απαραίτητη από προεπιλογή, εκτός εάν απαιτείται κάτι διαφορετικό. Για παράδειγμα, εάν έχετε μια συνάρτηση Πρόσθεση(χ, y) και το τεστ περνάει ειδικά τις τιμές 1 και 2 στη συνάρτηση και περιμένει την τιμή 3 ως αποτέλεσμα, τότε κάποιος θα μπορούσε να παραβλέψει την πραγματική αριθμητική λειτουργία και να επιστρέψει απλά το 3 κάθε φορά από τη στόχευση συνάρτηση. Λαμβάνοντας υπόψη το μεγαλύτερο επίπεδο κλίμακας σε μια επιχείρηση καθώς το πρόβλημα γίνεται πιο πολύπλοκο, μπορούμε να διαπιστώσουμε πόσο σημαντικό και κρίσιμο είναι να τυχαιοποιούμε τις εισόδους και τις εξόδους από προεπιλογή.

Επίσης, θα παρατηρήσετε ότι πραγματοποιήσαμε βαθειά αντιγραφή της μεταβλητής expectedStudent για να διασφαλίσουμε ότι δεν έχουν γίνει τροποποιήσεις στον αρχικά περασμένο φοιτητή. Για παράδειγμα, υποθέστε ότι μια τιμή φοιτητή έχει αλλάξει για οποιοδήποτε από τα χαρακτηριστικά της εσωτερικά μέσα στη συνάρτηση AddStudentAsync. Αυτή η αλλαγή δεν θα ενεργοποιήσει ένα τεστ αποτυχίας, εκτός εάν απελευθερώσουμε τη μεταβλητή expectedStudent από την είσοδο και τις εξόδους των μεταβλητών.

Κάνουμε ψεύτικη απόκριση από τον μεσίτη αποθήκευσης και εκτελούμε το θέμα του τεστ AddStudentAsync και στη συνέχεια επαληθεύουμε ότι η τιμή του φοιτητή που επιστράφηκε actualStudent ταιριάζει με την αναμενόμενη τιμή expectedStudent ανεξάρτητα από την αναφορά.

Τέλος, επαληθεύουμε ότι όλες οι κλήσεις έχουν γίνει σωστά και δεν έχουν γίνει πρόσθετες κλήσεις σε κανένα από τα εξαρτήματα της υπηρεσίας.

Ας κάνουμε τη δοκιμή αυτή να περάσει γράφοντας μια υλοποίηση που να ικανοποιεί μόνο τις απαιτήσεις της παραπάνω δοκιμής:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
	await this.storageBroker.InsertStudentAsync(student);
```

Αυτή η απλή υλοποίηση θα πρέπει να κάνει το τεστ μας να περάσει με επιτυχία. Είναι σημαντικό να κατανοήσετε ότι οποιαδήποτε υλοποίηση πρέπει να είναι μόνο αρκετή για να περάσει τα αποτυχημένα τεστ. Τίποτα περισσότερο και τίποτα λιγότερο.

### 2.1.3.1 Validation

Οι υπηρεσίες βάσης απαιτούν να διασφαλίζουν ότι τα εισερχόμενα και εξερχόμενα δεδομένα από και προς το σύστημα είναι σε καλή κατάσταση - παίζουν το ρόλο του πύλης μεταξύ του συστήματος και του εξωτερικού κόσμου για να διασφαλίσουν ότι τα δεδομένα που περνούν είναι δομικά, λογικά και εξωτερικά έγκυρα πριν από την πραγματοποίηση οποιωνδήποτε περαιτέρω λειτουργιών από τις ροές των υπηρεσιών αμοιβαίας πρόσβασης.
Η σειρά των επικύρωσεων εδώ είναι πολύ προσεκτικά σχεδιασμένη. Οι δομικές επικυρώσεις είναι οι πιο οικονομικές από όλες τις τρεις τύπους. Εξασφαλίζουν ότι ένα συγκεκριμένο χαρακτηριστικό ή κομμάτι δεδομένων γενικά δεν έχει μια προεπιλεγμένη τιμή αν είναι απαιτούμενο. Το αντίθετο αυτού είναι οι λογικές επικυρώσεις, όπου τα χαρακτηριστικά συγκρίνονται με άλλα χαρακτηριστικά με το ίδιο οντότητα ή οποιαδήποτε άλλη. Επιπλέον λογικές επικυρώσεις μπορεί να περιλαμβάνουν επίσης τη σύγκριση με μια σταθερή τιμή, όπως η σύγκριση της ηλικίας εγγραφής του μαθητή ώστε να μην είναι μικρότερη των 5 ετών.
Και οι δομικές και οι λογικές επικυρώσεις γίνονται πριν από τις εξωτερικές. Όπως είπαμε, αυτό συμβαίνει απλά επειδή δεν θέλουμε να πληρώσουμε το κόστος της επικοινωνίας με εξωτερικό πόρο, συμπεριλαμβανομένου του φόρου καθυστέρησης, αν το αίτημά μας δεν είναι σε καλή κατάσταση πρώτα.
Για παράδειγμα, δεν θα πρέπει να προσπαθήσουμε να δημοσιεύσουμε ένα αντικείμενο `Student` σε ένα εξωτερικό API αν το αντικείμενο είναι `null`. Ή αν το μοντέλο `Student` δεν είναι δομικά ή λογικά έγκυρο.

Για όλους τους τύπους επικυρώσεων, είναι σημαντικό να κατανοήσουμε ότι ορισμένες επικυρώσεις είναι αποκλειστικές ή απαιτούν μια άμεση έξοδο από την τρέχουσα ροή με τη ρίψη μιας εξαίρεσης ή την επιστροφή ενός τιμής σε ορισμένες περιπτώσεις. Και ορισμένες άλλες επικυρώσεις είναι συνεχείς. Ας μιλήσουμε πρώτα για αυτές τις δύο υποκατηγορίες των επικυρώσεων.

#### 2.1.3.1.0 Επικυρώσεις Διακοπής Κυκλώματος

Οι επικυρώσεις διακοπής κυκλώματος απαιτούν μια άμεση έξοδο από την τρέχουσα ροή. Για παράδειγμα, εάν ένα αντικείμενο που περνάει σε μια συνάρτηση είναι `null` - δεν χρειάζονται περαιτέρω λειτουργίες σε αυτό το επίπεδο εκτός από την έξοδο από την τρέχουσα ροή με τη ρίψη μιας εξαίρεσης ή την επιστροφή μιας τιμής κάποιου τύπου. Εδώ υπάρχει ένα παράδειγμα:
Σε μια περίπτωση επικύρωσης, ας υποθέσουμε ότι η συνάρτηση `AddStudent` έχει έναν φοιτητή με τιμή `null` που περνιέται ως εξής:

```csharp
Student noStudent = null;

await this.studentService.AddStudentAsync(noStudent);
```

Our `AddStudentAsync` function in this scenario is now required to validate whether the passed in parameter is `null` or not before going any further with any other type of validations or the business logic itself. Something like this:

```csharp
public Student AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Η δήλωση που επικεντρώνεται εδώ είναι η συνάρτηση `ValidateStudent` και το τι κάνει. Παρακάτω παραθέτω ένα παράδειγμα πώς θα υλοποιούνταν αυτή η διαδικασία:

```csharp
private void ValidateStudent(Student student)
{
	if(student is null)
	{
		throw new NullStudentException();
	}
}
```

Στη συνάρτηση που παρατίθεται παραπάνω, αποφασίσαμε να εκτοξεύσουμε αμέσως την εξαίρεση αντί να συνεχίσουμε περαιτέρω. Αυτός είναι ένας τύπος επικύρωσης με αμέση διακοπή (circuit-breaking validation).

Αλλά με τις επικυρώσεις, η αμέση διακοπή δεν είναι πάντα η σοφή επιλογή. Μερικές φορές θέλουμε να συλλέξουμε όλα τα θέματα εντός μιας συγκεκριμένης αίτησης πριν στείλουμε την έκθεση σφαλμάτων πίσω στον αποστολέα του αιτήματος. Ας μιλήσουμε για αυτό στην επόμενη ενότητα.

#### 2.1.3.1.1 Συνεχείς επικυρώσεις (Continuous Validations)

Οι συνεχείς επικυρώσεις είναι το αντίθετο των επικυρώσεων με αμέσως διακοπή (circuit-breaking validations). Δεν διακόπτουν τη ροή των επικυρώσεων, αλλά διακόπτουν σίγουρα τη ροή της λογικής. Με άλλα λόγια, οι συνεχείς επικυρώσεις διασφαλίζουν ότι δεν θα εκτελεστεί καμία επιχειρηματική λογική, αλλά επιτρέπουν επίσης σε άλλες επικυρώσεις του ίδιου τύπου να συνεχίσουν την εκτέλεσή τους πριν διακόψουν τη ροή. Ας υλοποιήσουμε αυτήν τη θεωρία με ένα παράδειγμα:

Υποθέστε ότι το μοντέλο μας για τον φοιτητή φαίνεται έτσι:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

Υποθέτοντας ότι το μοντέλο Student που περνιέται δεν είναι null, αλλά έχει προεπιλεγμένες τιμές για όλες τις ιδιότητές του. Θέλουμε να συλλέξουμε όλα αυτά τα θέματα για όσες ιδιότητες/χαρακτηριστικά έχει αυτό το αντικείμενο και να επιστρέψουμε μια πλήρη έκθεση στον αποστολέα του αιτήματος. Ας δούμε πώς να το κάνουμε αυτό.

#### 2.1.3.1.1.0 Upsertable Exceptions

Ένα πρόβλημα του τύπου αυτού απαιτεί έναν ειδικό τύπο εξαιρέσεων που επιτρέπει τη συλλογή όλων των σφαλμάτων στην ιδιότητα `Data`. Κάθε ενσωματωμένη εξαίρεση περιέχει την ιδιότητα `Data`, η οποία είναι βασικά ένα λεξικό με ζευγάρια κλειδιού/τιμής για τη συλλογή περισσότερων πληροφοριών για τα προβλήματα που προκάλεσαν την εξαίρεση αυτή να συμβεί.
Το πρόβλημα με αυτές τις ενσωματωμένες εξαιρέσεις είναι ότι δεν έχουν ενσωματωμένη υποστήριξη για την εισαγωγή. Δηλαδή, τη δυνατότητα να προσθέτετε σε μια υπάρχουσα λίστα τιμών έναντι ενός συγκεκριμένου κλειδιού ανά πάσα στιγμή.
Εδώ υπάρχει μια ενσωματωμένη υλοποίηση της εισαγωγής τιμών σε ένα δεδομένο λεξικό:

```csharp
var someException = new Exception();

if(someException.Data.Contains(someKey))
{
	(someException.Data[someKey] as List<string>)?.Add(someValue);
}
else
{
	someException.Data.Add(someKey, new List<string>{ someValue });
}
```

Αυτή η υλοποίηση μπορεί να είναι αρκετά δύσκολη για τους μηχανικούς να σκεφτούν και να δοκιμάσουν στην υλοποίηση σε επίπεδο υπηρεσίας. Ήταν πιο κατάλληλο να εισαγάγουμε μια απλή βιβλιοθήκη `Xeption` για να απλοποιήσουμε την παραπάνω υλοποίηση σε κάτι τόσο απλό όσο:

```csharp
var someException = new Xeption();
someException.UpsertDataList(someKey, someValue);
```

Τώρα που έχουμε αυτήν τη βιβλιοθήκη για να χρησιμοποιήσουμε, η ανησυχία για την υλοποίηση εξαιρέσεων που μπορούν να ενημερώνονται έχει επιλυθεί. Αυτό σημαίνει ότι έχουμε ό,τι χρειαζόμαστε για να συλλέξουμε τα σφάλματα των επικυρώσεων μας. Ωστόσο, αυτό δεν είναι αρκετά καλό εάν δεν έχουμε ένα μηχανισμό για να διακόψουμε το κύκλωμα όταν πιστεύουμε ότι είναι η κατάλληλη στιγμή να το κάνουμε.
Μπορούμε απλά να χρησιμοποιήσουμε τις ενσωματωμένες δυνατότητες για να υλοποιήσουμε απευθείας τον διακοπτόμενο κύκλωμα ως εξής:

```csharp
if(someException.Data.Count > 0)
{
	throw someException;
}
```

Και ενώ αυτό μπορεί να ενσωματωθεί εύκολα σε οποιαδήποτε υπάρχουσα υλοποίηση. Παρόλα αυτά, δεν συνέβαλε πολύ στην συνολική εμφάνιση και αίσθηση του κώδικα. Για αυτόν τον λόγο αποφάσισα να το κάνω μέρος της βιβλιοθήκης `Xeption` για να απλοποιηθεί ως εξής:

```csharp
someException.ThrowIfContainsErrors();
```
Αυτό θα κάνει τις προσαρμοσμένες μας επικυρώσεις να φαίνονται κάτι σαν αυτό:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		: base (message: "Student is invalid. Please fix the errors and try again.")
	{ }

	public InvalidStudentException(string message)
		: base (message) {}
}
```


Κάθε προσαρμοσμένη εξαίρεση, είτε είναι τοπικοποιημένη είτε κατηγοριοποιημένη, θα έχει στην ουσία δύο διαφορετικούς κατασκευαστές. Ο πρώτος κατασκευαστής ενσωματώνει το `exception message` για να διευκολύνει τη χρήση της εξαίρεσης. Ο δεύτερος κατασκευαστής είναι κυρίως για δοκιμές για να διασφαλίσει ότι τα μηνύματα που επικοινωνούνται μέσω της εξαίρεσης είναι τα σωστά μηνύματα.

Αλλά με τις συνεχείς επικυρώσεις, η διαδικασία συλλογής αυτών των σφαλμάτων μεταφέρει περισσότερα από απλά μια ειδική υλοποίηση εξαίρεσης. Θα συζητήσουμε περισσότερα για αυτό στο επόμενο κεφάλαιο.

#### 2.1.3.1.1.1 Δυναμικοί Κανόνες

Ένας μη κυκλωματικός ή συνεχής διαδικασία επικύρωσης θα απαιτήσει τη δυνατότητα να περνιούνται δυναμικοί κανόνες σε οποιοδήποτε αριθμό ή χωρητικότητα για να προστεθούν αυτά τα σφάλματα επικύρωσης. Ένας κανόνας επικύρωσης είναι μια δυναμική δομή που αναφέρει εάν ο κανόνας έχει παραβιαστεί για τη συνθήκη του· και επίσης το μήνυμα σφάλματος που πρέπει να αναφερθεί στον τελικό χρήστη για να του βοηθήσει να διορθώσει αυτό το πρόβλημα.

Σε ένα σενάριο όπου θέλουμε να διασφαλίσουμε ότι οποιοσδήποτε δοθείς αναγνωριστικό είναι έγκυρο, ένας δυναμικός συνεχής κανόνας επικύρωσης θα μοιάζει κάπως έτσι:

```csharp
private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id is required"
};
```

Τώρα ο κανόνας μας δεν αναφέρει απλώς εάν ένα συγκεκριμένο χαρακτηριστικό είναι έγκυρο ή όχι. Έχει επίσης ένα νόημα που είναι αναγνώρισης για τον καταναλωτή της υπηρεσίας για να κατανοήσει τι καθιστά αυτό το συγκεκριμένο χαρακτηριστικό μη έγκυρο.

Είναι πολύ σημαντικό να επισημάνουμε τη γλώσσα που πρέπει να χρησιμοποιούν οι μηχανικοί για τα μηνύματα επικύρωσης. Αυτό θα εξαρτηθεί πλήρως από τους δυνητικούς χρήστες του συστήματός σας. Ένας μη μηχανικός δεν θα κατανοήσει ένα μήνυμα όπως "To κείμενο δεν μπορεί να είναι null, κενό ή κενό διάστημα" - το "null" ως έννοια δεν είναι κάτι πολύ κοινά χρησιμοποιούμενο. Οι μηχανικοί πρέπει να συνεργαστούν στενά με τους χρήστες τους για να βεβαιωθούν ότι η γλώσσα καθιστά νόημα για αυτούς.

Οι δυναμικοί κανόνες, κατά σχεδιασμό, θα επιτρέψουν στους μηχανικούς να τροποποιήσουν τόσο τις εισόδους όσο και τις εξόδους τους χωρίς να διακυβεύουν τη λειτουργικότητα του υπάρχοντος, όσον καιρό οι τιμές null λαμβάνονται υπόψη. Εδώ υπάρχει ένα ακόμη παράδειγμα ενός Δυναμικού Κανόνα Επικύρωσης:

```csharp
private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
{
	Condition = firstId != secondId,
	Message = $"Id is not the same as {secondIdName}.",
	HelpLink = "/help/code1234"
};
```

Ο δυναμικός κανόνας μας τώρα μπορεί να προσφέρει περισσότερες παραμέτρους εισόδου και περισσότερες χρήσιμες πληροφορίες σε όρους πιο λεπτομερούς μηνύματος εξαιρέσεων με συνδέσμους προς χρήσιμες ιστοσελίδες τεκμηρίωσης ή αναφορές για κωδικούς σφαλμάτων.

#### 2.1.3.1.1.2 Συλλέκτης Κανόνων & Επικυρώσεων

Τώρα που έχουμε τις προηγμένες εξαιρέσεις και τους δυναμικούς κανόνες επικύρωσης. Είναι η στιγμή να τα ενοποιήσουμε όλα όσον αφορά την αποδοχή άπειρου αριθμού κανόνων επικύρωσης, την εξέταση των αποτελεσμάτων των συνθηκών τους και τέλος τον τερματισμό του κυκλώματος όταν ολοκληρωθούν όλες οι συνεχείς επικυρώσεις. Εδώ είναι πώς να το κάνετε αυτό:

```csharp
private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Η παραπάνω συνάρτηση τώρα θα δέχεται οποιονδήποτε αριθμό κανόνων επικύρωσης, καθώς και τις παραμέτρους στις οποίες εκτελούνται οι κανόνες, και στη συνέχεια θα εξετάζει τις συνθήκες και θα ενημερώνει την αναφορά των σφαλμάτων. Έτσι μπορούμε να χρησιμοποιήσουμε την παραπάνω μέθοδο ως εξής:

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)),
		(Rule: IsInvalid(student.Name), Parameter: nameof(Student.Name)),
		(Rule: IsInvalid(student.Grade), Parameter: nameof(Student.Grade))
	);
}
```
Αυτός ο απλοποιημένος τρόπος εγγραφής των κανόνων και των επικυρώσεων είναι το τελικό στόχος της παροχής αξίας στους τελικούς χρήστες ενώ ταυτόχρονα καθιστά ευχάριστη τη διαδικασία της ανάπτυξης της λύσης για τους μηχανικούς.

Τώρα, ας εμβαθύνουμε στους τύπους επικυρώσεων που μπορούν να προσφέρουν τα συστήματά μας και πώς να τις χειριστούμε.

#### 2.1.3.1.1.3 Υβριδικές Συνεχείς Επικυρώσεις
Η παραπάνω δομή επιτρέπει την υποστήριξη σεναρίων για επικυρώσεις εμφωλευμένων αντικειμένων. Για παράδειγμα, ας υποθέσουμε ότι το μοντέλο `Student` μας έχει περισσότερα από απλούς τύπους στη δομή του, όπως εξής:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
	public StudentAddress Address {get; set;}
}
```

Ας υποθέσουμε ότι το μοντέλο `StudentAddress` αποτελείται από ιδιότητες πρωτογενούς τύπου, από τις οποίες όλες ή τουλάχιστον κάποιες είναι υποχρεωτικές. Λαμβάνοντας υπόψη ότι το `StudentAddress` φαίνεται ως εξής:

```csharp
public class StudentAddress
{
	public string Street {get; set;}
	public string City {get; set;}
	public string ZipCode {get; set;}
}
```

Σε αυτήν την περίπτωση, δεν μπορούμε να επικυρώσουμε το `Address`ως μια ιδιότητα στο επίπεδο του `Student` και επίσης το `Street`, το `City` και το `ZipCode` στο ίδιο επίπεδο με την παραπάνω γονική/συσκευαστική ιδιότητα. Αυτό οφείλεται στο ότι αυτό θα προκαλούσε ένα σφάλμα `NullReferenceException` και ενδέχεται να διακόψει το κύκλωμα ανεπιθύμητα πέρα από ό,τι μπορούν να χειριστούν οι τοπικές εξαιρέσεις.

Σε αυτήν την περίπτωση, θα χρειαστεί να υιοθετήσουμε μια υβριδική προσέγγιση ως εξής:

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)),
		(Rule: IsInvalid(student.Name), Parameter: nameof(Student.Name)),
		(Rule: IsInvalid(student.Address), Parameter: nameof(Student.Address))
	);

	Validate(
		(Rule: IsInvalid(student.Address.Street), Parameter: nameof(StudentAddress.Street)),
		(Rule: IsInvalid(student.Address.City), Parameter: nameof(StudentAddress.City)),
		(Rule: IsInvalid(student.Address.ZipCode), Parameter: nameof(StudentAddress.ZipCode))
	);
}
```
Στον παραπάνω κώδικα, κάθε επίπεδο χειρίζεται ξεχωριστά. Θα διακόψουμε το κύκλωμα μόλις διαπιστώσουμε ότι η πρώτη γύρα επαληθεύσεων απέτυχε. Ωστόσο, αν η ιδιότητα Address είναι σε καλή κατάσταση, μπορούμε να συνεχίσουμε στην επόμενη γύρα πιο βαθιών επαληθεύσεων στο υπο-επίπεδο των ιδιοτήτων `StreetAddress (ZipCode, City και Street)`.

Αυτό το σενάριο συμβαίνει συνήθως με τις επαληθεύσεις σε επίπεδο ενορχήστρωσης για εικονικά μοντέλα και πιθανώς με τις ενσωματώσεις API  integrations at the Foundation Services level.

#### 2.1.3.1.2 Structural Validations

Οι επαληθεύσεις χωρίζονται σε τρία διαφορετικά επίπεδα. Το πρώτο από αυτά τα επίπεδα είναι οι δομικές επαληθεύσεις για να διασφαλίσουν ότι ορισμένες ιδιότητες σε οποιοδήποτε δοσμένο μοντέλο ή αρχέτυπο τύπου δεν βρίσκονται σε μη έγκυρη δομική κατάσταση.

Για παράδειγμα, μια ιδιότητα τύπου `String` δεν θα πρέπει να είναι κενή, `null` ή κενό διάστημα. Ένα άλλο παράδειγμα θα ήταν για ένα παράμετρο εισόδου τύπου `int`, η οποία δεν θα πρέπει να βρίσκεται στην `default` κατάστασή της, η οποία είναι το `0`, όταν προσπαθούμε να εισάγουμε για παράδειγμα ηλικία.

Οι δομικές επαληθεύσεις διασφαλίζουν ότι τα δεδομένα είναι σε καλή κατάσταση πριν προχωρήσουμε σε περαιτέρω επαληθεύσεις - για παράδειγμα, δεν μπορούμε να επαληθεύσουμε φοιτητές που έχουν τον ελάχιστο αριθμό χαρακτήρων (το οποίο είναι μια λογική επαλήθευση) στα ονόματά τους αν το όνομα τους είναι δομικά άκυρο λόγω null, κενού ή κενού διαστήματος.

Οι δομικές επαληθεύσεις παίζουν το ρόλο της αναγνώρισης των απαιτούμενων ιδιοτήτων σε οποιοδήποτε δοσμένο μοντέλο, και ενώ πολλές τεχνολογίες προσφέρουν σημειώσεις επαλήθευσης, πρόσθετα ή βιβλιοθήκες για την καθολική επιβολή κανόνων επικύρωσης δεδομένων, επέλεξα να εκτελέσω την επαλήθευση προγραμματιστικά και χειροκίνητα για να αποκτήσω περισσότερο έλεγχο σχετικά με το τι θα ήταν απαιτούμενο και τι όχι, με τη λογική της ανάπτυξης μέσω δοκιμασίας (TDD).

Το πρόβλημα με μερικές από τις τρέχουσες υλοποιήσεις στις δομικές και λογικές επαληθεύσεις σε μοντέλα δεδομένων είναι ότι μπορεί να αλλάξει πολύ εύκολα από κάτω από το ραντάρ χωρίς να ενεργοποιηθούν συναγερμοί από κανένα μονάδων δοκιμών. Ελέγξτε αυτό το παράδειγμα, για παράδειγμα:

```csharp
public Student
{
	[Required]
	public string Name {get; set;}
}
```

Το παραπάνω παράδειγμα μπορεί να φαίνεται πολύ πειστικό με μια πρώτη ματιά από μια μηχανική σκοπιά. Απλά πρέπει να διακοσμήσετε την ιδιότητα του μοντέλου με μια μαγική σημείωση και ξαφνικά τα δεδομένα σας επικυρώνονται.

Το πρόβλημα εδώ είναι ότι αυτό το μοτίβο συνδυάζει δύο διαφορετικές ευθύνες ή και περισσότερες μαζί, όλες στο ίδιο μοντέλο. Τα μοντέλα πρέπει να είναι απλώς αναπαραστάσεις αντικειμένων στην πραγματικότητα - τίποτα περισσότερο και τίποτα λιγότερο. Κάποιοι μηχανικοί τα αποκαλούν "αναιμικά μοντέλα", τα οποία επικεντρώνουν την ευθύνη κάθε μοντέλου μόνο στην αναπαράσταση των ιδιοτήτων του αντικειμένου του πραγματικού κόσμου που προσπαθεί να προσομοιώσει χωρίς περαιτέρω λεπτομέρειες.

Ωστόσο, τα μοντέλα που έχουν ανακοινωθεί τώρα προσπαθούν να εισάγουν επιχειρηματική λογική στον ορισμό τους. Αυτή η επιχειρηματική λογική μπορεί να χρειάζεται ή όχι σε όλες τις υπηρεσίες, τα συστήματα διαμεσολάβησης ή τα εκθέτοντα στοιχεία που τα χρησιμοποιούν.

Οι δομικές επικυρώσεις στα μοντέλα μπορεί να φαίνονται σαν περιττή δουλειά που μπορεί να αποφευχθεί με μαγικές διακοσμήσεις. Αλλά στην περίπτωση που προσπαθείτε να αποκλίνετε ελαφρώς από αυτές τις επικυρώσεις σε πιο προσαρμοσμένες επικυρώσεις, τότε θα δείτε να εμφανίζεται ένα νέο αντι-πρότυπο όπως οι προσαρμοσμένες σημειώσεις που ενδέχεται να είναι ανιχνεύσιμες ή όχι μέσω μονάδων δοκιμής.

Ας μιλήσουμε για το πώς να δοκιμάσουμε μια δομική διαδικασία επικύρωσης:

##### 2.1.3.1.2.0 οκιμή Δομικών Επικυρώσεων

Επειδή πιστεύω ακράδαντα στη σημασία της Δοκιμαστικής Οδήγησης της Ανάπτυξης (TDD), θα αρχίσω να δείχνω την υλοποίηση των δομικών επικυρώσεων γράφοντας πρώτα μια αποτυχημένη δοκιμή για αυτές.

Ας υποθέσουμε ότι έχουμε ένα μοντέλο φοιτητή, με τις παρακάτω λεπτομέρειες:

```csharp
public class Student
{
	public Guid Id {get; set;}
}
```

Θέλουμε να επικυρώσουμε ότι το αναγνωριστικό φοιτητή (Id) δεν είναι δομικά μη έγκυρο - όπως ένα κενό Guid - επομένως θα γράψουμε ένα μοναδικό τεστ με τον ακόλουθο τρόπο:

```csharp
[Fact]
public async void ShouldThrowValidationExceptionOnRegisterWhenIdIsInvalidAndLogItAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.Id = Guid.Empty;

	var invalidStudentException =
		new InvalidStudentException(
			message: "Student is invalid. Please fix the errors and try again.");

	invalidStudentException.AddData(
		key: nameof(Student.Id),
		value: "Id is required"
	);

	var expectedStudentValidationException =
		new StudentValidationException(
			message: "Student validation error occurred, fix errors and try again.",
			innerException: invalidStudentException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNoOtherCalls();
}
```

Στην παραπάνω δοκιμή, δημιουργήσαμε ένα τυχαίο αντικείμενο φοιτητή και αναθέσαμε μια μη έγκυρη τιμή Guid.Empty στην ιδιότητα Id του φοιτητή.

Όταν η λογική της δομικής επικύρωσης στην υπηρεσία βάσης μας εξετάζει την ιδιότητα Id, πρέπει να εκτοξεύσει μια εξαίρεση που περιγράφει το πρόβλημα επικύρωσης στο μοντέλο μας φοιτητή. Σε αυτήν την περίπτωση, εκτοξεύουμε την InvalidStudentException.

Η εξαίρεση απαιτείται να περιγράφει σύντομα τα τι, πού και γιατί της λειτουργίας επικύρωσης. Στην περίπτωση μας, το τι θα είναι το πρόβλημα επικύρωσης που συμβαίνει, το πού θα είναι η υπηρεσία φοιτητής και το γιατί θα είναι η τιμή ιδιότητας.

Εδώ είναι πώς θα φαίνεται μια `InvalidStudentException`:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		: base (message: "Student is invalid. Please fix the errors and try again.")
	{ }

	public InvalidStudentException(string message)
		: base (message) {}
}
```

Το παραπάνω μοναδικό δοκιμαστικό σενάριο απαιτεί ότι η `InvalidStudentException` μας να περικλείεται σε μια πιο γενική εξαίρεση σε επίπεδο συστήματος, η οποία είναι η `StudentValidationException` - αυτές οι εξαιρέσεις είναι αυτές που αποκαλώ εξωτερικές εξαιρέσεις, καθώς συγκεντρώνουν όλες τις διαφορετικές καταστάσεις επικυρώσεων ανεξάρτητα από την κατηγορία τους και επικοινωνούν το σφάλμα στις ροές ροών προς τα πάνω (upstream) ή στα σημεία ελέγχου (controllers), έτσι ώστε αυτοί να αντιστοιχίσουν το σφάλμα στον κατάλληλο κωδικό σφάλματος για τον καταναλωτή αυτών των υπηρεσιών.

Η `StudentValidationException` μας θα υλοποιηθεί ως εξής:

```csharp
public class StudentValidationException : Exception
{
	public StudentValidationException(Exception innerException)
		: base("Student validation error occurred, please check your input and try again.",
			innerException) { }

	public StudentValidationException(string message, Exception innerException)
		: base (message, innerException) {}
}
```
Το μήνυμα στην εξωτερική επικύρωση παραπάνω υποδηλώνει ότι το πρόβλημα βρίσκεται στην είσοδο και, συνεπώς, απαιτεί από τον υποβάλλοντα την είσοδο να δοκιμάσει ξανά καθώς δεν απαιτούνται ενέργειες από την πλευρά του συστήματος για να προσαρμοστεί.

##### 2.1.3.1.2.1 Υλοποίηση Επικυρώσεων Δομής

Τώρα, ας ρίξουμε μια ματιά στην άλλη πλευρά της διαδικασίας επικύρωσης, που είναι η υλοποίηση.
Οι δομικές επικυρώσεις πάντα έρχονται πριν από κάθε άλλο είδος επικυρώσεων. Αυτό είναι απλά επειδή οι δομικές επικυρώσεις είναι οι φθηνότερες από πλευράς εκτέλεσης και χρόνου απόψης ασυμπτωτικού χρόνου.
Για παράδειγμα, είναι πολύ φθηνότερο να επικυρώσετε ότι ένα Id είναι δομικά μη έγκυρο, από το να στείλετε ένα κλήση API για να λάβετε την ακριβώς ίδια απάντηση μαζί με το κόστος της καθυστέρησης. Όλα αυτά προστίθενται όταν πολυεκατομμύρια αιτήσεις ανά δευτερόλεπτο αρχίζουν να ρέουν.
Οι δομικές και λογικές επικυρώσεις, γενικά, ζουν σε δικές τους μερικές κλάσεις για να εκτελούν αυτές τις επικυρώσεις. Για παράδειγμα, αν η υπηρεσία μας ονομάζεται StudentService.cs, τότε θα πρέπει να δημιουργηθεί ένα νέο αρχείο με το όνομα StudentService.Validations.cs για να συνοψίσει και να απομονώσει οπτικά τους κανόνες επικύρωσης και να διασφαλιστεί ότι τα δεδομένα που εισέρχονται και εξέρχονται είναι σε καλή κατάσταση.

Εδώ είναι πώς θα φαίνεται μια επικύρωση του Id:

###### StudentService.Validations.cs

```csharp

private void ValidateStudent(Student student)
{
	Validate((Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)));
}

private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id is required"
};

private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertDataList(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Έχουμε υλοποιήσει μια μέθοδο για τον έλεγχο ολόκληρου του αντικειμένου φοιτητή, με μια συγκέντρωση όλων των κανόνων που χρειάζεται να ρυθμίσουμε για να επικυρώσουμε δομικά και λογικά το αντικείμενο εισόδου του φοιτητή. Το πιο σημαντικό σημείο που πρέπει να παρατηρηθεί στο παραπάνω απόσπασμα κώδικα είναι να διασφαλίσουμε την ενθυλάκωση οποιωνδήποτε λεπτομερειών περαιτέρω από τον κύριο στόχο μιας συγκεκριμένης μεθόδου.

Αυτό είναι το λόγο για τον οποίο αποφασίσαμε να υλοποιήσουμε μια ιδιωτική στατική μέθοδο `IsInvalid` για να απομονώσουμε τις λεπτομέρειες του τι καθιστά μια ιδιότητα τύπου `Guid` μη έγκυρη ή όχι. Και καθώς προχωρούμε περαιτέρω στην υλοποίηση, θα πρέπει να υλοποιήσουμε πολλαπλές εκδόσεις της ίδιας μεθόδου για τον δομικό και λογικό έλεγχο άλλων τύπων τιμής.

Ο σκοπός της μεθόδου `ValidateStudent` είναι απλά να διαμορφώσει τους κανόνες και να εκτελέσει μια ενέργεια εάν παραβιαστούν κάποιοι από αυτούς τους κανόνες. Υπάρχει πάντα η δυνατότητα να συγκεντρώσετε τα σφάλματα παραβίασης αντί να ρίξετε το σφάλμα πολύ νωρίς με το πρώτο σημάδι δομικού ή λογικού προβλήματος που θα εντοπιστεί.

Τώρα, με την υλοποίηση που προηγήθηκε, πρέπει να καλέσουμε αυτήν τη μέθοδο για να γίνει δομική και λογική επικύρωση της εισόδου μας. Ας κάνουμε αυτήν την κλήση στη μέθοδο `RegisterStudentAsync` μας, όπως ακολούθως:

###### StudentService.cs

```csharp
public ValueTask<Student> RegisterStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Με μια ματιά, θα παρατηρήσετε ότι η μέθοδός μας εδώ δεν χειρίζεται απαραίτητα κανένα είδος εξαιρέσεων στο επίπεδο της λογικής. Αυτό συμβαίνει διότι και όλος ο θόρυβος των εξαιρέσεων αποσυνδέεται επίσης σε μια μέθοδο με το όνομα `TryCatch`.

Το `TryCatch` είναι ένας όρος που δημιούργησα για να επιτρέψει στους μηχανικούς να επικεντρωθούν στο πιο σημαντικό βάσει του ποια πτυχή της υπηρεσίας κοιτούν, χωρίς να χρειάζεται να πάρουν βραχυκυκλώματα με την επεξεργασία των εξαιρέσεων για να κάνουν τον κώδικα λίγο πιο αναγνώσιμο.

Οι μέθοδοι `TryCatch` γενικά βρίσκονται σε ένα άλλο τμήμα, και ένα εντελώς νέο αρχείο που ονομάζεται `StudentService.Exceptions.cs` - εκεί όπου γίνεται όλη η διαχείριση των εξαιρέσεων και η αναφορά σφαλμάτων, όπως θα σας δείξω στο επόμενο παράδειγμα.

Ας ρίξουμε μια ματιά σε πώς φαίνεται μια μέθοδος `TryCatch`:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	catch (InvalidStudentException invalidStudentInputException)
	{
		throw CreateAndLogValidationException(invalidStudentInputException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Το πρότυπο `TryCatch` για την απόσβεση του θορύβου των εξαιρέσεων όμορφα δέχεται οποιαδήποτε συνάρτηση που επιστρέφει ένα συγκεκριμένο τύπο ως αναφορέα και χειρίζεται οποιαδήποτε εξαιρέσεις που εκτοξεύονται από αυτήν τη συνάρτηση ή τις εξαρτήσεις της.

Η κύρια ευθύνη ενός `TryCatch` είναι να συσκευάζει τις εσωτερικές εξαιρέσεις ενός υπηρεσίας με εξωτερικές εξαιρέσεις για να απλοποιήσει την αντίδραση των εξωτερικών καταναλωτών της υπηρεσίας αυτής σε μόνο ένα από τα τρία κύρια είδη εξαιρέσεων, τα οποία είναι Εξαιρέσεις Υπηρεσίας, Εξαιρέσεις Επικυρώσεων και Εξαιρέσεις Εξαρτήσεων. Υπάρχουν υποτύποι αυτών των εξαιρέσεων, όπως οι Εξαιρέσεις Επικύρωσης Εξαρτήσεων, αλλά αυτές συνήθως υπάγονται στην κατηγορία Εξαιρέσεων Επικύρωσης, όπως θα συζητήσουμε λεπτομερώς όταν προχωρήσουμε στην υπεύθυνη του Χαρτογράφησης των υπηρεσιών που βρίσκονται δίπλα στον διαμεσολαβητή (foundation) τους.

Σε μια μέθοδο `TryCatch`, μπορούμε να προσθέσουμε όσες εσωτερικές και εξωτερικές εξαιρέσεις θέλουμε και να τις αντιστοιχίσουμε σε τοπικές εξαιρέσεις για να μην υπάρχει έντονη εξάρτηση των ροών προς τα πάνω από τις υπηρεσίες σε κάποιες συγκεκριμένες βιβλιοθήκες ή μοντέλα εξωτερικών πόρων, για τα οποία θα συζητήσουμε αναλυτικά όταν προχωρήσουμε στην υπεύθυνη της Χαρτογράφησης των υπηρεσιών που βρίσκονται δίπλα στον διαμεσολαβητή (foundation) τους.

#### 2.1.3.1.3 Λογικές Επικυρώσεις

Οι λογικές επικυρώσεις βρίσκονται δεύτερες σε σειρά από τις δομικές επικυρώσεις. Η κύρια ευθύνη τους κατά ορισμό είναι να επικυρώνουν λογικά εάν ένα δομικά έγκυρο κομμάτι δεδομένων είναι και λογικά έγκυρο.
Για παράδειγμα, μια ημερομηνία γέννησης για έναν μαθητή μπορεί να είναι δομικά έγκυρη με μια τιμή `1/1/1800`, αλλά λογικά, ένας μαθητής που είναι πάνω από 200 χρόνια είναι αδύνατον.

Οι πιο συνηθισμένες λογικές επικυρώσεις είναι οι επικυρώσεις για τα πεδία ελέγχου, όπως το `CreatedBy` και το `UpdatedBy` - είναι λογικά αδύνατον να εισαχθεί ένα νέο αρχείο με δύο διαφορετικές τιμές για τους δημιουργούς του αρχείου αυτού - απλώς επειδή τα δεδομένα μπορούν να εισαχθούν από ένα άτομο τη φορά.

Ας μιλήσουμε για το πώς μπορούμε να υλοποιήσουμε λογικές επικυρώσεις με τη μέθοδο της δοκιμής και εξέλιξης (TDD):

##### 2.1.3.1.3.0 Δοκιμάζοντας τις λογικές επικυρώσεις

Στην κοινή περίπτωση δοκιμής λογικών επικύρωσης για τα πεδία ελέγχου, θέλουμε να πετάξουμε μια εξαίρεση επικύρωσης ότι η τιμή του πεδίου `UpdatedBy` δεν είναι έγκυρη, απλά επειδή δεν ταιριάζει με το πεδίο `CreatedBy`.

Ας υποθέσουμε ότι το μοντέλο του φοιτητή (Student) φαίνεται ως εξής:

```csharp
public class Student {
	Guid CreatedBy {get; set;}
	Guid UpdatedBy {get; set;}
}
```

Our test to validate these values logically would be as follows:

```csharp
[Fact]
public async Task ShouldThrowValidationExceptionOnRegisterIfUpdatedByNotSameAsCreatedByAndLogItAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.UpdatedBy = Guid.NewGuid();

	var invalidStudentException = 
		new InvalidStudentException(
			message: "Student is invalid. Please fix the errors and try again.");

	invalidStudentException.AddData(
		key: nameof(Student.UpdatedBy),
		value: $"Id is not the same as {nameof(Student.CreatedBy)}.");

	var expectedStudentValidationException =
		new StudentValidationException(
			message: "Student validation error occurred, fix errors and try again.",
			innerException: invalidStudentException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

Στο παραπάνω τεστ, έχουμε αλλάξει την τιμή του πεδίου `UpdatedBy` για να διασφαλίσουμε ότι διαφέρει πλήρως από το πεδίο `CreatedBy` - τώρα αναμένουμε μια `InvalidStudentException` με το CreatedBy ως τον λόγο για τον οποίο προκύπτει αυτή η εξαίρεση επικύρωσης.

Ας προχωρήσουμε και γράψουμε μια υλοποίηση για αυτό το αποτυχημένο τεστ.

##### 2.1.3.1.3.1 Implementing Logical Validations

Όπως κάναμε και στην ενότητα των δομικών επικυρώσεων, θα προσθέσουμε περισσότερους κανόνες στο `switch case` των επικυρώσεων μας, όπως παρακάτω:

###### StudentService.Validations.cs

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsNotSame(
			firstId: student.UpdatedBy,
			secondId: student.CreatedBy,
			secondIdName: nameof(student.CreatedBy)),
		Parameter: nameof(Student.UpdatedBy))
	);
}

private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
	{
		Condition = firstId != secondId,
		Message = $"Id is not the same as {secondIdName}."
	};

private void Validate(params (dyanamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new Exception();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(
				key: parameter,
				value: rule.Message);
		}
	}
}
```

Όλα τα υπόλοιπα στα αρχεία `StudentService.cs` και `StudentService.Exceptions.cs` συνεχίζονται να είναι ακριβώς τα ίδια με αυτά που κάναμε παραπάνω για τις δομικές επικυρώσεις.

Οι εξαιρέσεις λογικών επικυρώσεων, όπως και κάθε άλλη εξαίρεση που μπορεί να συμβεί, συνήθως δεν είναι κρίσιμες. Ωστόσο, όλα εξαρτώνται από την επιχειρησιακή σας περίπτωση για να καθορίσετε εάν μια συγκεκριμένη επικύρωση λογικής, δομικής ή ακόμα και εξάρτησης είναι κρίσιμη ή όχι. Σε αυτήν την περίπτωση, μπορεί να χρειαστεί να δημιουργήσετε μια ειδική κλάση εξαιρέσεων, κάτι σαν το `InvalidStudentCriticalException`, και να καταγράφετε τα γεγονότα ανάλογα.

#### 2.1.3.1.4 Εξωτερικές Επικυρώσεις

Ο τελευταίος τύπος επικυρώσεων που συνήθως πραγματοποιούνται από τις υπηρεσίες βάσης είναι οι εξωτερικές επικυρώσεις. Ορίζω τις εξωτερικές επικυρώσεις ως οποιαδήποτε μορφή επικυρώσεων που απαιτεί την κλήση ενός εξωτερικού πόρου για να επικυρωθεί εάν μια υπηρεσία βάσης πρέπει να συνεχίσει την επεξεργασία εισερχόμενων δεδομένων ή να σταματήσει με μια εξαίρεση.

Ένα καλό παράδειγμα εξωτερικών επικυρώσεων είναι όταν καλούμε ένα μεσίτη για να ανακτήσουμε μια συγκεκριμένη οντότητα βάση του αναγνωριστικού της. Εάν η επιστρεφόμενη οντότητα δεν βρεθεί ή ο μεσίτης του API επιστρέψει ένα σφάλμα "Not Found", τότε η υπηρεσία βάσης απαιτείται να εγκλωβίσει αυτό το σφάλμα σε μια `ValidationException` και να διακόψει όλες τις επόμενες διαδικασίες.

Οι εξαιρέσεις εξωτερικών επικυρώσεων μπορεί να εμφανιστούν εάν η επιστρεφόμενη τιμή δεν ταιριάζει με την προσδοκία, όπως για παράδειγμα μια κενή λίστα που επιστρέφεται από μια κλήση API όταν προσπαθούμε να εισαγάγουμε έναν νέο προπονητή ομάδας - αν δεν υπάρχουν μέλη της ομάδας, δεν μπορεί να υπάρχει προπονητής για παράδειγμα. Στην περίπτωση αυτή, η υπηρεσία βάσης θα απαιτηθεί να εγείρει μια τοπική εξαίρεση για να εξηγήσει το πρόβλημα, κάτι σαν το `NoTeamMembersFoundException` ή κάτι παρόμοιο.

Ας γράψουμε ένα αποτυχημένο τεστ για ένα παράδειγμα εξωτερικής επικύρωσης:

##### 2.1.3.1.4.0 Δοκιμάζοντας τις εξωτερικές επικυρώσεις

Ας υποθέσουμε ότι προσπαθούμε να ανακτήσουμε έναν μαθητή με ένα `Id` που δεν αντιστοιχεί σε κανένα εγγραφή στη βάση δεδομένων. Ας διαμορφώσουμε πρώτα ένα μοντέλο `NotFoundStudentException` ως εξής:

```csharp
using Xeption;

public class NotFoundStudentException : Xeption
{
	public NotFoundStudentException(Guid id)
		: base (message: $"Couldn't find a student with id: {id}.")
	{}

	public NotFoundStudentException(string message)
		: base (message) {}
}
```

Το παραπάνω μοντέλο είναι η πτυχή της τοπικοποίησης για την αντιμετώπιση του προβλήματος. Ας γράψουμε τώρα ένα τεστ που αποτυγχάνει ως εξής:

```csharp
public async Task ShouldThrowValidationExceptionOnRetrieveByIdIfStudentNotFoundAndLogItAsync()
{
	// given
	Guid randomStudentId = Guid.NewGuid();
	Guid inputStudentId = randomStudentId;
	Student noStudent = null;

	var notFoundStudentException =
		new NotFoundStudentException(
			message: $"Couldn't find a student with id: {inputStudentId}");

	var expectedStudentValidationException =
		new StudentValidationException(
			message: "Student validation error occurred, fix errors and try again.",
			innerException: notFoundStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.SelectStudentByIdAsync(inputStudentId))
			.ReturnsAsync(noStudent);

	// when
	ValueTask<Student> retrieveStudentByIdTask =
		this.studentService.RetrieveStudentByIdAsync(inputStudentId);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			retrieveStudentByIdTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.SelectStudentByIdAsync(inputStudentId),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNotOtherCalls();
}
```

Το παραπάνω τεστ απαιτεί από εμάς να εκτοξεύσουμε μια τοπικοποιημένη εξαίρεση όπως την `NotFoundStudentException` όταν ο αποθηκευτικός μεσίτης δεν επιστρέφει καμία τιμή για τον δοσμένο `studentId` και στη συνέχεια να τυλίξουμε αυτήν την εξαίρεση σε μια `StudentValidationException`.

Επιλέξαμε να τυλίξουμε την τοπικοποιημένη εξαίρεση σε μια εξαίρεση επικύρωσης και όχι σε μια εξαίρεση εξαρτήσεων διότι η προέλευση του σφάλματος προήλθε από την υπηρεσία μας και όχι από το εξωτερικό πόρο. Εάν ο εξωτερικός πόρος ήταν η πηγή του σφάλματος, θα έπρεπε να ταξινομήσουμε αυτό ως μια `DependencyValidationException`, το οποίο θα συζητήσουμε σύντομα.

Ας προχωρήσουμε στο κομμάτι της υλοποίησης αυτής της ενότητας για να κάνουμε το τεστ μας να περάσει.

##### 2.1.3.1.4.1 Υλοποίηση των Εξωτερικών Επικυρώσεων

Για να υλοποιήσουμε μια εξωτερική επικύρωση, θα πρέπει να αγγίξουμε διάφορες πτυχές της υπηρεσίας μας. Η βασική λογική, οι επικυρώσεις και η χειρισμός εξαιρέσεων είναι ως εξής.

Καταρχάς, ας κατασκευάσουμε μια συνάρτηση επικύρωσης που θα εκτοξεύσει μια `NotFoundStudentException` αν η παράμετρος που περνάτε είναι κενή.

###### StudentService.Validations.cs

```csharp
private static void VerifyStudentExists(Student maybeStudent, Guid studentId)
{
	if (maybeStudent is null)
	{
		throw new NotFoundStudentException(studentId);
	}
}
```

Αυτή η υλοποίηση θα φροντίσει για την ανίχνευση ενός προβλήματος και την έκδοση μιας τοπικής εξαίρεσης `NotFoundStudentException`. Τώρα ας μεταβούμε στην πτυχή της χειρισμού των εξαιρέσεων της υπηρεσίας μας.

###### StudentService.Exceptions.cs

```csharp
private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	..
	catch (NotFoundStudentException notFoundStudentException)
	{
		throw CreateAndLogValidationException(notFoundStudentException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

The above implementation will take care of categorizing a `NotFoundStudentException` to `StudentValidationException`. The last part is to put the pieces together as follows.

###### StudentService.cs

```csharp
public ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId) =>
TryCatch(async () =>
{
	ValidateStudentId(studentId);

	Student maybeStudent =
		await this.storageBroker.SelectStudentByIdAsync(studentId);

	ValidateStudentExists(maybeStudent, studentId);

	return maybeStudent;
});
```

Η παραπάνω υλοποίηση θα διασφαλίσει ότι το αναγνωριστικό είναι έγκυρο, αλλά πιο σημαντικό είναι ότι το αντικείμενο που επιστρέφει ο `storageBroker` θα ελεγχθεί για το εάν είναι αντικείμενο ή `null`. Έπειτα θα εκδώσει την εξαίρεση.

Υπάρχουν καταστάσεις όπου η προσπάθεια να ανακτήσετε μια οντότητα και να διαπιστώσετε ότι δεν υπάρχει δεν είναι απαραίτητα λανθασμένη. Εδώ είναι όπου οι Υπηρεσίες Επεξεργασίας εκμεταλλεύονται μια επιχειρηματική λογική υψηλότερης τάξης για να αντιμετωπίσουν αυτό το πιο σύνθετο σενάριο.

#### 2.1.3.1.5 Εξαρτημένες Επικυρώσεις

Οι εξαιρέσεις επικύρωσης εξαρτήσεων μπορεί να συμβούν επειδή καλέσατε ένα εξωτερικό πόρο και επέστρεψε ένα σφάλμα ή μια τιμή που δικαιολογεί την εκτύπωση ενός σφάλματος. Για παράδειγμα, μια κλήση σε ένα API μπορεί να επιστρέψει έναν κωδικό `404`, και αυτό ερμηνεύεται ως μια εξαίρεση εάν το εισερχόμενο έπρεπε να αντιστοιχεί σε ένα υπάρχον αντικείμενο.

Ένα πιο συνηθισμένο παράδειγμα είναι όταν ένα εισερχόμενο στοιχείο χρησιμοποιεί το ίδιο αναγνωριστικό όπως ένα υπάρχον στοιχείο στο σύστημα. Στον κόσμο της σχεσιακής βάσης δεδομένων, θα εκτοξεύοταν μια εξαίρεση διπλού κλειδιού. Σε ένα σενάριο RESTful API, η εφαρμογή της ίδιας έννοιας με προγραμματιστικό τρόπο επιτυγχάνει επίσης τον ίδιο στόχο για τις επικυρώσεις του API, υποθέτοντας ότι η ακρίβεια του συστήματος που καλείται αποδυναμώνει τη συνοχή της αναφορικής ακεραιότητας των δεδομένων του συστήματος συνολικά.


Υπάρχουν καταστάσεις όπου η ελαττωματική απόκριση μπορεί να εκφραστεί με έναν τρόπο διαφορετικό από τις εξαιρέσεις, αλλά θα αναφερθούμε σε αυτό το θέμα σε πιο προηγμένα κεφάλαια αυτού του Προτύπου.

Ας γράψουμε ένα δοκιμαστικό τεστ που θα επιβεβαιώσει εάν εκτοξεύουμε μια `DependencyValidationException` αν το μοντέλο `Student` υπάρχει ήδη στην αποθήκη και η υπηρεσία αποθήκευσης εκτοξεύει μια `DuplicateKeyException` ως αποτέλεσμα της λειτουργίας.

##### 2.1.3.1.5.0 Testing Dependency Validations

Ας υποθέσουμε ότι το μοντέλο μας του φοιτητή χρησιμοποιεί ένα `Id` με τον τύπο `Guid` όπως φαίνεται παρακάτω:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```
Το μοναδικό μας τεστ για την επιβεβαίωση ότι θα ρίξει μια εξαίρεση `DependencyValidation` σε μια κατάσταση `DuplicateKey` θα ήταν ως εξής:

```csharp
[Fact]
public async void ShouldThrowDependencyValidationExceptionOnRegisterIfStudentAlreadyExistsAndLogItAsync()
{
	// given
	Student someStudent = CreateRandomStudent();
	string someMessage = GetRandomMessage();
	
	var duplicateKeyException = 
		new DuplicateKeyException(exceptionMessage);

	var alreadyExistsStudentException =
		new AlreadyExistsStudentException(
			message: "Student with the same id already exists.",
			innerException: duplicateKeyException);

	var expectedStudentDependencyValidationException =
		new StudentDependencyValidationException(
			message: "Student dependency validation error occurred, try again.",
			innerException: alreadyExistsStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()))
			.ThrowsAsync(duplicateKeyException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentDependencyValidationException actualStudentDependencyValidationException =
		await Assert.ThrowsAsync<StudentDependencyValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentDependencyValidationException.Should().BeEquivalentTo(
		expectedStudentDependencyValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentDependencyValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
}
```

Στο παραπάνω τεστ, επαληθεύουμε ότι συσκευάζουμε μια εγγενή `DuplicateKeyException` μέσα σε ένα τοπικό μοντέλο που προσαρμόζεται στη συγκεκριμένη περίπτωση μοντέλου, που στην περίπτωσή μας είναι το `AlreadyExistsStudentException`. Στη συνέχεια, το συσκευάζουμε ξανά με ένα γενικότερο μοντέλο κατηγορίας εξαιρέσεων, δηλαδή το `StudentDependencyValidationException`.

Υπάρχουν μερικοί κανόνες που διέπουν την κατασκευή των εξαρτημένων επικυρώσεων, οι οποίοι είναι οι εξής:

- Κανόνας 1: Εάν μια εξάρτηση επικύρωσης διαχειρίζεται μια άλλη εξάρτηση επικύρωσης από ένα υποκείμενο υπηρεσίας, τότε η εσωτερική εξαίρεση της ροής εξαίρεσης πρέπει να είναι η ίδια για την εξάρτηση επικύρωσης στο τρέχον επίπεδο.

Με άλλα λόγια, εάν μια υπηρεσία `StudentService` προκαλεί μια `StudentDependencyValidationException` σε μια προϋπάρχουσα υπηρεσία, όπως η `StudentProcessingService`, τότε είναι σημαντικό η `StudentProcessingDependencyValidationException` να περιέχει την ίδια εσωτερική εξαίρεση με την `StudentDependencyValidationException`. Αυτό συμβαίνει διότι, μόλις αυτές οι εξαιρέσεις μεταφραστούν σε συστατικά εκθέσεων, όπως ένας ελεγκτής API ή συστατικά διεπαφής χρήστη, το αρχικό μήνυμα επικύρωσης πρέπει να διαδοθεί μέσω του συστήματος και να παρουσιαστεί στον τελικό χρήστη, ανεξάρτητα από το πού προήλθε.

Επιπλέον, η διατήρηση της αρχικής εσωτερικής εξαίρεσης εξασφαλίζει τη δυνατότητα να επικοινωνούν διαφορετικά μηνύματα σφαλμάτων μέσω σημείων πρόσβασης του API. Για παράδειγμα, η `AlreadyExistsStudentException` μπορεί να επικοινωνείται ως `Conflict` ή `409` σε επίπεδο ελεγκτή API - αυτό διαφέρει από μια άλλη εξαίρεση επικύρωσης εξαρτημένης από μια αναφορά μη έγκυρου φοιτητή όπως η `InvalidStudentReferenceException` που θα επικοινωνείτο ως σφάλμα `FailedDependency` ή `424`.

- Κανόνας 2: Εάν μια εξαίρεση επικύρωσης εξαρτημένης από μια εξαίρεση μη εξάρτησης χειρίζεται μια εξαίρεση, πρέπει να λάβει αυτήν την εξαίρεση ως εσωτερική εξαίρεση και όχι οτιδήποτε άλλο.

Αυτοί οι κανόνες εξασφαλίζουν ότι μόνο η τοπική εξαίρεση επικύρωσης είναι αυτή που διαδίδεται, όχι η εξαίρεση από το εξωτερικό σύστημα αποθήκευσης, ένα API ή οποιαδήποτε άλλη εξωτερική εξάρτηση.

Αυτό ισχύει για την περίπτωση που έχουμε εδώ με την `AlreadyExistsStudentException` και την `StudentDependencyValidationException` - η πρωτότυπη εξαίρεση αποκρύπτεται εντελώς από το μάτι, και η αντιστοίχιση της πρωτότυπης εξαίρεσης και του εσωτερικού της μηνύματος είναι αυτό που επικοινωνείται στον τελικό χρήστη. Αυτό δίνει στους μηχανικούς τη δυνατότητα να ελέγχουν τι επικοινωνείται από το άλλο άκρο του συστήματός τους, αντί να επιτρέπουν στο πρωτότυπο μήνυμα (το οποίο είναι υπόκεινται σε αλλαγές) να διαδίδεται στους τελικούς χρήστες.

##### 2.1.3.0.5.1 Υλοποίηση Εξαρτησιακών Επικυρώσεων

Ανάλογα με το πού προέρχεται το σφάλμα επικύρωσης, η υλοποίηση των εξαρτησιακών επικυρώσεων μπορεί να περιλαμβάνει ή όχι επιχειρηματική λογική. Όπως αναφέραμε προηγουμένως, αν το σφάλμα προέρχεται από το εξωτερικό πόρο (όπως στην περίπτωση αυτή) - τότε ό,τι έχουμε να κάνουμε είναι απλώς να τυλίξουμε αυτό το σφάλμα σε μια τοπική εξαίρεση και στη συνέχεια να το κατηγοριοποιήσουμε με μια εξωτερική εξαίρεση υπό εξάρτηση επικύρωσης.

Για να εξασφαλίσουμε ότι το προηγούμενο τεστ πέρασε, θα χρειαστούμε μερικά μοντέλα.
Η υλοποίηση της `AlreadyExistsStudentException` θα είναι ως εξής:

```csharp
public class AlreadyExistsStudentException : Exception
{
	public AlreadyExistsStudentException(Exception innerException)
		: base ("Student with the same Id already exists", innerException){ }

	public AlreadyExistsStudentException(string message, Exception innerException)
		: base (message, innerException) {}
}
```

Χρειαζόμαστε επίσης την `StudentDependencyValidationException` που θα πρέπει να είναι ως εξής:

```csharp
public class StudentDependencyValidationException : Exception
{
	public StudentDependencyValidationException(Exception innerException)
		: base("Student dependency validation error occurred, please try again.", innerException){ }

	public StudentDependencyValidationException(string message, Exception innerException)
		: base (message, innerException) {}
}

```

Now, let's go to the implementation side, let's start with the exception handling logic:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	...
	catch (DuplicateKeyException duplicateKeyException)
	{
		var alreadyExistsStudentException = 
			new AlreadyExistsStudentException(duplicateKeyException);

		throw CreateAndLogDependencyValidationException(alreadyExistsStudentException);
	}
}

...

private StudentDependencyValidationException CreateAndLogDependencyValidationException(Exception exception)
{
	var studentDependencyValidationException = 
		new StudentDependencyValidationException(exception);
	
	this.loggingBroker.LogError(studentDependencyValidationException);

	return studentDependencyValidationException;
}
```

Δημιουργήσαμε την τοπική εσωτερική εξαίρεση στο μπλοκ catch της διαδικασίας διαχείρισης των εξαιρέσεων μας για να επιτρέψουμε την επαναχρησιμοποίηση της μεθόδου εξαίρεσης επικύρωσης εξαρτημένης από την άλλη για άλλες καταστάσεις που απαιτούν το ίδιο επίπεδο εξωτερικών εξαιρέσεων.

Όλα τα υπόλοιπα παραμένουν ίδια για την αναφορά της μεθόδου `TryCatch` στο αρχείο `StudentService.cs`.

### 2.1.3.2 Aντιστοιχίες

Η δεύτερη ευθύνη μίας υπηρεσίας βάσης είναι να παίξει το ρόλο του μεταφραστή και να δημιουργήσει αντιστοιχίες προς και από τα τοπικά μοντέλα και τα μοντέλα που δεν είναι τοπικά. Για παράδειγμα, αν χρησιμοποιείτε μια υπηρεσία email που παρέχει τα δικά της SDKs για ενσωμάτωση, και οι μεσάζοντές σας ήδη περικλείουν και αποκαλύπτουν τα APIs για αυτήν την υπηρεσία, η υπηρεσία βάσης σας απαιτείται να δημιουργήσει αντιστοιχίες των εισόδων και εξόδων των μεθόδων των μεσαζόντων σε τοπικά μοντέλα. Η ίδια κατάσταση και συχνότερα συμβαίνει με τις ενσωματωμένες μη τοπικές εξαιρέσεις, όπως αυτές που αναφέραμε παραπάνω με την κατάσταση επικύρωσης των εξαρτήσεων, η ίδια πλευρά ισχύει για απλά σφάλματα εξαρτήσεων ή σφάλματα υπηρεσίας, όπως θα συζητήσουμε σύντομα.

#### 2.1.3.2.0 Μη Τοπικά Μοντέλα

Είναι πολύ συνηθισμένο για σύγχρονες εφαρμογές να απαιτούν ολοκλήρωση σε κάποιο σημείο με εξωτερικές υπηρεσίες. Αυτές οι υπηρεσίες μπορεί να είναι τοπικές στη συνολική αρχιτεκτονική ή τον κατανεμημένο σύστημα όπου βρίσκεται η εφαρμογή, ή μπορεί να είναι ένας πάροχος 3ης πλευράς, όπως μερικές από τις δημοφιλείς υπηρεσίες email, για παράδειγμα.

Οι πάροχοι εξωτερικών υπηρεσιών επενδύουν πολύ προσπάθεια στην ανάπτυξη ευφυών διεπαφών προγραμματισμού εφαρμογών (API), οδηγιών χρήσης (SDKs) και βιβλιοθηκών σε κάθε συνηθισμένη γλώσσα προγραμματισμού για να διευκολύνουν τους μηχανικούς να ενσωματώσουν τις εφαρμογές τους με αυτές τις υπηρεσίες 3ης πλευράς. Για παράδειγμα, ας υποθέσουμε ότι ένας πάροχος υπηρεσιών email 3ης πλευράς προσφέρει τον ακόλουθο API μέσω των SDKs του:

```csharp
public interface IEmailServiceProvider
{
	ValueTask<EmailMessage> SendEmailAsync(EmailMessage message);
}
```

Ας θεωρήσουμε ότι το μοντέλο `EmailMessage` είναι ένα ενσωματωμένο μοντέλο, που παρέχεται μέσω του SDK του πάροχου υπηρεσιών email. Οι μεσάζοντες σας μπορεί να προσφέρουν μια επένδυση γύρω από αυτό το API, δημιουργώντας ένα συμβόλαιο για να αφαιρέσουν τη λειτουργικότητα αλλά δεν μπορούν να κάνουν πολλά με τα ενσωματωμένα μοντέλα που περνάνε μέσα ή επιστρέφονται από αυτήν τη λειτουργικότητα. Έτσι, το διασύνδεσμός τους θα μοιάζει με κάτι τέτοιο:

```csharp
public interface IEmailBroker
{
	ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message);
}
```

Η υλοποίηση θα μοιάζει κάπως έτσι:

```csharp
public class EmailBroker : IEmailBroker
{
	public async ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message) =>
		await this.emailServiceProvider.SendEmailAsync(message);
}
```

Όπως είχαμε πει προηγουμένως, οι μεσίτες εδώ έχουν κάνει το μέρος τους από την αφαίρεση της πραγματικής υλοποίησης και των εξαρτήσεων του native `EmailServiceProvider` από τις υπηρεσίες των βασικών μας. Αλλά αυτό είναι μόνο το 50% της δουλειάς, η αφαίρεση δεν είναι ακόμα πλήρως ολοκληρωμένη μέχρι να μην υπάρχουν ίχνη του native μοντέλου `EmailMessage`. Εδώ είναι όπου οι βασικές υπηρεσίες εισέρχονται για να κάνουν μια λειτουργία δοκιμής οδήγησης της αντιστοίχισης μεταξύ των native μη τοπικών μοντέλων και των τοπικών μοντέλων της εφαρμογής σας. Για αυτό είναι πολύ πιθανό να δούμε μια συνάρτηση αντιστοίχισης σε μια υπηρεσία βάσης για να αφαιρέσουμε το native μοντέλο από το υπόλοιπο των υπηρεσιών του επιχειρησιακού επιπέδου σας.

Η υπηρεσία βάσης σας θα πρέπει στη συνέχεια να υποστηρίξει ένα νέο τοπικό μοντέλο, ας το αποκαλέσουμε `Email`. Το μοντέλο σας μπορεί να είναι ίδιο με το εξωτερικό μοντέλο `EmailMessage` - ειδικά σε επίπεδο αρχαίων τύπων δεδομένων. Αλλά το νέο μοντέλο θα είναι το μοναδικό συμβόλαιο ανάμεσα στο καθαρά επιχειρηματικό λογικό επίπεδο σας (υπηρεσίες επεξεργασίας, διορχήσεων, συντονισμού και διαχείρισης) και το λογικό υβριδικό επίπεδο όπως οι υπηρεσίες βάσης. Εδώ υπάρχει ένα απόσπασμα κώδικα για αυτήν τη λειτουργία:

```csharp
public async ValueTask<Email> SendEmailMessageAsync(Email email)
{
	EmailMessage inputEmailMessage = MapToEmailMessage(email);
	EmailMessage sentEmailMessage = await this.emailBroker.SendEmailMessageAsync(inputEmailMessage);

	return MapToEmail(sentEmailMessage);
}

```

Εξαρτώντας από το εάν το επιστρεφόμενο μήνυμα έχει μία κατάσταση ή αν θα θέλατε να επιστρέψετε το μήνυμα εισόδου ως ένδειξη μιας επιτυχούς λειτουργίας, και οι δύο πρακτικές είναι έγκυρες στο πρότυπό μου. Όλα εξαρτώνται από το τι έχει νόημα για τη λειτουργία που προσπαθείτε να εκτελέσετε. Το απόσπασμα κώδικα παραπάνω είναι ένα ιδανικό σενάριο όπου ο κώδικάς σας θα προσπαθήσει να παραμείνει πιστός στην τιμή που περάστηκε καθώς και στην τιμή που επιστράφηκε με όλες τις απαραίτητες αντιστοιχίσεις περιλαμβανομένων.

#### 2.1.3.2.1 Αντιστοιχίσεις Εξαιρέσεων

Όπως και με τα μη τοπικά μοντέλα, οι εξαιρέσεις που προέρχονται είτε από το εξωτερικό API όπως τα μοντέλα EntityFramework `DbUpdateException`, είτε από άλλα, πρέπει να αντιστοιχιστούν σε τοπικά μοντέλα εξαιρέσεων. Η διαχείριση αυτών των μη τοπικών εξαιρέσεων τόσο νωρίς πριν εισέλθουν στα συστατικά του καθαρά επιχειρηματικού επιπέδου θα αποτρέψει οποιαδήποτε πιθανή σφιχτή σύνδεση ή εξάρτηση από κάποιο εξωτερικό μοντέλο. Καθώς μπορεί να είναι πολύ συνηθισμένο, οι εξαιρέσεις να διαχειρίζονται διαφορετικά ανάλογα με τον τύπο της εξαίρεσης και τον τρόπο που θέλουμε να αντιμετωπίσουμε εσωτερικά στο σύστημα.

Για παράδειγμα, εάν προσπαθούμε να χειριστούμε μια `UserNotFoundException` που εκτοξεύεται από τη χρήση του Microsoft Graph, ενδέχεται να μην θέλουμε απαραίτητα να διακόψουμε ολόκληρη τη διαδικασία. Μπορεί να θέλουμε να συνεχίσουμε προσθέτοντας έναν χρήστη σε κάποιο άλλο αποθηκευτικό μέσο για μελλοντική επεξεργασία υποβολής στο Graph.

Τα εξωτερικά API δεν θα πρέπει να επηρεάζουν το εάν η εσωτερική λειτουργία σας θα πρέπει να διακοπεί ή όχι. Επομένως, η διαχείριση των εξαιρέσεων στο επίπεδο του βάσης είναι η εγγύηση ότι αυτή η επίδραση περιορίζεται στα όρια της περιοχής διαχείρισης των εξωτερικών πόρων της εφαρμογής μας και δεν έχει καμία επίδραση στις κύριες επιχειρησιακές διαδικασίες μας.

Η παρακάτω εικόνα θα πρέπει να διασαφηνίσει λίγο περισσότερο αυτή την οπτική:
<br />

<p align=center>
<img src="https://user-images.githubusercontent.com/1453985/112714067-b7366a00-8e95-11eb-9bb7-a5a047640f4a.png" />
</p>
<br />

Εδώ υπάρχουν μερικά κοινά σενάρια για την αντιστοίχιση εξαιρέσεων που προέρχονται από τοπικές ή εσωτερικές εξαιρέσεις σε εξωτερικές εξαιρέσεις:

| Exception                             | Wrap Inner Exception With        | Wrap With                            | Log Level |
| ------------------------------------- | -------------------------------- | ------------------------------------ | --------- |
| NullStudentException                  | -                                | StudentValidationException           | Error     |
| InvalidStudentException               | -                                | StudentValidationException           | Error     |
| SqlException                          | FailedStudentStorageException    | StudentDependencyException           | Critical  |
| HttpResponseUrlNotFoundException      | FailedStudentApiException        | StudentDependencyException           | Critical  |
| HttpResponseUnauthorizedException     | FailedStudentApiException        | StudentDependencyException           | Critical  |
| NotFoundStudentException              | -                                | StudentValidationException           | Error     |
| HttpResponseNotFoundException         | NotFoundStudentException         | StudentDependencyValidationException | Error     |
| DuplicateKeyException                 | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| HttpResponseConflictException         | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| ForeignKeyConstraintConflictException | InvalidStudentReferenceException | StudentDependencyValidationException | Error     |
| DbUpdateConcurrencyException          | LockedStudentException           | StudentDependencyValidationException | Error     |
| DbUpdateException                     | FailedStudentStorageException    | StudentDependencyException           | Error     |
| HttpResponseException                 | FailedStudentApiException        | StudentDependencyException           | Error     |
| Exception                             | FailedStudentServiceException    | StudentServiceException              | Error     |

[*] [Standardizing Validations & Exceptions](https://www.youtube.com/watch?v=Wtpxb7yPQP0)

[*] [Test-Driving Non-Circuit-Breaking Validations](https://www.youtube.com/watch?v=guJPrIQ0kJk)
