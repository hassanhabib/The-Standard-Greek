# 2 Υπηρεσίες

## 2.0 Εισαγωγή

Οι υπηρεσίες, γενικώς, είναι οι δοχεία της επιχειρηματικής λογικής σε οποιοδήποτε δεδομένο λογισμικό - είναι το κύριο συστατικό κάθε συστήματος και ο βασικός παράγοντας που καθιστά ένα σύστημα διαφορετικό από ένα άλλο.

Ο κύριος μας στόχος με τις υπηρεσίες είναι να τις κρατήσουμε ανεξάρτητες από συγκεκριμένες τεχνολογίες ή εξωτερικές εξαρτήσεις.

Κάθε στρώμα επιχειρηματικής λογικής είναι πιο συμβατό με το Πρότυπο αν μπορεί να συνδεθεί με οποιεσδήποτε άλλες εξαρτήσεις και τεχνολογίες εκθέσεως με το ελάχιστο δυνατόν κόπο ενσωμάτωσης.

### 2.0.0 Λειτουργίες Υπηρεσιών

Όταν μιλάμε για επιχειρηματική λογική, αναφερόμαστε κυρίως σε τρεις βασικές κατηγορίες λειτουργιών: επικύρωση, επεξεργασία και ενσωμάτωση.

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100530065-4494d680-31a2-11eb-8393-32b21ab99a3d.png" />
</p>
<br />

Ας μιλήσουμε για αυτές τις κατηγορίες.

#### 2.0.0.0 Επικυρώσεις (Validations)
Οι επικυρώσεις διασφαλίζουν ότι τα εισερχόμενα ή εξερχόμενα δεδομένα ταιριάζουν με ένα συγκεκριμένο σύνολο κανόνων: δομικές, λογικές ή εξωτερικές επικυρώσεις, με ακριβή αυτή τη σειρά προτεραιότητας. Θα επεκταθούμε σε λεπτομέρειες σχετικά με αυτό στις επερχόμενες ενότητες.

#### 2.0.0.1 Επεξεργασία (Processing)

Η επεξεργασία επικεντρώνεται κυρίως στον έλεγχο της ροής, τον χαρτογραφισμό και τον υπολογισμό για να ικανοποιηθεί μια επιχειρηματική ανάγκη - οι λειτουργίες επεξεργασίας διακρίνουν μια υπηρεσία από μια άλλη και, γενικά, ένα λογισμικό από ένα άλλο.

#### 2.0.0.2 Ενσωμάτωση (Integration)

Τέλος, η διαδικασία ενσωμάτωσης επικεντρώνεται στην ανάκτηση ή αποστολή δεδομένων από ή προς οποιοδήποτε ενσωματωμένο σύστημα εξαρτήσεων.

Θα συζητήσουμε αυτές τις πτυχές λεπτομερώς στο επερχόμενο κεφάλαιο. Το κύριο πράγμα που πρέπει να κατανοήσουμε για τις υπηρεσίες είναι ότι ο σχεδιασμός πρέπει να είναι ευέλικτος και δυναμικός για να ενσωματώνεται εύκολα με οποιαδήποτε τεχνολογία από την άποψη των εξαρτήσεων και να είναι εύκολο να ενσωματωθεί σε οποιαδήποτε λειτουργικότητα έκθεσης από την προοπτική μιας διεπαφής προγραμματισμού εφαρμογών (API).

### 2.0.1 Τύποι Υπηρεσιών (Service types)

Οι υπηρεσίες έχουν διάφορους τύπους βάσει της διάταξής τους σε οποιαδήποτε δομή αρχιτεκτονικής. Πέφτουν κάτω από τρεις κύριες κατηγορίες: επικυρωτές, ορχηστρωτές και συγκεντρωτές.

<br />
<p align=center>
 <img src="https://user-images.githubusercontent.com/1453985/100529444-b23e0400-319c-11eb-816a-59c73154542b.png" />
</p>
<br />

#### 2.0.1.0 Επικυρωτές (Validators)

Οι υπηρεσίες επικύρωσης είναι κυρίως υπηρεσίες γειτονικές στον μεσίτη ή υπηρεσίες βάσης.

Η κύρια ευθύνη αυτών των υπηρεσιών είναι να προσθέτουν ένα επίπεδο επικύρωσης πάνω από τις υπάρχουσες πρωταρχικές λειτουργίες, όπως οι λειτουργίες CRUD, για να διασφαλίσουν ότι τα εισερχόμενα και εξερχόμενα δεδομένα επικυρώνονται δομικά, λογικά και εξωτερικά προτού αποσταλούν τα δεδομένα εντός ή εκτός του συστήματος.

#### 2.0.1.1 Ενορχηστρωτές

Οι υπηρεσίες ορχηστρατές είναι το πυρήνα του επιχειρηματικού λογικού στρώματος. Μπορούν να είναι επεξεργαστές, ορχηστρατές, συντονιστές ή υπηρεσίες διαχείρισης, ανάλογα με τον τύπο των εξαρτήσεών τους.

Οι υπηρεσίες ορχηστρατές επικεντρώνονται κυρίως στο να συνδυάζουν πολλές πρωταρχικές λειτουργίες ή πολλαπλές λειτουργίες υψηλής τάξης επιχειρηματικής λογικής για να επιτύχουν ένα ακόμα υψηλότερο στόχο.

Οι υπηρεσίες ορχηστρατές είναι οι λήψεις αποφάσεων εντός οποιασδήποτε αρχιτεκτονικής, οι κυβερνητές του ρυθμού στο εσωτερικό κάθε συστήματος και το κύριο συστατικό που καθιστά μία εφαρμογή ή λογισμικό διαφορετικό από το άλλο.

Σκοπίμως σχεδιάζουμε τις υπηρεσίες ορχηστρατές να έχουν μεγαλύτερη διάρκεια ζωής από κάθε άλλο τύπο υπηρεσίας στο σύστημα.

#### 2.0.1.2 Συγκεντρωτές (Aggregators)

Ο κύριος ρόλος των υπηρεσιών συγκεντρωτών είναι να συνδέουν το αποτέλεσμα πολλαπλών υπηρεσιών επεξεργασίας, ορχηστρώσεως, συντονισμού ή διαχείρισης για να αποκαλύψουν μία μοναδική διεπαφή προγραμματισμού εφαρμογών (API) για οποιονδήποτε ελεγκτή API ή στοιχείο διεπαφής χρήστη να αλληλεπιδρά με το υπόλοιπο σύστημα.

Οι συγκεντρωτές είναι οι φρουροί του επιχειρηματικού λογικού στρώματος. Βεβαιώνουν ότι τα στοιχεία εκθέσεως δεδομένων (όπως οι ελεγκτές API) αλληλεπιδρούν μόνο με ένα μόνο σημείο επαφής για να αλληλεπιδρούν με το υπόλοιπο σύστημα.

Οι συγκεντρωτές, γενικά, δεν ενδιαφέρονται για τη σειρά με την οποία καλούνται οι λειτουργίες που είναι συνδεδεμένες με αυτούς. Ωστόσο, ορισμένες φορές είναι απαραίτητο να εκτελεστεί μια συγκεκριμένη λειτουργία, όπως η δημιουργία ενός αρχείου φοιτητή πριν από την ανάθεση ενός διαβατηρίου βιβλιοθήκης.

Στα ακόλουθα κεφάλαια, θα συζητήσουμε κάθε τύπο αυτών των υπηρεσιών.

### 2.0.2 Συνολικοί Κανόνες

Πολλοί κανόνες διέπουν τη συνολική αρχιτεκτονική και σχεδιασμό των υπηρεσιών σε οποιοδήποτε σύστημα.

Αυτοί οι κανόνες εξασφαλίζουν την συνολική αναγνωσιμότητα, συντηρησιμότητα και δυνατότητα παραμετροποίησης του συστήματος - με αυτήν τη συγκεκριμένη σειρά.

#### 2.0.2.0 Κάνε ή Ανάθεσε (Do or Delegate)

Κάθε υπηρεσία πρέπει είτε να κάνει είτε να αναθέτει το έργο αλλά όχι και τα δύο.

Για παράδειγμα, μια υπηρεσία επεξεργασίας πρέπει να αναθέτει το έργο της αποθήκευσης δεδομένων σε μια υπηρεσία θεμελίωσης και να μην προσπαθεί να κάνει αυτό το έργο μόνη της.

#### 2.0.2.1 Πρότυπο Two-Three (Πρότυπο Florance)

Για τις υπηρεσίες ενορχήστρωσης, οι εξαρτήσεις τους από υπηρεσίες (όχι μεσίτες) θα πρέπει να περιορίζονται σε δύο ή τρεις, αλλά όχι σε μία ή σε τέσσερις ή περισσότερες.

Αν ένας ενορχηστρωτής εξαρτάται μόνο από μία υπηρεσία, τότε παραβιάζει τον ορισμό της ορχήστρας, η οποία είναι η συνδυασμός πολλαπλών λειτουργιών από διαφορετικές πηγές για την επίτευξη μιας υψηλότερης τάξης επιχειρηματικής λογικής.

###### Αυτό το πρότυπο παραβιάζει το Πρότυπο Florance

<br/>
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561648-4926c100-326e-11eb-9028-96bcd3eb0b1d.png">
</p>
<br />

###### Αυτό το πρότυπο ακολουθεί τη συμμετρία του Προτύπου Florance

<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/100561978-2a74fa00-326f-11eb-9d05-404eed3eaf5f.png">
</p>
<br />

Το πρότυπο Florance εξασφαλίζει επίσης την ισορροπία και τη συμμετρία της συνολικής αρχιτεκτονικής.

Για παράδειγμα, δεν μπορείτε να ορχηστρώσετε μεταξύ μιας υπηρεσίας θεμελίωσης και μιας υπηρεσίας επεξεργασίας. Αυτό προκαλεί μια μορφή ανισορροπίας στην αρχιτεκτονική σας και δυσκολία όταν προσπαθείτε να συνδυάσετε μια ενιαία δήλωση με τη γλώσσα που κάθε υπηρεσία μιλά βάσει του επιπέδου και του τύπου της.

Οι συγκεντρωτές είναι οι μοναδικοί τύποι υπηρεσιών που επιτρέπεται να παραβιάζουν αυτόν τον κανόνα, όπου ο συνδυασμός και η σειρά των υπηρεσιών ή των κλήσεών τους δεν έχουν πραγματικές επιπτώσεις.

Θα συζητήσουμε λεπτομερώς το πρότυπο Florance στις επερχόμενες ενότητες του Προτύπου.

#### 2.0.2.2 Μοναδικό Σημείο Έκθεσης (Single Exposure Point)

Οι ελεγκτές API, τα στοιχεία διεπαφής χρήστη (UI) ή οποιαδήποτε άλλη μορφή έκθεσης δεδομένων από το σύστημα θα πρέπει να έχουν ένα μόνο σημείο επαφής με το επίπεδο επιχειρηματικής λογικής.

Για παράδειγμα, ένα άκρο API που προσφέρει άκρα για την διατήρηση και ανάκτηση δεδομένων φοιτητών δεν θα πρέπει να έχει πολλαπλές ενσωματώσεις με πολλαπλές υπηρεσίες, αλλά μάλλον μία υπηρεσία που παρέχει όλες αυτές τις δυνατότητες.

Μερικές φορές, μια μόνη ορχήστρωση, συντονισμός ή υπηρεσία διαχείρισης δεν προσφέρει όλα τα σχετικά με ένα συγκεκριμένο στοιχείο. Μια υπηρεσία συγκεντρωτής συνδυάζει όλες αυτές τις δυνατότητες σε μια υπηρεσία έτοιμη για ένταξη με μια τεχνολογία έκθεσης.

#### 2.0.2.3 Ίδιο ή Πρωτεϊκό Μοντέλο Εισόδου/Εξόδου

Όλες οι υπηρεσίες πρέπει να διατηρούν ένα μόνο συμβόλαιο όσον αφορά τους τύπους της επιστροφής και της εισόδου, εκτός αν πρόκειται για πρωτεϊκά δεδομένα.

Για παράδειγμα, μια υπηρεσία που παρέχει λειτουργίες για έναν τύπο οντότητας`Student` - δεν θα πρέπει να επιστρέφει από κανένα από τα μεθόδους της τα δεδομένα από άλλον τύπο οντότητας.

Μπορείτε να επιστρέψετε μια συγκέντρωση της ίδιας οντότητας, είτε πρόκειται για προσαρμοσμένη ή ενσωματωμένη όπως τα μοντέλα `List<Student>` or `AggregatedStudents`, είτε για πρωτεϊκού τύπου, όπως η ανάκτηση του αριθμού των φοιτητών, ή ένα λογικό (boolean) που υποδεικνύει αν υπάρχει φοιτητής ή όχι, αλλά όχι κανένα άλλο μη πρωτεϊκό ή μη συγκεντρωτικό συμβόλαιο.

Ένας παρομοίος κανόνας ισχύει και για τις παραμέτρους εισόδου - κάθε υπηρεσία μπορεί να λαμβάνει μια παράμετρο εισόδου με το ίδιο συμβόλαιο, ένα εικονικό συμβόλαιο συγκέντρωσης ή έναν πρωτεϊκό τύπο, αλλά όχι κανένα άλλο συμβόλαιο.

Αυτός ο κανόνας επικεντρώνει την ευθύνη μιας υπηρεσίας σε μια μόνο οντότητα και όλες τις σχετικές λειτουργίες της.

Όταν μια υπηρεσία επιστρέφει ένα διαφορετικό συμβόλαιο, παραβιάζει τον κανόνα της ονοματολογίας της, όπως μια StudentOrchestrationService που επιστρέφει List<Teacher> - και αρχίζει να πέφτει στην παγίδα να καλείται από άλλες υπηρεσίες από εντελώς διαφορετικά αγωγά δεδομένων.

Για πρωτεϊκές παραμέτρους εισόδου, αν ανήκουν σε μοντέλο οντότητας που δεν είναι απαραίτητα μια αναφορά στην κύρια οντότητα, ανακύπτει το ερώτημα του πώς να οργανώσουμε μια ορχήστρωση μεταξύ δύο υπηρεσιών επεξεργασίας ή θεμελίωσης για τη διατήρηση ενός ενοποιημένου μοντέλου χωρίς να παραβιάσουμε τον κανόνα της αγνής σύμβασης.

Υποθέτοντας ότι απαιτείται ο συνδυασμός πολλαπλών διαφορετικών συμβολαίων σε μια υπηρεσία ορχήστρωσης. Σε αυτήν την περίπτωση, ένα νέο ενοποιημένο εικονικό μοντέλο υποδεικνύει την ανάγκη για ένα νέο μοναδικό συμβόλαιο για την υπηρεσία ορχήστρωσης, με αντιστοιχίες που υλοποιούνται κάτω από το συγκεκριμένο επίπεδο αυτής της υπηρεσίας για να διατηρηθεί η συμβατότητα και η ασφάλεια της ένταξης.

#### 2.0.2.4 Κάθε Υπηρεσία για τον Εαυτό της

Κάθε υπηρεσία είναι υπεύθυνη για τον έλεγχο των εισόδων και εξόδων της. Μην εξαρτάστε από τις υπηρεσίες προς τα πάνω ή προς τα κάτω για να επικυρώσουν τα δεδομένα σας.

Αυτό είναι ένας μηχανισμός άμυνας προγραμματισμού για να διασφαλίσει ότι σε περίπτωση αντικατάστασης υλοποιήσεων πίσω από τις συμβάσεις, η ευθύνη οποιαδήποτε δοθείσας υπηρεσίας δεν θα επηρεαστεί εάν οι υπηρεσίες προς τα κάτω ή προς τα πάνω αποφασίσουν να προσπεράσουν τις επικυρώσεις τους για οποιοδήποτε λόγο.

Εντός οποιουδήποτε μονολιθικού, μικρουπηρεσιακού ή βασισμένου σε αρχιτεκτονική serverless συστήματος, κάθε υπηρεσία σχεδιάζεται έτσι ώστε να μπορεί να αποσπαστεί από το σύστημα σε κάποιο σημείο και να γίνει το τελευταίο σημείο επαφής πριν την ένταξη με κάποιον εξωτερικό διαχειριστή πόρων.

Για παράδειγμα, στην ακόλουθη αρχιτεκτονική, οι υπηρεσίες αντιστοιχίζουν μέρη ενός μοντέλου Student εισόδου σε ένα μοντέλο LibraryCard. Εδώ υπάρχει μια εικόνα των μοντέλων:

###### Student

```csharp
public class Student
{
    public Guid Id {get; set;}
    public string Name {get; set;}
}
```

###### LibraryCard

```csharp
public class LibraryCard
{
    public Guid Id {get; set;}
    public Guid StudentId {get; set;}
}
```
Τώρα, ας υποθέσουμε ότι η υπηρεσία ορχήστρωσης μας, η StudentOrchestrationService, εξασφαλίζει ότι κάθε νέος φοιτητής που εγγράφεται θα πρέπει να έχει μια βιβλιοθήκη κάρτα, έτσι η λογική μας μπορεί να φαίνεται ως εξής:

```csharp
public async ValueTask<Student> RegisterStudentAsync(Student student)
{
    Student registeredStudent =
        await this.studentProcessingService.RegisterStudentAsync(student);

    await AssignStudentLibraryCardAsync(student);

    return registeredStudent;
}

private async ValueTask<LibraryCard> AssignStudentLibraryCardAsync(Student student)
{
    LibraryCard studentLibraryCard = MapToLibraryCard(student);

    return await this.libraryCardProcessingService.AddLibraryCardAsync(studentLibraryCard);
}

private LibraryCard MapToLibraryCard(Student student)
{
    return new LibraryCard
    {
        Id = Guid.NewGuid(),
        StudentId = student.Id
    };
}
```

Όπως μπορείτε να δείτε παραπάνω, απαιτείται ένα έγκυρο αναγνωριστικό φοιτητή για να διασφαλιστεί μια επιτυχημένη αντιστοίχιση με μια `LibraryCard` - και αφού η αντιστοίχιση είναι υπεύθυνότητα του ορχηστρωτή, πρέπει να διασφαλίσουμε ότι ο εισαγόμενος φοιτητής και το αναγνωριστικό του είναι σε καλή κατάσταση πριν προχωρήσουμε στη διαδικασία της ορχήστρωσης.

#### 2.0.2.5 Ροή Μπροστά (Flow Forward)

Οι υπηρεσίες δεν μπορούν να καλούν υπηρεσίες στο ίδιο επίπεδο. Για παράδειγμα, οι Υπηρεσίες Θεμελίωσης δεν μπορούν να καλούν άλλες Υπηρεσίες Θεμελίωσης, και οι Υπηρεσίες Ορχήστρωσης δεν μπορούν να καλούν άλλες Υπηρεσίες Ορχήστρωσης από το ίδιο επίπεδο.
Αυτή η αρχή ονομάζεται Ροή-Μπροστά - όπως δείχνει η εικόνα:


<br />
<p align=center>
    <img src="https://user-images.githubusercontent.com/1453985/236656309-30864ae2-860c-4a90-9bf5-db145a072e1b.png">
</p>
<br />

##### 2.0.2.5.0 Για τις Διεπαφές Προγραμματισμού (APIs)
Λόγω της διακριτικότητας, η ίδια αρχή ισχύει και για τις μεθόδους εντός αυτών των υπηρεσιών. Δημόσιες διεπαφές προγραμματισμού δεν μπορούν να καλούν όλες τις δημόσιες διεπαφές προγραμματισμού. Εδώ έχουμε ένα παράδειγμα:

```csharp
public async ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId)
{
    ...

    return await this.storageBroker.SelectStudentByIdAsync(studentId);
}

public async ValueTask<Student> ModifyStudentAsync(Student student)
{
    ...

    Student maybeStudent = 
        await this.storageBroker.SelectStudentByIdAsync(studentId);
    
    ...
    ...
}
```
Στο παράδειγμα της Υπηρεσίας Θεμελίωσης που παρουσιάστηκε παραπάνω, δεν μπορούμε να καλέσουμε τη μέθοδο `RetriveStudentByIdAsync` σε μια public μέθοδο από μια άλλη `public` μέθοδο, όπως την `ModifyStudentAsync`. Θα διαπιστώσετε ότι και οι δύο μέθοδοι κάλεσαν ακριβώς την ίδια μέθοδο από μια χαμηλότερη εξάρτηση, όπως ένα `StorageBroker`, πλήρως ανεξάρτητες μεταξύ τους.

Αν και αυτό μπορεί να φαίνεται επαναληπτικό, ο λόγος για αυτό είναι ότι οι public διεπαφές προγραμματισμού, συμβάσεις ή άλλως, προορίζονται να αποσυρθούν κάποια στιγμή στη διάρκεια του κύκλου ζωής τους. Επίσης, μπορεί να αλλάξουν πλήρως από άποψη υλοποίησης. Αν μια public διεπαφή προγραμματισμού εξαρτιόταν από μια άλλη public διεπαφή προγραμματισμού στο ίδιο επίπεδο, η απόσυρση της μιας θα προκαλέσει ένα κατακρημνιστικό αποτέλεσμα σε όλες τις υπόλοιπες. Αυτό είναι ένα σύμπτωμα του χαοτικού σχεδιασμού, το οποίο το Πρότυπο απαγορεύει απερίφραστα.
