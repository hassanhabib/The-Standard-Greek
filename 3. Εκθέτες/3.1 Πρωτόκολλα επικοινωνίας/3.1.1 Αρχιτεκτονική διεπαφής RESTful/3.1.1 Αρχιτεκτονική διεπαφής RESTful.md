# 3.1.1 RESTful APIs

## 3.1.1.0 Εισαγωγή
Οι ελεγκτές RESTful API λειτουργούν ως διαμεσολαβητές μεταξύ του πυρήνα της επιχειρηματικής λογικής και του εξωτερικού κόσμου. Βρίσκονται στην άλλη πλευρά της πυραμίδας της επιχειρηματικής πραγματικότητας οποιασδήποτε εφαρμογής. Κατά κάποιο τρόπο, οι ελεγκτές API είναι παρόμοιοι με τους Διαμεσολαβητές. Εξασφαλίζουν μια επιτυχημένη ενσωμάτωση μεταξύ της πυρήνας μας λογικής και του υπόλοιπου κόσμου.

## 3.1.1.1 Στον Χάρτη
Οι ελεγκτές βρίσκονται στο όριο οποιουδήποτε συστήματος. Ανεξάρτητα από το αν αυτό το σύστημα είναι μια μονολιθική πλατφόρμα ή απλή μικρο-υπηρεσία. Οι ελεγκτές API ισχύουν ακόμη και για μικρότερα lambdas ή cloud functions. Λειτουργούν ως ενεργοποιητές για την πρόσβαση σε αυτούς τους πόρους σε οποιοδήποτε σύστημα μέσω REST.

<br />
    <div align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147741682-63434be5-3122-4484-b9a1-fd013f18b1b0.png" />
    </div>
<br />

Η πλευρά των καταναλωτών των ελεγκτών μπορεί να ποικίλει. Σε συστήματα παραγωγής, αυτοί οι καταναλωτές μπορεί να είναι άλλες υπηρεσίες που απαιτούν δεδομένα από ένα συγκεκριμένο σημείο του API. Μπορεί να είναι βιβλιοθήκες που έχουν χτιστεί ως περιτυλίγματα γύρω από τα API των ελεγκτών για να παρέχουν έναν τοπικό πόρο με εξωτερικά δεδομένα. Ωστόσο, οι καταναλωτές μπορεί επίσης να είναι απλά μηχανικοί που δοκιμάζουν τα endpoints, επικυρώνοντας τη συμπεριφορά τους μέσω των εγγράφων swagger.

## 3.1.1.2 Χαρακτηριστικά
Υπάρχουν αρκετοί κανόνες και αρχές που διέπουν την υλοποίηση των σημείων πρόσβασης των RESTful API. Ας συζητήσουμε αυτά εδώ.

### 3.1.1.2.0 Γλώσσα
Οι ελεγκτές χρησιμοποιούν διαφορετική γλώσσα όταν πρόκειται για την υλοποίηση των μεθόδων τους σε σύγκριση με τις υπηρεσίες και τους διαμεσολαβητές. Για παράδειγμα, εάν ένας διαμεσολαβητής που αλληλεπιδρά με μια αποθήκη χρησιμοποιεί μια γλώσσα όπως InsertStudentAsync, και η αντίστοιχη υλοποίηση της υπηρεσίας χρησιμοποιεί κάτι σαν AddStudentAsync, το αντίστοιχο για τον ελεγκτή θα είναι η χρήση της γλώσσας του RESTful όπως PostStudentAsync.

Υπάρχουν μόνο λίγοι όροι που θα χρησιμοποιούσε ένας ελεγκτής για να εκφράσει μια συγκεκριμένη λειτουργία. Ας σχεδιάσουμε τον χάρτη εδώ για καλύτερη κατανόηση:

| Controllers							| Services                      	| Brokers								    |
|------------------------				|---------------------------		| ------------------------------------------|
| Post          				        | Add                               | Insert                     			    |
| Get               				    | Retrieve               			| Select                       			    |
| Put               					| Modify                          	| Update                			        |
| Delete                          		| Remove                            | Delete                                	|

Η γλώσσα που μιλούν οι ελεγκτές ονομάζεται Http Verbs (ή αλλιώς HTTP μέθοδοι). Οι επιλογές τους είναι πιο ευρείες από τις προαναφερθείσες λειτουργίες CRUD. Για παράδειγμα, υπάρχει το PATCH, το οποίο επιτρέπει στους καταναλωτές του API να ενημερώνουν μόνο μέρη ενός συγκεκριμένου εγγράφου. Το PATCH χρησιμοποιείται σπάνια σήμερα, από την εμπειρία μου σε εφαρμογές παραγωγής. Ωστόσο, μπορεί να ειδικευθεί μια ειδική ενότητα γι' αυτές στις μελλοντικές εκδόσεις του The Standard.

#### 3.1.1.2.0.0 Πέρα από τις Καθιερωμένες Λειτουργίες CRUD
Όπως αναφέραμε προηγουμένως, ο ελεγκτής μπορεί να αλληλεπιδρά με περισσότερες από απλά μια υπηρεσία βάσης. Μπορεί να αλληλεπιδρά με λειτουργίες υψηλότερης τάξης της επιχειρηματικής λογικής. Για παράδειγμα, μια υπηρεσία επεξεργασίας μπορεί να προσφέρει μια ρουτίνα `Upsert`. Σε αυτή την περίπτωση, ένα τυπικό Http Verb δεν θα μπορούσε να ικανοποιήσει μια συνδυαστική ρουτίνα όπως το `Upsert`. Σε αυτή την περίπτωση, επιλύουμε στην αρχική κατάσταση του `Post`, υποθέτοντας ότι ο πόρος δεν υπάρχει.

Μπορεί να γίνει χρήσιμο να ειδοποιήσουμε τους καταναλωτές μας αν αποφασίσαμε να τροποποιήσουμε αντί να προσθέσουμε, ποια λειτουργία επιλέξαμε να ακολουθήσουμε. Ωστόσο, αυτό είναι μια υλοποίηση περίπτωση προς περίπτωση και, συχνότερα από ποτέ, οι καταναλωτές δεν ενδιαφέρονται να μάθουν αυτήν την πληροφορία. Η ίδια ιδέα ισχύει και για άλλες γλώσσες που μπορεί να χρησιμοποιούν μη-βασικές υπηρεσίες. Όπως το Process ή το Calculate ή οποιαδήποτε άλλη επιχειρηματική γλώσσα υψηλότερης τάξης που μπορεί να επιλέξουν προηγμένες υπηρεσίες.

#### 3.1.1.2.0.1 Similar Verbs
Μερικές φορές, ειδικά με τις βασικές λειτουργίες CRUD, θα χρειαστεί να χρησιμοποιήσετε το ίδιο Http ρήμα για να περιγράψετε δύο διαφορετικές διαδικασίες. Για παράδειγμα, η ολοκλήρωση με τόσο την RetrieveById όσο και την RetrieveAll αντιστοιχεί σε μια λειτουργία Get στον χώρο του RESTful. Σε αυτήν την περίπτωση, κάθε λειτουργία θα έχει διαφορετικό όνομα, διατηρώντας το ίδιο ρήμα ως εξής:

```csharp
[HttpGet]
public ActionResult<IQueryable<Student>> GetAllStudents()
{
    ...
}

[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    ...
}
```

Όπως βλέπετε παραπάνω, ο παράγοντας που διαφοροποιεί είναι τόσο το όνομα της συνάρτησης GetAllStudents έναντι GetStudentByIdAsync, όσο και η Route ταυτόχρονα. Θα συζητήσουμε τις διαδρομές σύντομα, αλλά το κύριο στοιχείο εδώ είναι η δυνατότητα να υλοποιούνται πολλαπλές διαδικασίες με διαφορετικά ονόματα, ακόμα και αν αντιστοιχούν στο ίδιο Http ρήμα.

#### 3.1.1.2.0.2 Συμβάσεις Διαδρομών
Οι ελεγκτές RESTful API είναι προσβάσιμοι μέσω διαδρομών (routes). Μια διαδρομή είναι απλά ένα URL που συνδυάζεται με ένα Http ρήμα, ώστε το σύστημα να γνωρίζει ποια διαδικασία πρέπει να καλέσει για να ταιριάξει με αυτήν τη διαδρομή. Για παράδειγμα, εάν θέλω να ανακτήσω έναν φοιτητή με το Id 123, τότε η διαδρομή του API θα ήταν ως εξής: api/students/123. Και εάν θέλω να ανακτήσω όλους τους φοιτητές σε κάποιο σύστημα, απλώς μπορώ να καλέσω το api/students με το ρήμα GET.

##### 3.1.1.2.0.2.0 Controller Routes
Η κλάση του ελεγκτή σε μια απλή εφαρμογή ASP.NET μπορεί να ρυθμιστεί απλά στην κορυφή της δήλωσης της κλάσης ελέγχου με μια διακόσμηση ως εξής:

```csharp
[ApiController]
[Route("api/[controller]")]
public class StudentsController
{
    ...
}
```

Η διαδρομή εκεί είναι ένα πρότυπο που ορίζει το σημείο πρόσβασης που ξεκινά με το api και ακολουθείται από την παράλειψη του όρου "Controller" από το όνομα της κλάσης. Έτσι, το StudentsController θα γίνει api/students. Είναι σημαντικό όλοι οι ελεγκτές να έχουν μια πληθυντική έκδοση της σύμβασης που εξυπηρετούν. Αντίθετα από τις υπηρεσίες όπου λέμε StudentService, οι ελεγκτές θα είναι η πληθυντική έκδοση με το StudentsController.

##### 3.1.1.2.0.2.1 Routine Routes
Η ίδια ιδέα ισχύει και για τις μεθόδους εντός της κλάσης ελεγκτή. Όπως βλέπουμε στο απόσπασμα κώδικα παραπάνω, έχουμε διακοσμήσει τη μέθοδο GetStudentByIdAsync με τη διακόσμηση HttpGet με μια συγκεκριμένη διαδρομή που προσδιορίζεται για να προστεθεί στη συνολική διαδρομή του ελεγκτή. Για παράδειγμα, αν η διαδρομή του ελεγκτή είναι api/students, μια διαδικασία με HttpGet("{studentId}") θα έχει ως αποτέλεσμα μια διαδρομή που φαίνεται ως εξής: api/students/{studentId}.

Το studentId τότε θα αντιστοιχιστεί ως μια μεταβλητή παραμέτρου εισόδου που πρέπει να ταιριάζει με τη μεταβλητή που έχει οριστεί στη διαδρομή, όπως φαίνεται παρακάτω:

```csharp
[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    ...
}
```

Αλλά μερικές φορές αυτές οι διαδρομές δεν είναι απλώς παράμετροι URL. Μερικές φορές περιέχουν ένα αίτημα μέσα σε αυτές. Για παράδειγμα, ας πούμε ότι θέλουμε να δημοσιεύσουμε μια βιβλιοθήκη κάρτα για ένα συγκεκριμένο αρχείο φοιτητή. Η διαδρομή μας θα φαίνεται κάπως έτσι: api/students/{studentId}/librarycards με ρήμα POST. Σε αυτή την περίπτωση πρέπει να κάνουμε διάκριση μεταξύ αυτών των δύο παραμέτρων εισόδου με την κατάλληλη ονομασία ως εξής:

```csharp
[HttpPost("{studentId}/librarycards")]
public async ValueTask<ActionResult<LibraryCard>> PostLibraryCardAsync(Guid studentId, LibraryCard libraryCard)
{
    ...
}
```

##### 3.1.1.2.0.2.2 Plural Singular Plural

Όταν ορίζετε διαδρομές σε μια RESTful API, είναι σημαντικό να ακολουθείτε τις γενικές συμβάσεις ονομασίας για αυτές τις διαδρομές. Ο γενικός κανόνας είναι να αποκτάτε πρόσβαση σε μια συλλογή πόρων, στη συνέχεια να επιλέγετε ένα συγκεκριμένο στοιχείο, στη συνέχεια να αποκτάτε πάλι πρόσβαση σε μια συλλογή πόρων εντός αυτού του στοιχείου και ούτω καθεξής. Για παράδειγμα, στο παραπάνω παράδειγμα με τις βιβλιοθήκες καρτών, μπορείτε να δείτε ότι ξεκινήσαμε από την πρόσβαση σε όλους τους φοιτητές, στη συνέχεια επιλέξαμε έναν συγκεκριμένο φοιτητή με ένα συγκεκριμένο αναγνωριστικό, στη συνέχεια θέλαμε να αποκτήσουμε πρόσβαση σε όλες τις κάρτες βιβλιοθήκης που συνδέονται με αυτόν το φοιτητή και στη συνέχεια να επιλέξουμε μια πολύ συγκεκριμένη κάρτα με αναφορά στο αναγνωριστικό της.

Αυτή η σύμβαση λειτουργεί τέλεια σε σχέσεις ενός-πολλών. Αλλά τι γίνεται με τις σχέσεις ένα-προς-ένα; Ας υποθέσουμε ότι ένας φοιτητής μπορεί να έχει μία και μόνο μία κάρτα βιβλιοθήκης ανά πάσα στιγμή. Σε αυτήν την περίπτωση, η διαδρομή μας θα εξακολουθούσε να μοιάζει κάπως έτσι: `api/students/{studentId}/librarycards` με ρήμα `POST`, και θα προκαλούσε σφάλμα `ΣΥΓΚΡΟΥΣΗ` (CONFLICT) αν μια κάρτα βρίσκεται ήδη σε εκκρεμότητα, ανεξάρτητα από το εάν τα αναγνωριστικά ταιριάζουν ή οχι.

##### 3.1.1.2.0.2.2 Query Parameters & OData
Ωστόσο, η διαδρομή που συστήνω είναι η διαδρομή με επίπεδο μοντέλο. Εκεί όπου κάθε πόρος ζει αυτόνομα με τις δικές του μοναδικές διαδρομές. Στην περίπτωσή μας, η ανάκτηση μιας κάρτας βιβλιοθήκης για έναν συγκεκριμένο φοιτητή θα ήταν ως εξής: `api/librarycards?studentId={studentId}` ή απλά χρησιμοποιώντας μια ελαφρώς πιο προηγμένη παγκόσμια τεχνολογία όπως το OData, όπου το ερώτημα θα ήταν απλά `api/librarycards?$filter=studentId eq '123'`.

Εδώ υπάρχει ένα παράδειγμα υλοποίησης βασικών παραμέτρων ερωτήματος:

```csharp
[HttpPost()]
public async ValueTask<ActionResult<LibraryCard>> PostLibraryCardAsync(Guid studentId, LibraryCard libraryCard)
{
    ...
}
```
Όσον αφορά στο OData, μια υλοποίηση θα ήταν η εξής:

```csharp
[HttGet]
[EnableQuery]
public async ValueTask<IQueryable<LibraryCard>> GetAllLibraryCards()
{
    ...
}
```

Η ίδια ιδέα ισχύει και για τη μέθοδο `POST` για ένα μοντέλο. Αντί να κάνουμε ανάρτηση προς: `api/students/{studentId}/librarycards` - μπορούμε να χρησιμοποιήσουμε το ίδιο το contract για να κάνουμε ανάρτηση στο `api/librarycards` με ένα μοντέλο που περιέχει το αναγνωριστικό του φοιτητή. Αυτή η ιδέα επίπεδης διαδρομής μπορεί να απλοποιήσει την υλοποίηση και να ευθυγραμμίσει τέλεια με τον συνολικό στόχο του The Standard. Τη διατήρηση των πραγμάτων απλά.

### 3.1.1.2.1 Codes & Responses
Οι απαντήσεις από έναν ελεγκτή API πρέπει να αντιστοιχίζονται σε κωδικούς και απαντήσεις. Για παράδειγμα, εάν προσπαθούμε να προσθέσουμε ένα νέο φοιτητή σε ένα σύστημα εκπαίδευσης, κάνουμε μια αίτηση `POST` για τον φοιτητή και λαμβάνουμε ως απάντηση το ίδιο σώμα που υποβάλλαμε με έναν κωδικό κατάστασης 201, που σημαίνει ότι η πόρος έχει δημιουργηθεί.

Υπάρχουν τρεις κύριες κατηγορίες όπου μπορούν να ενταχθούν οι απαντήσεις. Η πρώτη είναι η κατηγορία επιτυχίας. Εκεί όπου τόσο ο χρήστης όσο και ο διακομιστής έχουν κάνει το μέρος τους και η αίτηση έχει επιτύχει. Η δεύτερη κατηγορία είναι οι κωδικοί σφαλμάτων του χρήστη, όπου η αίτηση του χρήστη έχει κάποιο πρόβλημα. Σε αυτήν την περίπτωση, θα επιστραφεί ένας κωδικός `4xx` με λεπτομερές μήνυμα σφάλματος για να βοηθήσει τους χρήστες να διορθώσουν τις αιτήσεις τους ή να πραγματοποιήσουν μια επιτυχημένη λειτουργία. Η τρίτη περίπτωση είναι οι κωδικοί σφάλματος του συστήματος, όπου το σύστημα έχει αντιμετωπίσει κάποιο πρόβλημα, είτε εσωτερικά είτε εξωτερικά, και χρειάζεται να επιστρέψει έναν κωδικό `5xx` για να υποδείξει στον χρήστη ότι κάτι πήγε λάθος με το σύστημα και χρειάζεται να επικοινωνήσει με την υποστήριξη.

Ας μιλήσουμε λεπτομερέστερα για αυτούς τους κωδικούς και τις περιπτώσεις τους εδώ.

#### 3.1.1.2.1.0  Κωδικοί Επιτυχίας (2xx)
Οι κωδικοί επιτυχίας υποδεικνύουν ότι ένας πόρος έχει δημιουργηθεί, ενημερωθεί, διαγραφεί ή ανακτηθεί. Κατά κάποιες περιπτώσεις υποδεικνύουν ότι ένα αίτημα έχει υποβληθεί επιτυχώς με τρόπο ενδεχομένως συνεπείας, που μπορεί να επιτευχθεί ή όχι στο μέλλον. Εδώ παραθέτουμε τις λεπτομέρειες για κάθε περίπτωση:

| Code      							| Method                          	| Details								                            |
|---------------------------------------|-----------------------------------|-------------------------------------------------------------------|
| 200             				        | Ok                                | Used for successful GET, PUT and DELETE operations.               |
| 201               				    | Created               			| Used for successful POST operations                               |
| 202               					| Accepted                          | Used for request that was delegated but may or may not succeed    |


Here's some examples for each:

In a retrieve non-post scenario, it's more befitting to return an `Ok` status code as follows:

```csharp
[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    Student retrievedStudent = 
        await this.studentService.RetrieveStudentByIdAsync(studentId);

    return Ok(retrievedStudent);
}
```

But in a scenario where we have to create a resource, a `Created` is more befitting for this case as follows:

```csharp
[HttpPost)]
public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
{
    Student retrievedStudent = 
        await this.studentService.AddStudentAsync(student);

    return Created(student);
}
```

Σε περιπτώσεις ενδεχόμενης συνέπειας, όπου ένα πόρος που αναρτήθηκε δεν αποθηκεύεται ακόμα πραγματικά, ενημερώνουμε το αίτημα στην ουρά αναμονής και επιστρέφουμε έναν κατάσταση `Accepted` για να υποδείξουμε ότι θα ξεκινήσει ένα διαδικασία:
```csharp
[HttpPost)]
public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
{
    Student retrievedStudent = 
        await this.studentEventService.EnqueueStudentEventAsync(student);

    return Accepted(student);
}
```

Ο κανόνας του Προτύπου για περιπτώσεις ενδεχόμενης συνέπειας είναι να διασφαλιστεί ότι ο υποβάλλων έχει ένα διακριτικό στοιχείο τις περιστάσεις, ώστε οι αιτούντες μπορούν να ερευνήσουν την κατάσταση του αιτήματός τους με διαφορετική κλήση στην API. Θα συζητήσουμε αυτά τα μοτίβα σε ένα διαφορετικό βιβλίο που ονομάζεται "Η Πρότυπη Αρχιτεκτονική".


#### 3.1.1.2.1.1 Κωδικοί Σφαλμάτων Χρήστη (4xx)
Αυτή είναι η δεύτερη κατηγορία απαντήσεων της API. Εδώ υπάρχει ένα ζήτημα στο αίτημα του χρήστη και το σύστημα πρέπει να βοηθήσει τον χρήστη να κατανοήσει γιατί το αίτημά του δεν ήταν επιτυχημένο. Για παράδειγμα, υποθέστε ότι ένας πελάτης υποβάλλει έναν νέο φοιτητή σε ένα σύστημα εκπαίδευσης. Εάν το αναγνωριστικό του φοιτητή είναι μη έγκυρο, πρέπει να επιστραφεί ένας κωδικός `400` ή `Bad Request` με μια λεπτομερή εξήγηση που εξηγεί ακριβώς ποιο είναι το αίτιο για την αποτυχία του αιτήματος.

Οι ελεγκτές είναι υπεύθυνοι για την αντιστοίχιση των κατηγορικών εξαιρέσεων της πυρήνα σε κατάλληλους κωδικούς κατάστασης. Εδώ έχουμε ένα παράδειγμα:

```csharp
[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    try
    {
        ...
    }
    catch (StudentValidationException studentValidationException)
    {
        return BadRequest(studentValidationException.InnerException)
    }
}
```

Όπως φαίνεται σε αυτό το απόσπασμα κώδικα, πιάσαμε μια εξαίρεση κατηγορικής επικύρωσης και την αντιστοιχίσαμε σε έναν κωδικό σφάλματος `400` που είναι το `BadRequest`. Η πρόσβαση στην εσωτερική εξαίρεση εδώ γίνεται για να εξαγάγουμε λεπτομέρειες προβλήματος από την ιδιότητα `Data` στην εσωτερική εξαίρεση που περιέχει όλες τις τιμές του λεξικού της αναφοράς σφάλματος.

Ωστόσο, μερικές φορές οι ελεγκτές πρέπει να εξετάσουν πιο βαθιά. Πιάνοντας μια συγκεκριμένη τοπική εξαίρεση όχι μόνο την κατηγορική. Για παράδειγμα, ας πούμε ότι θέλουμε να διαχειριστούμε την `NotFoundStudentException` με έναν κωδικό σφάλματος `404` ή `NotFound`. Έτσι θα το επιτύχουμε:

```csharp
[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    try
    {
        ...
    }
    catch (StudentValidationException studentValidationException)
        (when studentValidationException.InnerException is NotFoundStudentException)
    {
        return NotFound(studentValidationException.InnerException)
    }
}
```

Στο απόσπασμα κώδικα παραπάνω, αναγκαστήκαμε να εξετάσουμε τον τύπο της εσωτερικής εξαίρεσης για να επικυρώσουμε την τοπική εξαίρεση από μέσα. Αυτό είναι το πλεονέκτημα της διαδικασίας αποσυντυπώσεως και συσκευασίας που συζητήσαμε στην ενότητα 2.3.3.0.2 του Προτύπου. Ο ελεγκτής μπορεί επίσης να εξετάσει πολλούς τύπους μέσα στο ίδιο μπλοκ όπως ακολούθως:

```csharp
    ...
    catch (StudentCoordinationDependencyValidationException studentCoordinationDependencyValidationException)
        (when studentValidationException.InnerException 
            is NotFoundStudentException
            or NotFoundLibraryCardException
            or NotFoundStudentContactException)
    {
        return NotFound(studentValidationException.InnerException)
    }
    ...
```

With that in mind, let's detail the most common mappings from exceptions to codes:

| Code      							| Method                          	| Exception								                            |
|---------------------------------------|-----------------------------------|-------------------------------------------------------------------|
| 400             				        | BadRequest                        | ValidationException or DependencyValidationException              |
| 404               				    | NotFound               			| NotFoundException                                                 |
| 409               					| Conflict                          | AlreadyExistException                                             |
| 423               					| Locked                            | LockedException                                                   |
| 424               					| FailedDependency                  | InvalidReferenceException                                         |

Υπάρχουν περισσότερα κωδικοί κατάστασης `4xx` εκεί έξω. Αλλά τη στιγμή αυτή μπορεί να παράγονται αυτόματα από το πλαίσιο του ιστό, όπως στο ASP.NET, ή δεν υπάρχουν ακόμα χρήσιμα σενάρια για αυτούς. Για παράδειγμα, ένα σφάλμα `401` ή `Unauthorized` μπορεί να παράγεται αυτόματα εάν το άκρο ελέγχου του ελεγχθεί με απαιτήσεις εξουσιοδότησης.

#### 3.1.1.2.1.2 Κωδικοί Σφαλμάτων Συστήματος (5xx)
Οι κωδικοί σφαλμάτων συστήματος είναι ο τρίτος και τελευταίος δυνατός τύπος κωδικών που μπορεί να συμβούν ή να επιστραφούν από ένα άκρο του API. Η βασική τους ευθύνη είναι να υποδεικνύουν γενικά ότι ο καταναλωτής του άκρου του API δεν φέρει ευθύνη. Κάτι κακό συνέβη στο σύστημα και η ομάδα μηχανικών πρέπει να εμπλακεί για να επιλύσει το ζήτημα. Γι' αυτό καταγράφουμε τις εξαιρέσεις μας με ένα επίπεδο σοβαρότητας στον πυρήνα της επιχειρησιακής λογικής, ώστε να γνωρίζουμε πόσο επείγουσα μπορεί να είναι η κατάσταση.

Ο πιο κοινός κωδικός http που μπορεί να επικοινωνηθεί για πρόβλημα στην πλευρά του διακομιστή είναι ο κωδικός `500` ή `InternalServerError`. Ας ρίξουμε μια ματιά σε ένα απόσπασμα κώδικα που αντιμετωπίζει αυτήν την κατάσταση:

```csharp
[HttpGet("{studentId}")]
public async ValueTask<ActionResult<Student>> GetStudentByIdAsync(Guid studentId)
{
    try
    {
        ...
    }
    ...
    catch (StudentDependencyException studentDependencyException)
    {
        return InternalServerError(studentValidationException)
    }
}
```

Στο ανωτέρω απόσπασμα αγνοήσαμε εντελώς την εσωτερική εξαίρεση και επικεντρωθήκαμε κυρίως στην κατηγορική εξαίρεση για λόγους ασφαλείας. Κυρίως για να μην επιτραπεί η έκθεση εσωτερικών πληροφοριών του διακομιστή σε μια απάντηση του API, εκτός από κάτι τόσο απλό όπως `Σφάλμα εξάρτησης, επικοινωνήστε με την υποστήριξη`. Δεδομένου ότι ο καταναλωτής του API απαιτείται να μην προβεί σε καμία ενέργεια παρά μόνο να δημιουργήσει ένα εισιτήριο για την ομάδα υποστήριξης.

Ιδανικά, αυτά τα προβλήματα θα έπρεπε να εντοπίζονται κατά τη διάρκεια των δοκιμών αποδοχής, τις οποίες θα συζητήσουμε σύντομα σε αυτό το κεφάλαιο. Ωστόσο, υπάρχουν και περιπτώσεις όπου μπορεί να προκύψουν προβλήματα στο διακομιστή, όπως διαρροή μνήμης ή άλλα εσωτερικά προβλήματα υποδομής που δεν θα ανιχνευθούν από τις δοκιμές end-to-end.

Όσον αφορά τις κατηγορίες των εξαιρέσεων που μπορούν να χειριστούν, το εύρος είναι σχετικά μικρότερο όσον αφορά τα σφάλματα του διακομιστή. Εδώ είναι τα σχετικά στοιχεία:

| Code      							| Method                          	| Exception								                            |
|---------------------------------------|-----------------------------------|-------------------------------------------------------------------|
| 500             				        | InternalServerError               | DependencyException or ServiceException                           |
| 507               				    | NotFound               			| InsufficientStorageException (Internal Only)                      |

Υπάρχει επίσης ένα ενδιαφέρον περιστατικό όπου δύο ομάδες συμφωνούν σε ένα συγκεκριμένο έγγραφο swagger, και η ομάδα ανάπτυξης του πίσω μέρους του API αποφασίζει να χτίσει αντίστοιχα σημεία εισόδου API με μεθόδους που δεν έχουν υλοποιηθεί ακόμα, για να επικοινωνήσει στην άλλη ομάδα ότι το έργο δεν έχει ξεκινήσει ακόμα. Σε αυτήν την περίπτωση, η χρήση του κωδικού σφάλματος `501` είναι αρκετή, ο οποίος είναι ένας κωδικός για "Μη υλοποιημένο".

Επίσης, είναι σημαντικό να αναφερθεί ότι ο πρωτογενής κωδικός σφάλματος `500` μπορεί να επικοινωνείται σε εφαρμογές ASP.NET μέσω της μεθόδου `Problem`. Βασιζόμαστε σε μια βιβλιοθήκη `RESTfulSense` για να παρέχει περισσότερους κωδικούς από ό,τι μπορεί να προσφέρει η πρωτογενής υλοποίηση, αλλά πιο σημαντικά παρέχει μια επιλογή για ανάπτυξη και αποσυναρμολόγηση λεπτομερειών προβλημάτων στο πλευρικό μέρος του πελάτη.

#### 3.1.1.2.1.3 Όλοι οι Κωδικοί
Πέρα από αυτούς που αναφέρθηκαν στα προηγούμενα τμήματα και για σκοπούς τεκμηρίωσης, παρακάτω παρατίθενται όλοι οι κωδικοί `4xx` και `5xx` που μπορεί να επικοινωνήσει ένα API σύμφωνα με τις τελευταίες τυποποιημένες κατευθυντήριες γραμμές:

|Status|Code|
|--- |--- |
|BadRequest|400|
|Unauthorized|401|
|PaymentRequired|402|
|Forbidden|403|
|NotFound|404|
|UrlNotFound|404|
|MethodNotAllowed|405|
|NotAcceptable|406|
|ProxyAuthenticationRequired|407|
|RequestTimeout|408|
|Conflict|409|
|Gone|410|
|LengthRequired|411|
|PreconditionFailed|412|
|RequestEntityTooLarge|413|
|RequestUriTooLong|414|
|UnsupportedMediaType|415|
|RequestedRangeNotSatisfiable|416|
|ExpectationFailed|417|
|MisdirectedRequest|421|
|UnprocessableEntity|422|
|Locked|423|
|FailedDependency|424|
|UpgradeRequired|426|
|PreconditionRequired|428|
|TooManyRequests|429|
|RequestHeaderFieldsTooLarge|431|
|UnavailableForLegalReasons|451|
|InternalServerError|500|
|NotImplemented|501|
|BadGateway|502|
|ServiceUnavailable|503|
|GatewayTimeout|504|
|HttpVersionNotSupported|505|
|VariantAlsoNegotiates|506|
|InsufficientStorage|507|
|LoopDetected|508|
|NotExtended|510|
|NetworkAuthenticationRequired|511|

Θα εξετάσουμε τον ενσωματισμό ορισμένων από αυτούς τους κωδικούς σε μελλοντικές αναθεωρήσεις του Προτύπου όπως χρειάζεται.

### 3.1.1.2.2 Μονή Εξάρτηση
Τα στοιχεία εκθέτη μπορούν να έχουν μόνο μια εξάρτηση. Αυτή η εξάρτηση πρέπει να είναι ένα στοιχείο Υπηρεσίας. Δεν μπορεί να είναι ένας Ενδιάμεσος (Broker) ή οποιαδήποτε άλλη φυσική εξάρτηση που οι Ενδιάμεσοι μπορεί να χρησιμοποιούν για την ανάκτηση ρυθμίσεων ή οποιαδήποτε άλλης μορφής εξαρτήσεις.

Κατά την υλοποίηση ενός ελεγκτή, ο κατασκευαστής μπορεί να υλοποιηθεί ως εξής:

```csharp
[ApiController]
[Route("api/[controller]")]
public class StudentsController : RESTFulController
{
    private readonly IStudentService studentService;

    public StudentsController(IStudentService studentService) =>
        this.studentService = studentService;

    ...
    ...
}
```

### 3.1.1.2.3 Μονό Συμβόλαιο
Αυτό το χαρακτηριστικό προκύπτει από τον κανόνα της μοναδικής εξάρτησης. Εάν οι Υπηρεσίες μπορούν να εξυπηρετούν και να λαμβάνουν μόνο ένα συμβόλαιο, τότε το ίδιο θα ισχύει και για τους ελεγκτές. Μπορούν να επιστρέψουν ένα συμβόλαιο, μια λίστα αντικειμένων με το ίδιο συμβόλαιο ή μέρος του συμβολαίου όταν περνούν Ids ή ερωτήματα.

## 3.1.1.3 Οργάνωση
Οι ελεγκτές πρέπει να βρίσκονται κάτω από τον φάκελο Controllers και να ανήκουν στο πεδίο ονομάτων Controllers. Οι ελεγκτές δεν χρειάζεται να έχουν δικούς τους φακέλους ή πεδία ονομάτων, καθώς εκτελούν μια απλή διαδικασία εκθέσεως και αυτό είναι όλο.

Παράδειγμα πεδίου ονομάτων για έναν ελεγκτή:

```csharp
namespace GitFyle.Core.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ContributionsController : RESTFulController
    {
        ...
    }
}
```

## 3.1.1.4 Ελεγκτής Αρχικής Σελίδας
Κάθε σύστημα θα πρέπει να υλοποιεί ένα σημείο πρόσβασης API που αποκαλούμε HomeController. Η μοναδική ευθύνη του ελεγκτή είναι να επιστρέφει ένα απλό μήνυμα που υποδεικνύει ότι το API είναι ακόμα ενεργό. Εδώ υπάρχει ένα παράδειγμα:

```csharp
using Microsoft.AspNetCore.Mvc;

namespace OtripleS.Web.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class HomeController : ControllerBase
    {
        [HttpGet]
        public ActionResult<string> Get() =>
            Ok("Hello Mario, the princess is in another castle!");
    }
}
```

Οι ελεγκτές (controllers) της αρχικής σελίδας (home controllers) δεν απαιτείται να έχουν κάποια ασφάλεια σε αυτά. Αυτοί ανοίγουν έναν πύλη για δοκιμές καρδιακού παλμού (heartbeat tests) για να εξασφαλίσουν ότι το σύστημα ως οντότητα λειτουργεί χωρίς να ελέγχει κάποιες εξωτερικές εξαρτήσεις. Αυτή η πρακτική είναι πολύ σημαντική για να βοηθήσει τους μηχανικούς να γνωρίζουν πότε το σύστημα είναι εκτός λειτουργίας και να ενεργούν γρήγορα.

## 3.1.1.5 Δοκιμές
Οι ελεγκτές μπορούν να υποβληθούν σε μονάδα δοκιμών για να επαληθευτεί ότι η αντιστοίχιση των εξαιρέσεων στους κωδικούς σφάλματος είναι στη θέση της. Ωστόσο, αυτό δεν είναι ένα πρότυπο που έχω ακολουθήσει μέχρι τώρα. Ωστόσο, πιο σημαντικές είναι οι δοκιμές αποδοχής. Οι δοκιμές αποδοχής επαληθεύουν ότι όλα τα συστατικά του συστήματος είναι πλήρως και επιτυχώς ενσωματωμένα μεταξύ τους.

Εδώ υπάρχει ένα παράδειγμα ενός δοκιμαστικού αποδοχής:

```csharp
[Fact]
public async Task ShouldPostStudentAsync()
{
    // given
    Student randomStudent = CreateRandomStudent();
    Student inputStudent = randomStudent;
    Student expectedStudent = inputStudent;

    // when 
    await this.otripleSApiBroker.PostStudentAsync(inputStudent);

    Student actualStudent =
        await this.otripleSApiBroker.GetStudentByIdAsync(inputStudent.Id);

    // then
    actualStudent.Should().BeEquivalentTo(expectedStudent);
    await this.otripleSApiBroker.DeleteStudentByIdAsync(actualStudent.Id);
}
```

Τα δοκιμαστικά αποδοχής απαιτούνται για να καλύπτουν κάθε διαθέσιμο σημείο πρόσβασης (endpoint) σε έναν ελεγκτή. Είναι επίσης υπεύθυνα για τον καθαρισμό οποιωνδήποτε δεδομένων δοκιμής μετά την ολοκλήρωση της δοκιμής. Είναι επίσης σημαντικό να αναφέρουμε ότι πόροι που δεν ανήκουν στη μικρουπηρεσία, όπως η βάση δεδομένων, πρέπει να προσομοιωθούν με εφαρμογές όπως το WireMock και πολλές άλλες.

Τα δοκιμαστικά αποδοχής επίσης υλοποιούνται μετά το γεγονός σε αντίθεση με τα δοκιμαστικά μονάδας. Ένα σημείο πρόσβασης πρέπει να είναι πλήρως ενσωματωμένο και λειτουργικό προτού γραφεί ένα τεστ για να διασφαλιστεί η επιτυχία της υλοποίησης.


[*] [Acceptance Tests (Part 1)](https://www.youtube.com/watch?v=WWN-9ahbdIU)

[*] [Acceptance Tests (Part 2)](https://www.youtube.com/watch?v=ANqj9pldfso)

