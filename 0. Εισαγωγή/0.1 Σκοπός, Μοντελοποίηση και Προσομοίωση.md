# 0.1 Σκοπός, Μοντελοποίηση και Προσομοίωση

## 0.1.0 Εισαγωγή

Το Standard ορίζει τη διαδικασία της μηχανικής λογισμικού σε τρεις κύριες κατηγορίες: Σκοπό, Μοντελοποίηση και Προσομοίωση. Κάθε ένα από αυτά τα στοιχεία παίζει κρίσιμο ρόλο στην καθοδήγηση των προσπαθειών μηχανικής προς την παραγωγή μιας επιτυχημένης λύσης και την εκπλήρωση ενός συγκεκριμένου σκοπού.

Η σειρά με την οποία ακολουθούνται αυτά τα στοιχεία είναι επίσης σκόπιμη. Πρέπει να υπάρχει ένας σκοπός για να διαμορφωθεί η διαδικασία μοντελοποίησης. Και κανείς δεν μπορεί να προσομοιώνει αλληλεπιδράσεις χωρίς μοντέλα. Αλλά ενώ αυτή η σειρά στην έναρξη της διαδικασίας μηχανικής είναι κρίσιμη, είναι σημαντικό να κατανοήσουμε ότι η ίδια η διαδικασία είναι επιλεκτικά ιεραρχική. Μια αλλαγή στον σκοπό μπορεί να αντικατοπτριστεί ως αλλαγή στη προσομοίωση αλλά όχι απαραίτητα στη μοντελοποίηση. Μια αλλαγή στα μοντέλα μπορεί να μην απαιτεί απαραίτητα αλλαγή στον σκοπό ή την προσομοίωση.

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148862410-f4ce62ad-deaa-4376-af1c-c43b9aa53473.png" />
	</div>
<br />

## 0.1.1 Σκοπός

Η διαδικασία σκοπού είναι η ικανότητά μας να ανακαλύψουμε γιατί χρειαζόμαστε μια λύση. Για παράδειγμα, αν έχουμε πρόβλημα να γνωρίζουμε πόσα είδη υπάρχουν σε κάποιο ράφι σε κάποιο σούπερ μάρκετ. Θεωρούμε ότι η χειροκίνητη καταμέτρηση είναι αναποτελεσματική και πρέπει να εφαρμοστεί ένα σύστημα για να διασφαλίσουμε ότι έχουμε τον σωστό αριθμό ειδών.

Η λογική βασίζεται σε μεγάλο βαθμό στην ικανότητά μας να παρατηρούμε προβλήματα και στη συνέχεια να διατυπώνουμε ένα πρόβλημα για να επινοήσουμε μια λύση που αντιμετωπίζει το συγκεκριμένο πρόβλημα. Επομένως, ο σκοπός είναι να βρούμε έναν λόγο για να ενεργήσουμε.

Έτσι, έχουμε την παρατήρηση, τη διατύπωση της λογικής (το πρόβλημα) και την πρόθεση για μια λύση. Όλα αυτά τα στοιχεία αποτελούν το τμήμα Σκοπού της μηχανικής λογισμικού.

### 0.1.1.0 Παρατήρηση

Ζούμε σε έναν κόσμο γεμάτο παρατηρήσιμα. Η έμπνευσή μας ενεργοποιείται από την φιλοδοξία μας να πετύχουμε περισσότερα. Τα όνειρά μας αποκαλύπτουν εμπόδια στο δρόμο μας που πρέπει να λύσουμε για να συνεχίσουμε το ταξίδι μας και να πραγματοποιήσουμε τα όνειρά μας. Από τη στιγμή που ένας νεαρός μαθητής χρησιμοποιεί έναν υπολογιστή για να λύσει μια περίπλοκη εξίσωση έως τη στιγμή που ο ίδιος ο μαθητής γίνεται αστροναύτης, υπολογίζοντας την τροχιά των δορυφόρων που περιβάλλουν τον πλανήτη μας.

Η παρατήρηση είναι η ικανότητά μας να ανιχνεύσουμε ένα πρόβλημα που εμποδίζει την επίτευξη ενός στόχου. Τα προβλήματα μπορούν να είναι από απλά, όπως να έχουμε τον σωστό αριθμό ειδών σε ένα ράφι σούπερ μάρκετ, έως και να κατανοήσουμε γιατί δεν μπορούμε να καταγράψουμε εικόνες πλανητών εκατομμύρια έτη φωτός μακριά από εμάς. Αυτά είναι τα προβλήματα που οι μηχανικοί θα περιέγραφαν ως παρατηρήσιμα προβλήματα.

Όσο μεγαλύτερος είναι ο σκοπός, τόσο πιο περίπλοκο θα είναι ένα πρόβλημα. Αλλά η εκκίνηση με μικρότερους σκοπούς είναι ένας τρόπος να εκπαιδεύσουμε το μυαλό μας να αντιμετωπίσει μεγαλύτερους - βήμα-βήμα, ένα πρόβλημα τη φορά.

### 0.1.1.1 Άρθρωση

Η περιγραφή του παρατηρήσιμου είναι από μόνη της μια τέχνη, διότι η καλή περιγραφή ενός προβλήματος είναι το μισό της λύσης του. Όσο πιο σαφής είναι η αρθρογραφία του προβλήματος, τόσο πιο πιθανό είναι να κατανοηθεί από άλλους που μας βοηθούν να λύσουμε το ίδιο πρόβλημα.

Η αρθρογραφία δεν είναι πάντα με λέξεις. Είναι επίσης με σχήματα και μορφές. Δεν είναι τυχαίο ότι ορισμένες από τις πιο προηγμένες αρχαίες κουλτούρες έχουν χρησιμοποιήσει σχήματα και μορφές για να περιγράψουν την εποχή τους και την ιστορία τους. Τα σχήματα είναι μια παγκόσμια γλώσσα, που κατανοείται και ερμηνεύεται από οποιονδήποτε μπορεί να τα συσχετίσει πολύ πιο γρήγορα από το να μάθει μια ομιλούμενη γλώσσα. Ένα σχήμα ή μια μορφή μπορεί να είναι ο πιο ωφέλιμος τρόπος να απεικονιστεί μια ιδέα, καθώς οι εικόνες της αξίζουν χιλιάδες λέξεις.

Η αρθρογραφία απαιτεί πάθος για την επίλυση του προβλήματος. Είτε είναι γραπτή, προφορική ή εικονογραφημένη. Ένα πάθος μυαλό θα μεταδώσει το κρυφό μήνυμα της επικαιρότητας του προβλήματος που πρέπει να λυθεί. Η αρθρογραφία ενός προβλήματος είναι ένα μεγάλο μέρος του τρόπου με τον οποίο μπορεί κανείς να πουλήσει μια λύση. Η ικανότητά μας να μεταδώσουμε μια ιδέα σε άλλους μηχανικούς και σε όσους θα επενδύσουν και θα χρησιμοποιήσουν αυτή τη λύση είναι ένα από τα πιο κρίσιμα aspects της μηχανικής λογισμικού.

### 0.1.1.2 Λύση

Μέρος του σκοπού είναι ο τρόπος με τον οποίο θα επιτευχθεί. Στην βιομηχανία της μηχανικής, η εκπλήρωση των στόχων δεν μπορεί να γίνει με οποιονδήποτε τρόπο. Ένας μεγάλος λόγος για τον οποίο τόση πολλή λογισμική αποτυγχάνει παγκοσμίως είναι ότι η πτυχή της επίλυσης προβλημάτων αγνοήθηκε ως ασήμαντο μέρος του σκοπού. Μπορεί να έχετε ακούσει για μηχανικούς που βρίσκονται ενάντια σε μια προθεσμία και αποφασίζουν να κόψουν γωνίες για να επιτύχουν έναν στόχο. Σύμφωνα με το Standard μας, αυτό είναι παραβίαση. Μια λύση δεν πρέπει απλώς να επιτύχει έναν στόχο αλλά πρέπει να είναι ένας σκοπός από μόνο του, προς όφελος των περιβαλλόντων αρχιτεκτονικών ζητημάτων όπως η βελτιστοποίηση, η αναγνωσιμότητα, η διαμορφωσιμότητα και η μακροζωία. Η επίλυση προβλημάτων ως μέρος του σκοπού είναι η τέχνη της μηχανικής λογισμικού.

## 0.1.2 Μοντελοποίηση

Η μοντελοποίηση είναι το δεύτερο πιο σημαντικό aspect της μηχανικής λογισμικού. Μπορούμε να εξαγάγουμε μοντέλα από τους ηθοποιούς σε οποιοδήποτε πρόβλημα, είτε αυτοί οι ηθοποιοί είναι ζωντανοί οργανισμοί, αντικείμενα ή άλλοι. Εξάγοντας μόνο τα attributes που σχετίζονται με το πρόβλημα που προσπαθούμε να λύσουμε και απορρίπτοντας τα υπόλοιπα. Για παράδειγμα, όταν προσπαθούμε να μετρήσουμε τα items σε ένα ράφι σούπερ μάρκετ, θα χρειαζόμασταν ένα μοντέλο για αυτά τα items.

Ένα πιο απλό παράδειγμα θα ήταν η ανίχνευση των items σε ένα σούπερ μάρκετ που είναι εύθραυστα. Το μόνο attribute που μας ενδιαφέρει εδώ είναι η ημερομηνία λήξης του item. Όλα τα άλλα, συμπεριλαμβανομένης της ετικέτας, του χρώματος, του βάρους ή οποιωνδήποτε άλλων πληροφοριών, είναι εκτός του πεδίου εφαρμογής της διαδικασίας μοντελοποίησης και της λύσης.

Η μοντελοποίηση δεν μπορεί να υπάρξει χωρίς έναν σκοπό. Καθώς ο σκοπός ορίζει το πεδίο εφαρμογής ή το πλαίσιο εντός του οποίου θα πρέπει να πραγματοποιηθεί η μοντελοποίηση. Η μοντελοποίηση χωρίς σκοπό αφήνει την πόρτα ανοιχτή για να προσελκύσει έναν άπειρο αριθμό attributes που μπορεί να έχει κάθε στοιχείο στο παρατηρήσιμο σύμπαν.

Η σχέση μεταξύ των attributes purposing και modeling είναι ανάλογη. Όσο πιο περίπλοκος είναι ο σκοπός, τόσο πιο πιθανό είναι η διαδικασία μοντελοποίησης να απαιτήσει περισσότερα attributes από τον πραγματικό κόσμο για να μοντελοποιηθεί στη λύση.

Εκφράζουμε τα μοντέλα μας σε γλώσσες προγραμματισμού ως class. Το προαναφερθέν πρόβλημα των εύθραυστα items μπορεί να εκπροσωπηθεί ως εξής:

```csharp
public class Item
{
	public DateTimeOffset ExpirationDate {get; set;}
}
```

Το όνομα της `class` αντιπροσωπεύει τον συνολικό τύπο του item. Δεδομένου ότι όλα τα items έχουν το ίδιο attribute της ExpirationDate, το όνομα θα πρέπει να παραμείνει όσο το δυνατόν πιο γενικό.

Τώρα, ας φανταστούμε ότι ο σκοπός μας έγινε λίγο πιο περίπλοκος. Ας υποθέσουμε ότι το νέο πρόβλημα είναι να εντοπίσουμε τα πιο ακριβά εύθραυστα items ώστε το κατάστημα να τα βάλει μπροστά για να τα πουλήσει πριν από τα λιγότερο δαπανηρά items. Σε αυτή την περίπτωση, το μοντέλο μας θα απαιτούσε ένα νέο attribute όπως η Price ώστε ένα πρόγραμμα υπολογιστή ή μια λύση να μπορεί να determine which is more valuable. Αυτή είναι η εμφάνιση του νέου μας μοντέλου:

```csharp
public class Item
{
	public double Price {get; set;}
	public DateTimeOffset ExpirationDate {get; set;}
}
```

### 0.1.2.0 Τύποι Μοντέλων

Τα μοντέλα διέπουν ολόκληρη τη διαδικασία προσομοίωσης ενός προβλήματος (και της λύσης του). Τα ίδια τα μοντέλα χωρίζονται σε τρεις κύριες κατηγορίες, τους Φορείς Δεδομένων, τα Λειτουργικά και τα Ρυθμιστικά. Ας συζητήσουμε αυτούς τους τύπους στις ακόλουθες ενότητες:

#### 0.1.2.0.0 Μοντέλα φορέων δεδομένων

Τα μοντέλα φορέων δεδομένων έχουν έναν κύριο σκοπό, ο οποίος είναι να μεταφέρουν δεδομένα μεταξύ συστημάτων. Τα μοντέλα φορέων δεδομένων μπορούν να διαφέρουν ανάλογα με τον τύπο των δεδομένων που μεταφέρουν. Ορισμένα μοντέλα φορέων δεδομένων μεταφέρουν άλλα μοντέλα για να αντιπροσωπεύσουν ένα σύνθετο σύστημα. Άλλα απλώς αντιπροσωπεύουν αναφορές στα αρχικά δεδομένα που αντιπροσωπεύουν.

Μοντέλα φορέων δεδομένων σε σχεσιακή μορφή μπορούν να χωριστούν σε τρεις διαφορετικές κατηγορίες. Αυτές οι κατηγορίες καθιστούν πολύ πιο σαφή τις περιοχές προτεραιότητας όσον αφορά την ανάπτυξη, το σχεδιασμό και την μηχανική. Για παράδειγμα, δεν μπορούμε να ξεκινήσουμε την ανάπτυξη δευτερευόντων/υποστηρικτικών μοντέλων αν δεν έχουμε τα πρωταρχικά μας μοντέλα πρώτα. Ας μιλήσουμε για αυτές τις κατηγορίες λεπτομερώς:

#### 0.1.2.0.0.0 Πρωταρχικά μοντέλα

Τα πρωταρχικά μοντέλα είναι οι πυλώνες κάθε συστήματος. Κανένα σύστημα δεν μπορεί να προχωρήσει στο σχεδιασμό και την μηχανική χωρίς μια σαφή οριοθέτηση και υλοποίηση αυτών των πρωταρχικών μοντέλων. Για παράδειγμα, αν χτίζουμε ένα εκπαιδευτικό σύστημα, μοντέλα όπως Student, Teacher και Course θεωρούνται πρωταρχικά μοντέλα.

Τα πρωταρχικά μοντέλα αποθήκευσης σχεσιακού σχήματος δεν περιέχουν ξένες πλήκτρες ή αναφορές σε οποιοδήποτε άλλο φυσικό μοντέλο. Ονομάζουμε αυτά τα μοντέλα πρωταρχικά επειδή είναι αυτάρκη. Δεν εξαρτώνται φυσικά από κάποιο άλλο μοντέλο για να υπάρχουν. Αυτό σημαίνει ότι ένα δεδομένο πρωταρχικό μοντέλο όπως το Student μπορεί να εξακολουθεί να υπάρχει σε ένα εκπαιδευτικό σύστημα είτε υπάρχει ένα αρχείο Teacher είτε όχι. Αυτό ονομάζεται φυσική εξάρτηση.

Ωστόσο, τα πρωταρχικά μοντέλα ενδέχεται να βασίζονται εννοιολογικά ή λογικά σε άλλα μοντέλα. Για παράδειγμα, ένα μοντέλο Student έχει μια λογική σχέση με ένα μοντέλο Teacher, απλώς και μόνο επειδή δεν μπορεί να υπάρξει μαθητής χωρίς καθηγητή και αντίστροφα. Ένα μοντέλο Student έχει επίσης μια εννοιολογική σχέση με τον οικοδεσπότη του και τις γειτονικές υπηρεσίες φιλοξενίας. Για παράδειγμα, υπάρχει μια εννοιολογική σχέση μεταξύ ενός μοντέλου Student και ενός μοντέλου Notification σχετικά με τη ροή εργασιών. Οποιοσδήποτε φοιτητής σε οποιοδήποτε σχολείο βασίζεται εννοιολογικά σε ειδοποιήσεις για να παρακολουθήσει μαθήματα και να ολοκληρώσει εργασίες ή άλλες εκδηλώσεις (events).


#### 0.1.2.0.0.1 Δευτερεύοντα μοντέλα

Από την άλλη πλευρά, τα δευτερεύοντα μοντέλα έχουν σκληρή εξάρτηση από τα πρωταρχικά μοντέλα. Σε ένα σχεσιακό μοντέλο βάσης δεδομένων, τα δευτερεύοντα μοντέλα συνήθως έχουν ξένες πλήκτρες που αναφέρονται σε άλλο μοντέλο στο συνολικό σχήμα της βάσης δεδομένων. Αλλά ακόμα και σε μη σχεσιακά συστήματα αποθήκευσης, τα δευτερεύοντα μοντέλα μπορούν να αντιπροσωπεύονται ως ιεραρχικές οντότητες εντός μιας δεδομένης μεγαλύτερης οντότητας ή να έχουν χαλαρή αναφορά σε άλλη οντότητα.

Ας μιλήσουμε για κάποια παραδείγματα δευτερευόντων μοντέλων. Ένα μοντέλο Comment σε μια πλατφόρμα κοινωνικών μέσων δεν μπορεί να υπάρξει χωρίς ένα μοντέλο Post. Δεν μπορείτε να σχολιάσετε κάτι που δεν υπάρχει. Σε μια σχεσιακή βάση δεδομένων, το μοντέλο σχολίων θα μοιάζει κάπως έτσι:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897099-5dd8aa3d-f6c2-4504-ba42-5e911c21a09a.png" />
</div>

<br />

Στο παραπάνω παράδειγμα, ένα δευτερεύον μοντέλο `Comment` έχει ένα ξένο πλήκτρο PostId που αναφέρεται στο πρωτεύον κλειδί `Id` σε ένα μοντέλο `Post`. Σε ένα μη σχεσιακό σύστημα, τα δευτερεύοντα μοντέλα μπορούν εύκολα να αναγνωριστούν ως ιεραρχικά αντικείμενα εντός μιας δεδομένης οντότητας. Παρακάτω είναι ένα παράδειγμα:

```json
{
	"id": "some-id",
	"content": "some post",
	"comments": [
		{
			"id": "comment-id",
			"content": "some comment"
		}
	]
}
```

Δευτερεύοντα μοντέλα γενικά μπορεί να έχουν λογικές και εννοιολογικές σχέσεις με άλλα μοντέλα εντός του οικοδεσπότη τους, των γειτονικών ή των εξωτερικών συστημάτων. Ωστόσο, οι πιθανότητες να έχουν αυτές τις εννοιολογικές σχέσεις είναι πολύ λιγότερες από τα πρωταρχικά μοντέλα.

#### 0.1.2.0.0.2 Μοντέλα Σχέσεων

Τα μοντέλα σχέσεων είναι συνδέσεις μεταξύ δύο πρωτογενών μοντέλων. Η κύρια ευθύνη τους είναι να υλοποιήσουν μια σχέση πολλών προς πολλούς μεταξύ δύο οντοτήτων. Για παράδειγμα, ένας `Student` μπορεί να έχει πολλούς δασκάλους και ένας `Teacher` μπορεί να έχει πολλούς μαθητές. Σε αυτή την περίπτωση χρειαζόμαστε ένα μοντέλο σχέσεων για να ενεργεί ως ενδιάμεσο μοντέλο.

Τα μοντέλα σχέσεων δεν πρέπει να έχουν κανένα detail. Περιέχουν μόνο αναφορές σε άλλα μοντέλα και αυτό είναι το πρωτεύον κλειδί τους. Ένα σύνθετο κλειδί που συσσωρεύει δύο ή περισσότερα ξένα κλειδιά εντός του. Ας ρίξουμε μια ματιά σε ένα παράδειγμα:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897988-f865d0ef-9e22-421f-afe8-8d987bb67464.png" />
</div>

<br />

#### 0.1.2.0.0.3 Υβριδικά Μοντέλα

Υπάρχει μια κατάσταση όπου ένα μοντέλο συνδέει πολλαπλές οντότητες αλλά μεταφέρει επίσης τα δεδομένα του. Σας συμβουλεύω να μην ακολουθήσετε αυτή την πορεία για να διατηρήσετε την καθαρότητα στο σχεδιασμό του συστήματος σας και να ελέγξετε την πολυπλοκότητα των μοντέλων σας. Ωστόσο, μερικές φορές αυτή η προσέγγιση είναι μια απαραίτητη επιλογή για να προχωρήσετε με μια συγκεκριμένη υλοποίηση ή μια επιχειρηματική ροή. Σε αυτή την περίπτωση, μπορούμε να προτείνουμε ένα υβριδικό μοντέλο που μπορεί να μεταφέρει συγκεκριμένες λεπτομέρειες σχετικά με τη σχέση μεταξύ δύο ανεξάρτητων οντοτήτων.

Ένα υβριδικό μοντέλο μπορεί να περιγράψει την αποσύνδεση μεταξύ δύο οντοτήτων σε μια σχέση πολλών προς πολλούς σε ένα σενάριο soft-delete. Ακολουθεί ένα παράδειγμα υβριδικού μοντέλου που μπορεί να συμβεί στην πραγματικότητα. Ας υποθέσουμε ότι ένα μέλος ομάδας δεν θέλει να είναι πλέον μέλος μιας συγκεκριμένης ομάδας. Θεωρούμε την ιδιότητα μέλους της ομάδας τους ως `απενεργοποιημένη` με έναν λόγο που επισυνάπτεται χωρίς να διαγράψουμε πραγματικά το αρχείο. Εδώ είναι τι θα έμοιαζε αυτό:

<br />
<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155970437-3599c84c-b27a-471f-979a-17b624dd6b63.png" />
</div>
<br />

Τα υβριδικά μοντέλα συνδυάζουν τα δευτερεύοντα μοντέλα στον τρόπο που αναφέρονται στα πρωταρχικά μοντέλα. Εφαρμόζουν μια σχεσιακή φύση επιτρέποντας σε πολλαπλές οντότητες να σχετίζονται μεταξύ τους χωρίς αποκλειστικότητα. Σε ένα μη σχεσιακό μοντέλο δεδομένων, η ακεραιότητα αναφοράς μπορεί να γίνει λίγο πιο χαλαρή λόγω της γραμμικής φύσης του σχήματος αυτού.

#### 0.1.2.0.1 Μοντέλα Λειτουργίας

Τα μοντέλα λειτουργίας στοχεύουν κυρίως στην προσομοίωση οποιουδήποτε λογισμικού συστήματος. Σκεφτείτε όλες τις πρωτόγονες, πολύπλοκες και εκθετικές λειτουργίες που θα μπορούσε να απαιτήσει ένα απλό σενάριο για να εφαρμοστεί μια επιτυχημένη προσομοίωση. Ας υποθέσουμε ότι προσπαθούμε να επιλύσουμε ένα πρόβλημα όπου μπορούμε να απλοποιήσουμε τις εγγραφές μαθητών σε ορισμένα σχολεία. Η διαδικασία εγγραφής θα απαιτήσει κάποια προσομοίωση για να προστεθεί η πληροφορία αυτών των μαθητών σε ένα ηλεκτρονικό σύστημα.

Τα μοντέλα λειτουργίας θα διαχειριστούν ολόκληρη την έκθεση, την επεξεργασία και την ολοκλήρωση της διαδικασίας, προσφέροντας υπηρεσίες που προσφέρουν API/UI για την εισαγωγή, την αποστολή, την προσθήκη και την εισαγωγή/επανάληψη των πληροφοριών των μαθητών σε ορισμένα συστήματα εκπαίδευσης.

Το Πρότυπο επικεντρώνεται έντονα στα μοντέλα λειτουργίας επειδή αντιπροσωπεύουν τον πυρήνα οποιουδήποτε συστήματος όσον αφορά τις επιχειρηματικές ροές. Τα μοντέλα λειτουργίας είναι επίσης όπου πηγαίνουν οι περισσότερες από τις πόρους ανάπτυξης και σχεδιασμού σε κάθε προσπάθεια ανάπτυξης λογισμικού. Τα μοντέλα λειτουργίας μπορούν να χωριστούν σε τρεις κύριες κατηγορίες: Την ολοκλήρωση, την επεξεργασία και την έκθεση.

#### 0.1.2.0.1.0 Integration Models (Brokers)
Integration operational models' primary responsibility is to connect any existing system with external resources, which can be localized to the environment of that system like reading the current date or time or remote like calling an external API or persisting data in some database.

We call these integration models Brokers. They play a liaison role between processing operational models and external systems. Here's an example:

```cSharp
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

The integration model above offers the capability to call an external API while abstracting the configuration details away from the processing operational models.

Like any other operational model type, they don't hold data but instead, use private class members and constants to share internal data across its public and private methods. The `ApiBroker` here as a model represents a simulation of integration with an external system.

We will discuss Brokers extensively in upcoming chapters to shed some light on the rules and guidelines in developing brokers with any external resources or systems.


#### 0.1.2.0.1.1 Processing Models (Services)
Processing models are the holders of all business-specific simulations. Things like student registrations, requesting a new library card, or simply retrieving some student information based on specific criteria. Processing models can be either primitive/foundational, high-order/processing, or advanced/orchestrators.

Processing models, in general, either rely on integration models or self-relying like computational processing services or rely on each other.

Here's an example of a simple foundational/primitive service:

```cSharp
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```

A higher-order service would do/look as follows:

```CSharp
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

More advanced orchestration-type services would combine multiple processing or foundational services as follows:
```csharp
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryCardProcessingService.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

In general, operational models are only concerned with the nature of simulation or processing of specific data carrier models; they are not concerned with holding data or retaining a status. In general, operational models are stateless in that they don't retain any of the details that went through them other than delegating logging for observability and monitoring purposes.

#### 0.1.2.0.1.2 Exposure Models (Exposers)
Exposure models handle the HMI in all scenarios where humans and systems have to interact. They could be simple RESTful APIs and SDKs or just UI like in web, mobile, or desktop applications, including commandline-based systems/terminals.

Exposure operational models are like the integration models; they allow the outside world to interact with your system. They sit on the other end of any system and are responsible for routing every request, communication, or call to the proper operational models. Exposure models never communicate directly with integration models and don't have any configuration other than their dependencies injected through their constructors.

Exposure models may have their own language in terms of operations; for instance, an integration model might use a language like `InsertStudent` while an exposure model for an API endpoint would use a language such as `PostStudent` to express the very same operation in an exposure context.

Here's an example of exposure models:

```csharp
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpPost]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

The above model exposes an API endpoint for RESTful communication to offer the capability to register students into a schooling system. We will further discuss the types of exposure models based on the context and the systems they are implemented within.

#### 0.1.2.0.2 Configuration Models
The last type of model in any system is the configuration model. They can represent the entry point into a system, register dependencies for any system, or take the form of middleware to route URLs into their respective function within an exposure model.

Configuration models usually sit at the beginning of launching a system, handling incoming and outgoing communications or underlying system operations like memory caching, thread management, etc.

In a simple API application, you may see models that look like this:

```csharp
public class Startup
{
	public void ConfigureServices(IServices services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

As you can see from the code snippet above, the configuration model `Startup` offers capabilities to handle dependency injection-based registration of contracts to their concrete implementations. They may handle adding security or setting up a middleware pipeline. Configuration models are technology-specific. They may differ from a Play framework in Scala to a Spring or Flex in Python or Java. We will outline high-level rules according to The Standard for configuration models, but we will not dive deeper into the details of implementing any of them.

## 0.1.3 Simulation

The simulation aspect of software engineering is our ability to resemble the interactions to and from the models. For instance, in the grocery store example, a simulation would be the act of *selling* the item. Selling the item requires multiple modifications to the item in terms of deducting the count of the available items and reordering the items left based on the most valuable available item.

We can describe the simulation process as illustrating the relationships between models, which are programmed as `functions`, `methods`, or `routines`; these terms all mean the same thing. If we have a software service that is responsible for items sales, a simulation process will look like this:

```csharp
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

In the example above, we have a model called `SaleService` that offers functionality to simulate the sales process in the real world on a model of an item. And this is how you describe everything in object-oriented programming. Everything is an object (from a model), and these objects interact with each other (simulation).

Object interaction, in general, can be observed in three different types. A model is taking an action on another model. For instance, the `SaleService` is executing an action of `Sell` on an `Item` model. That's a model interacting with another model. In the very same example, a simulation could be something happening to the model from another model, such as the `Item` in the example above. And the last type of simulation is a model interacting with itself, such as models that self-dispose once their purpose is achieved, as they are no longer needed, so they self-destruct.

The simulation process is the third and last aspect of software engineering. We will dive into it deeply when we talk about brokers, services, and exposers to illustrate how the industrial software's modeling and simulation process happens.

## 0.1.4 Summary

If we consider *purposing* to be the domain or the framework in which models interact, then the following illustration should simplify and convey the picture a bit clearer:

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148863196-a30ced43-7133-4107-a23f-d0beb3efa6db.png" />
	</div>
<br />

It's important to understand that computer software can serve multiple purposes. Computer software can interact with other software that shares common purposes. The purpose of the software becomes the model, and the integrations become the simulations in that aspect. Here's a 10,000 feet example:

<br />
	<div align=center>
		<img width="75%" src="https://user-images.githubusercontent.com/1453985/148863514-2ed0fe04-1096-42c3-b54a-3b8dbd506e7a.png" />
	</div>
<br />

The complexity of any large system can be broken into smaller problems if the single-purpose or single-responsibility aspect is enforced for each sub-system. That's what modern software architectures would call granularity and modularization, which we will be discussing briefly throughout the architecture aspect of The Standard.

[*] [Purposing, Modeling & Simulation (Part 1)](https://www.youtube.com/watch?v=Doul1gZKCuU)
