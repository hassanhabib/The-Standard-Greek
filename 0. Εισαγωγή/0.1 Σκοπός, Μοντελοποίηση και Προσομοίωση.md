# 0.1 Σκοπός, Μοντελοποίηση και Προσομοίωση

## 0.1.0 Εισαγωγή

Το Πρότυπο ορίζει τη διαδικασία της μηχανικής λογισμικού σε τρεις κύριες κατηγορίες: Σκοπό, Μοντελοποίηση και Προσομοίωση. Κάθε ένα από αυτά τα στοιχεία παίζει κρίσιμο ρόλο στην καθοδήγηση των προσπαθειών μηχανικής προς την παραγωγή μιας επιτυχημένης λύσης και την εκπλήρωση ενός συγκεκριμένου σκοπού.

Η σειρά με την οποία ακολουθούνται αυτά τα στοιχεία είναι επίσης σημαντική. Πρέπει να υπάρχει ένας σκοπός για να διαμορφωθεί η διαδικασία μοντελοποίησης. Και κανείς δεν μπορεί να προσομοιώνει αλληλεπιδράσεις χωρίς μοντέλα. Ενώ αυτή η σειρά στην έναρξη της διαδικασίας μηχανικής είναι κρίσιμη, είναι σημαντικό να κατανοήσουμε ότι η ίδια η διαδικασία είναι επιλεκτικά ιεραρχική. Μια αλλαγή στον σκοπό μπορεί να αντικατοπτριστεί ως αλλαγή στη προσομοίωση αλλά όχι απαραίτητα στη μοντελοποίηση. Μια αλλαγή στα μοντέλα μπορεί να μην απαιτεί απαραίτητα αλλαγή στον σκοπό ή την προσομοίωση.

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148862410-f4ce62ad-deaa-4376-af1c-c43b9aa53473.png" />
	</div>
<br />

## 0.1.1 Σκοπός

Η διαδικασία σκοπού είναι η ικανότητά μας να ανακαλύψουμε γιατί χρειαζόμαστε μια λύση. Για παράδειγμα, αν έχουμε πρόβλημα να γνωρίζουμε πόσα είδη υπάρχουν σε κάποιο ράφι σε κάποιο σούπερ μάρκετ. Θεωρούμε ότι η χειροκίνητη καταμέτρηση είναι αναποτελεσματική και πρέπει να εφαρμοστεί ένα σύστημα για να διασφαλίσουμε ότι έχουμε τον σωστό αριθμό ειδών.

Η λογική βασίζεται σε μεγάλο βαθμό στην ικανότητά μας να παρατηρούμε προβλήματα και στη συνέχεια να διατυπώνουμε ένα πρόβλημα για να επινοήσουμε μια λύση που αντιμετωπίζει το συγκεκριμένο πρόβλημα. Επομένως, ο σκοπός είναι να βρούμε έναν λόγο για να ενεργήσουμε.

Έτσι, έχουμε την παρατήρηση, τη διατύπωση της λογικής (το πρόβλημα) και την πρόθεση για μια λύση. Όλα αυτά τα στοιχεία αποτελούν το τμήμα Σκοπού της μηχανικής λογισμικού.

### 0.1.1.0 Παρατήρηση

Η έμπνευσή μας ενεργοποιείται από την φιλοδοξία μας να πετύχουμε περισσότερα. Τα όνειρά μας αποκαλύπτουν εμπόδια στο δρόμο μας που πρέπει να λύσουμε για να συνεχίσουμε το ταξίδι μας και να πραγματοποιήσουμε τα όνειρά μας. Από τη στιγμή που ένας νεαρός μαθητής χρησιμοποιεί έναν υπολογιστή για να λύσει μια περίπλοκη εξίσωση έως τη στιγμή που ο ίδιος ο μαθητής γίνεται αστροναύτης, υπολογίζοντας την τροχιά των δορυφόρων που περιβάλλουν τον πλανήτη μας.

Η παρατήρηση είναι η ικανότητά μας να ανιχνεύσουμε ένα πρόβλημα που εμποδίζει την επίτευξη ενός στόχου. Τα προβλήματα μπορούν να είναι από απλά, όπως να έχουμε τον σωστό αριθμό ειδών σε ένα ράφι σούπερ μάρκετ, έως και να κατανοήσουμε γιατί δεν μπορούμε να καταγράψουμε εικόνες πλανητών εκατομμύρια έτη φωτός μακριά από εμάς. Αυτά είναι τα προβλήματα που οι μηχανικοί θα περιέγραφαν ως παρατηρήσιμα προβλήματα.

Όσο μεγαλύτερος είναι ο σκοπός, τόσο πιο περίπλοκο θα είναι ένα πρόβλημα. Αλλά η εκκίνηση με μικρότερους σκοπούς είναι ένας τρόπος να εκπαιδεύσουμε το μυαλό μας να αντιμετωπίσει μεγαλύτερους - βήμα-βήμα, ένα πρόβλημα τη φορά.

### 0.1.1.1 Άρθρωση

Η περιγραφή του παρατηρήσιμου είναι από μόνη της μια τέχνη, διότι η καλή περιγραφή ενός προβλήματος είναι το μισό της λύσης του. Όσο πιο σαφής είναι η αρθρογραφία του προβλήματος, τόσο πιο πιθανό είναι να κατανοηθεί από άλλους που μας βοηθούν να λύσουμε το ίδιο πρόβλημα.

Η αρθρογραφία δεν είναι πάντα με λέξεις. Είναι επίσης με σχήματα και μορφές. Δεν είναι τυχαίο ότι ορισμένες από τις πιο προηγμένες αρχαίες κουλτούρες έχουν χρησιμοποιήσει σχήματα και μορφές για να περιγράψουν την εποχή τους και την ιστορία τους. Τα σχήματα είναι μια παγκόσμια γλώσσα, που κατανοείται και ερμηνεύεται από οποιονδήποτε μπορεί να τα συσχετίσει πολύ πιο γρήγορα από το να μάθει μια ομιλούμενη γλώσσα. Ένα σχήμα ή μια μορφή μπορεί να είναι ο πιο ωφέλιμος τρόπος να απεικονιστεί μια ιδέα, καθώς οι εικόνες της αξίζουν χιλιάδες λέξεις.

Η αρθρογραφία απαιτεί πάθος για την επίλυση του προβλήματος. Είτε είναι γραπτή, προφορική ή εικονογραφημένη. Ένα πάθος μυαλό θα μεταδώσει το κρυφό μήνυμα της επικαιρότητας του προβλήματος που πρέπει να λυθεί. Η αρθρογραφία ενός προβλήματος είναι ένα μεγάλο μέρος του τρόπου με τον οποίο μπορεί κανείς να πουλήσει μια λύση. Η ικανότητά μας να μεταδώσουμε μια ιδέα σε άλλους μηχανικούς και σε όσους θα επενδύσουν και θα χρησιμοποιήσουν αυτή τη λύση είναι ένα από τα πιο κρίσιμα aspects της μηχανικής λογισμικού.

### 0.1.1.2 Λύση

Μέρος του σκοπού είναι ο τρόπος με τον οποίο θα επιτευχθεί. Στην βιομηχανία της μηχανικής, η εκπλήρωση των στόχων δεν μπορεί να γίνει με οποιονδήποτε τρόπο. Ένας μεγάλος λόγος για τον οποίο τόση πολλή λογισμική αποτυγχάνει παγκοσμίως είναι ότι η πτυχή της επίλυσης προβλημάτων αγνοήθηκε ως ασήμαντο μέρος του σκοπού. Μπορεί να έχετε ακούσει για μηχανικούς που βρίσκονται ενάντια σε μια προθεσμία και αποφασίζουν να κόψουν γωνίες για να επιτύχουν έναν στόχο. Σύμφωνα με το Standard μας, αυτό είναι παραβίαση. Μια λύση δεν πρέπει απλώς να επιτύχει έναν στόχο αλλά πρέπει να είναι ένας σκοπός από μόνο του, προς όφελος των περιβαλλόντων αρχιτεκτονικών ζητημάτων όπως η βελτιστοποίηση, η αναγνωσιμότητα, η διαμορφωσιμότητα και η μακροζωία. Η επίλυση προβλημάτων ως μέρος του σκοπού είναι η τέχνη της μηχανικής λογισμικού.

## 0.1.2 Μοντελοποίηση

Η μοντελοποίηση είναι το δεύτερο πιο σημαντικό aspect της μηχανικής λογισμικού. Μπορούμε να εξαγάγουμε μοντέλα από τους ηθοποιούς σε οποιοδήποτε πρόβλημα, είτε αυτοί οι ηθοποιοί είναι ζωντανοί οργανισμοί, αντικείμενα ή άλλοι. Εξάγοντας μόνο τα attributes που σχετίζονται με το πρόβλημα που προσπαθούμε να λύσουμε και απορρίπτοντας τα υπόλοιπα. Για παράδειγμα, όταν προσπαθούμε να μετρήσουμε τα items σε ένα ράφι σούπερ μάρκετ, θα χρειαζόμασταν ένα μοντέλο για αυτά τα items.

Ένα πιο απλό παράδειγμα θα ήταν η ανίχνευση των items σε ένα σούπερ μάρκετ που είναι εύθραυστα. Το μόνο attribute που μας ενδιαφέρει εδώ είναι η ημερομηνία λήξης του item. Όλα τα άλλα, συμπεριλαμβανομένης της ετικέτας, του χρώματος, του βάρους ή οποιωνδήποτε άλλων πληροφοριών, είναι εκτός του πεδίου εφαρμογής της διαδικασίας μοντελοποίησης και της λύσης.

Η μοντελοποίηση δεν μπορεί να υπάρξει χωρίς έναν σκοπό. Καθώς ο σκοπός ορίζει το πεδίο εφαρμογής ή το πλαίσιο εντός του οποίου θα πρέπει να πραγματοποιηθεί η μοντελοποίηση. Η μοντελοποίηση χωρίς σκοπό αφήνει την πόρτα ανοιχτή για να προσελκύσει έναν άπειρο αριθμό attributes που μπορεί να έχει κάθε στοιχείο στο παρατηρήσιμο σύμπαν.

Η σχέση μεταξύ των attributes purposing και modeling είναι ανάλογη. Όσο πιο περίπλοκος είναι ο σκοπός, τόσο πιο πιθανό είναι η διαδικασία μοντελοποίησης να απαιτήσει περισσότερα attributes από τον πραγματικό κόσμο για να μοντελοποιηθεί στη λύση.

Εκφράζουμε τα μοντέλα μας σε γλώσσες προγραμματισμού ως class. Το προαναφερθέν πρόβλημα των εύθραυστα items μπορεί να εκπροσωπηθεί ως εξής:

```csharp
public class Item
{
	public DateTimeOffset ExpirationDate {get; set;}
}
```

Το όνομα της `class` αντιπροσωπεύει τον συνολικό τύπο του item. Δεδομένου ότι όλα τα items έχουν το ίδιο attribute της ExpirationDate, το όνομα θα πρέπει να παραμείνει όσο το δυνατόν πιο γενικό.

Τώρα, ας φανταστούμε ότι ο σκοπός μας έγινε λίγο πιο περίπλοκος. Ας υποθέσουμε ότι το νέο πρόβλημα είναι να εντοπίσουμε τα πιο ακριβά εύθραυστα items ώστε το κατάστημα να τα βάλει μπροστά για να τα πουλήσει πριν από τα λιγότερο δαπανηρά items. Σε αυτή την περίπτωση, το μοντέλο μας θα απαιτούσε ένα νέο attribute όπως η Price ώστε ένα πρόγραμμα υπολογιστή ή μια λύση να μπορεί να determine which is more valuable. Αυτή είναι η εμφάνιση του νέου μας μοντέλου:

```csharp
public class Item
{
	public double Price {get; set;}
	public DateTimeOffset ExpirationDate {get; set;}
}
```

### 0.1.2.0 Τύποι Μοντέλων

Τα μοντέλα διέπουν ολόκληρη τη διαδικασία προσομοίωσης ενός προβλήματος (και της λύσης του). Τα ίδια τα μοντέλα χωρίζονται σε τρεις κύριες κατηγορίες, τους Φορείς Δεδομένων, τα Λειτουργικά και τα Ρυθμιστικά. Ας συζητήσουμε αυτούς τους τύπους στις ακόλουθες ενότητες:

#### 0.1.2.0.0 Μοντέλα φορέων δεδομένων

Τα μοντέλα φορέων δεδομένων έχουν έναν κύριο σκοπό, ο οποίος είναι να μεταφέρουν δεδομένα μεταξύ συστημάτων. Τα μοντέλα φορέων δεδομένων μπορούν να διαφέρουν ανάλογα με τον τύπο των δεδομένων που μεταφέρουν. Ορισμένα μοντέλα φορέων δεδομένων μεταφέρουν άλλα μοντέλα για να αντιπροσωπεύσουν ένα σύνθετο σύστημα. Άλλα απλώς αντιπροσωπεύουν αναφορές στα αρχικά δεδομένα που αντιπροσωπεύουν.

Μοντέλα φορέων δεδομένων σε σχεσιακή μορφή μπορούν να χωριστούν σε τρεις διαφορετικές κατηγορίες. Αυτές οι κατηγορίες καθιστούν πολύ πιο σαφή τις περιοχές προτεραιότητας όσον αφορά την ανάπτυξη, το σχεδιασμό και την μηχανική. Για παράδειγμα, δεν μπορούμε να ξεκινήσουμε την ανάπτυξη δευτερευόντων/υποστηρικτικών μοντέλων αν δεν έχουμε τα πρωταρχικά μας μοντέλα πρώτα. Ας μιλήσουμε για αυτές τις κατηγορίες λεπτομερώς:

#### 0.1.2.0.0.0 Πρωταρχικά μοντέλα

Τα πρωταρχικά μοντέλα είναι οι πυλώνες κάθε συστήματος. Κανένα σύστημα δεν μπορεί να προχωρήσει στο σχεδιασμό και την μηχανική χωρίς μια σαφή οριοθέτηση και υλοποίηση αυτών των πρωταρχικών μοντέλων. Για παράδειγμα, αν χτίζουμε ένα εκπαιδευτικό σύστημα, μοντέλα όπως Student, Teacher και Course θεωρούνται πρωταρχικά μοντέλα.

Τα πρωταρχικά μοντέλα αποθήκευσης σχεσιακού σχήματος δεν περιέχουν ξένες πλήκτρες ή αναφορές σε οποιοδήποτε άλλο φυσικό μοντέλο. Ονομάζουμε αυτά τα μοντέλα πρωταρχικά επειδή είναι αυτάρκη. Δεν εξαρτώνται φυσικά από κάποιο άλλο μοντέλο για να υπάρχουν. Αυτό σημαίνει ότι ένα δεδομένο πρωταρχικό μοντέλο όπως το Student μπορεί να εξακολουθεί να υπάρχει σε ένα εκπαιδευτικό σύστημα είτε υπάρχει ένα αρχείο Teacher είτε όχι. Αυτό ονομάζεται φυσική εξάρτηση.

Ωστόσο, τα πρωταρχικά μοντέλα ενδέχεται να βασίζονται εννοιολογικά ή λογικά σε άλλα μοντέλα. Για παράδειγμα, ένα μοντέλο Student έχει μια λογική σχέση με ένα μοντέλο Teacher, απλώς και μόνο επειδή δεν μπορεί να υπάρξει μαθητής χωρίς καθηγητή και αντίστροφα. Ένα μοντέλο Student έχει επίσης μια εννοιολογική σχέση με τον οικοδεσπότη του και τις γειτονικές υπηρεσίες φιλοξενίας. Για παράδειγμα, υπάρχει μια εννοιολογική σχέση μεταξύ ενός μοντέλου Student και ενός μοντέλου Notification σχετικά με τη ροή εργασιών. Οποιοσδήποτε φοιτητής σε οποιοδήποτε σχολείο βασίζεται εννοιολογικά σε ειδοποιήσεις για να παρακολουθήσει μαθήματα και να ολοκληρώσει εργασίες ή άλλες εκδηλώσεις (events).


#### 0.1.2.0.0.1 Δευτερεύοντα μοντέλα

Από την άλλη πλευρά, τα δευτερεύοντα μοντέλα έχουν σκληρή εξάρτηση από τα πρωταρχικά μοντέλα. Σε ένα σχεσιακό μοντέλο βάσης δεδομένων, τα δευτερεύοντα μοντέλα συνήθως έχουν ξένες πλήκτρες που αναφέρονται σε άλλο μοντέλο στο συνολικό σχήμα της βάσης δεδομένων. Αλλά ακόμα και σε μη σχεσιακά συστήματα αποθήκευσης, τα δευτερεύοντα μοντέλα μπορούν να αντιπροσωπεύονται ως ιεραρχικές οντότητες εντός μιας δεδομένης μεγαλύτερης οντότητας ή να έχουν χαλαρή αναφορά σε άλλη οντότητα.

Ας μιλήσουμε για κάποια παραδείγματα δευτερευόντων μοντέλων. Ένα μοντέλο Comment σε μια πλατφόρμα κοινωνικών μέσων δεν μπορεί να υπάρξει χωρίς ένα μοντέλο Post. Δεν μπορείτε να σχολιάσετε κάτι που δεν υπάρχει. Σε μια σχεσιακή βάση δεδομένων, το μοντέλο σχολίων θα μοιάζει κάπως έτσι:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897099-5dd8aa3d-f6c2-4504-ba42-5e911c21a09a.png" />
</div>

<br />

Στο παραπάνω παράδειγμα, ένα δευτερεύον μοντέλο `Comment` έχει ένα ξένο πλήκτρο PostId που αναφέρεται στο πρωτεύον κλειδί `Id` σε ένα μοντέλο `Post`. Σε ένα μη σχεσιακό σύστημα, τα δευτερεύοντα μοντέλα μπορούν εύκολα να αναγνωριστούν ως ιεραρχικά αντικείμενα εντός μιας δεδομένης οντότητας. Παρακάτω είναι ένα παράδειγμα:

```json
{
	"id": "some-id",
	"content": "some post",
	"comments": [
		{
			"id": "comment-id",
			"content": "some comment"
		}
	]
}
```

Δευτερεύοντα μοντέλα γενικά μπορεί να έχουν λογικές και εννοιολογικές σχέσεις με άλλα μοντέλα εντός του οικοδεσπότη τους, των γειτονικών ή των εξωτερικών συστημάτων. Ωστόσο, οι πιθανότητες να έχουν αυτές τις εννοιολογικές σχέσεις είναι πολύ λιγότερες από τα πρωταρχικά μοντέλα.

#### 0.1.2.0.0.2 Μοντέλα Σχέσεων

Τα μοντέλα σχέσεων είναι συνδέσεις μεταξύ δύο πρωτογενών μοντέλων. Η κύρια ευθύνη τους είναι να υλοποιήσουν μια σχέση πολλών προς πολλούς μεταξύ δύο οντοτήτων. Για παράδειγμα, ένας `Student` μπορεί να έχει πολλούς δασκάλους και ένας `Teacher` μπορεί να έχει πολλούς μαθητές. Σε αυτή την περίπτωση χρειαζόμαστε ένα μοντέλο σχέσεων για να ενεργεί ως ενδιάμεσο μοντέλο.

Τα μοντέλα σχέσεων δεν πρέπει να έχουν κανένα detail. Περιέχουν μόνο αναφορές σε άλλα μοντέλα και αυτό είναι το πρωτεύον κλειδί τους. Ένα σύνθετο κλειδί που συσσωρεύει δύο ή περισσότερα ξένα κλειδιά εντός του. Ας ρίξουμε μια ματιά σε ένα παράδειγμα:

<br />

<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155897988-f865d0ef-9e22-421f-afe8-8d987bb67464.png" />
</div>

<br />

#### 0.1.2.0.0.3 Υβριδικά Μοντέλα

Υπάρχει μια κατάσταση όπου ένα μοντέλο συνδέει πολλαπλές οντότητες αλλά μεταφέρει επίσης τα δεδομένα του. Σας συμβουλεύω να μην ακολουθήσετε αυτή την πορεία για να διατηρήσετε την καθαρότητα στο σχεδιασμό του συστήματος σας και να ελέγξετε την πολυπλοκότητα των μοντέλων σας. Ωστόσο, μερικές φορές αυτή η προσέγγιση είναι μια απαραίτητη επιλογή για να προχωρήσετε με μια συγκεκριμένη υλοποίηση ή μια επιχειρηματική ροή. Σε αυτή την περίπτωση, μπορούμε να προτείνουμε ένα υβριδικό μοντέλο που μπορεί να μεταφέρει συγκεκριμένες λεπτομέρειες σχετικά με τη σχέση μεταξύ δύο ανεξάρτητων οντοτήτων.

Ένα υβριδικό μοντέλο μπορεί να περιγράψει την αποσύνδεση μεταξύ δύο οντοτήτων σε μια σχέση πολλών προς πολλούς σε ένα σενάριο soft-delete. Ακολουθεί ένα παράδειγμα υβριδικού μοντέλου που μπορεί να συμβεί στην πραγματικότητα. Ας υποθέσουμε ότι ένα μέλος ομάδας δεν θέλει να είναι πλέον μέλος μιας συγκεκριμένης ομάδας. Θεωρούμε την ιδιότητα μέλους της ομάδας τους ως `απενεργοποιημένη` με έναν λόγο που επισυνάπτεται χωρίς να διαγράψουμε πραγματικά το αρχείο. Εδώ είναι τι θα έμοιαζε αυτό:

<br />
<div align=center>
	<img src="https://user-images.githubusercontent.com/1453985/155970437-3599c84c-b27a-471f-979a-17b624dd6b63.png" />
</div>
<br />

Τα υβριδικά μοντέλα συνδυάζουν τα δευτερεύοντα μοντέλα στον τρόπο που αναφέρονται στα πρωταρχικά μοντέλα. Εφαρμόζουν μια σχεσιακή φύση επιτρέποντας σε πολλαπλές οντότητες να σχετίζονται μεταξύ τους χωρίς αποκλειστικότητα. Σε ένα μη σχεσιακό μοντέλο δεδομένων, η ακεραιότητα αναφοράς μπορεί να γίνει λίγο πιο χαλαρή λόγω της γραμμικής φύσης του σχήματος αυτού.

#### 0.1.2.0.1 Μοντέλα Λειτουργίας

Τα μοντέλα λειτουργίας στοχεύουν κυρίως στην προσομοίωση οποιουδήποτε λογισμικού συστήματος. Σκεφτείτε όλες τις πρωτόγονες, πολύπλοκες και εκθετικές λειτουργίες που θα μπορούσε να απαιτήσει ένα απλό σενάριο για να εφαρμοστεί μια επιτυχημένη προσομοίωση. Ας υποθέσουμε ότι προσπαθούμε να επιλύσουμε ένα πρόβλημα όπου μπορούμε να απλοποιήσουμε τις εγγραφές μαθητών σε ορισμένα σχολεία. Η διαδικασία εγγραφής θα απαιτήσει κάποια προσομοίωση για να προστεθεί η πληροφορία αυτών των μαθητών σε ένα ηλεκτρονικό σύστημα.

Τα μοντέλα λειτουργίας θα διαχειριστούν ολόκληρη την έκθεση, την επεξεργασία και την ολοκλήρωση της διαδικασίας, προσφέροντας υπηρεσίες που προσφέρουν API/UI για την εισαγωγή, την αποστολή, την προσθήκη και την εισαγωγή/επανάληψη των πληροφοριών των μαθητών σε ορισμένα συστήματα εκπαίδευσης.

Το Πρότυπο επικεντρώνεται έντονα στα μοντέλα λειτουργίας επειδή αντιπροσωπεύουν τον πυρήνα οποιουδήποτε συστήματος όσον αφορά τις επιχειρηματικές ροές. Τα μοντέλα λειτουργίας είναι επίσης όπου πηγαίνουν οι περισσότερες από τις πόρους ανάπτυξης και σχεδιασμού σε κάθε προσπάθεια ανάπτυξης λογισμικού. Τα μοντέλα λειτουργίας μπορούν να χωριστούν σε τρεις κύριες κατηγορίες: Την ολοκλήρωση, την επεξεργασία και την έκθεση.

#### 0.1.2.0.1.0 Μοντέλα Ενσωμάτωσης (Διαμεσολαβητές)
Η βασική ευθύνη των λειτουργικών μοντέλων ενσωμάτωσης είναι να συνδέουν οποιοδήποτε υπάρχον σύστημα με εξωτερικούς πόρους, που μπορεί να είναι τοπικοί για το περιβάλλον εκείνου του συστήματος, όπως η ανάγνωση της τρέχουσας ημερομηνίας ή ώρας, ή απομακρυσμένοι, όπως η κλήση εξωτερικού API ή η διατήρηση δεδομένων σε κάποια βάση δεδομένων.

Αυτά τα μοντέλα ενσωμάτωσης τα αποκαλούμε Διαμεσολαβητές. Παίζουν ρόλο διαμεσολαβητή μεταξύ των λειτουργικών μοντέλων επεξεργασίας και των εξωτερικών συστημάτων. Εδώ έχουμε ένα παράδειγμα:

```cSharp
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

Το παραπάνω μοντέλο ενσωμάτωσης προσφέρει τη δυνατότητα να καλεί ένα εξωτερικό API, αφαιρώντας τις λεπτομέρειες ρύθμισης από τα λειτουργικά μοντέλα επεξεργασίας.

Όπως και άλλοι τύποι λειτουργικών μοντέλων, δεν κρατούν δεδομένα, αλλά αντίθετα χρησιμοποιούν ιδιωτικά μέλη τάξης και σταθερές για να μοιράζονται εσωτερικά δεδομένα σε όλες τις δημόσιες και ιδιωτικές μεθόδους τους. Ο `ApiBroker` εδώ ως μοντέλο αντιπροσωπεύει μια προσομοίωση της ενσωμάτωσης με ένα εξωτερικό σύστημα.

Θα συζητήσουμε εκτενώς τους Διαμεσολαβητές στα επερχόμενα κεφάλαια για να φωτίσουμε τους κανόνες και τις κατευθυντήριες γραμμές στην ανάπτυξη διαμεσολαβητών με οποιουσδήποτε εξωτερικούς πόρους ή συστήματα.


#### 0.1.2.0.1.1 Μοντέλα Επεξεργασίας (Υπηρεσίες)
Τα μοντέλα επεξεργασίας αποτελούν τους κατόχους όλων των επιχειρησιακών προσομοιώσεων. Πράγματα όπως οι εγγραφές φοιτητών, η αίτηση για μια νέα κάρτα βιβλιοθήκης ή απλώς η ανάκτηση ορισμένων πληροφοριών φοιτητή με βάση συγκεκριμένα κριτήρια. Τα μοντέλα επεξεργασίας μπορούν να είναι είτε αρχαϊκά/θεμελιακά, υψηλής τάξης/επεξεργασίας, ή προχωρημένα/ορχηστρωτές.

Τα μοντέλα επεξεργασίας, γενικά, είτε βασίζονται σε μοντέλα ενσωμάτωσης είτε είναι αυτάκλητα, όπως οι υπηρεσίες επεξεργασίας υπολογισμού, ή βασίζονται μεταξύ τους.

Ορίστε ένα παράδειγμα μιας απλής θεμελιακής/αρχαϊκής υπηρεσίας:

```cSharp
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```
Μια υπηρεσία υψηλότερης τάξης θα έχει την εξής μορφή:

```CSharp
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

Πιο προχωρημένες υπηρεσίες τύπου ορχήστρωσης θα συνδυάζουν πολλές υπηρεσίες επεξεργασίας ή θεμελιακές υπηρεσίες ως εξής:

```csharp
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryCardProcessingService.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

Συνολικά, τα λειτουργικά μοντέλα ασχολούνται μόνο με τη φύση της προσομοίωσης ή επεξεργασίας συγκεκριμένων μοντέλων φορέων δεδομένων· δεν ασχολούνται με τη διατήρηση δεδομένων ή τη διατήρηση ενός κατάστασης. Γενικά, τα λειτουργικά μοντέλα είναι αναίσθητα στην κατάσταση, δεν διατηρούν καμία από τις λεπτομέρειες που πέρασαν από αυτά, εκτός από την ανατροφοδότηση του καταγραφής για λόγους παρατηρησιμότητας και παρακολούθησης.

#### 0.1.2.0.1.2 Μοντέλα Έκθεσης (Εκθέτες)
Τα μοντέλα έκθεσης χειρίζονται το HMI σε όλα τα σενάρια όπου άνθρωποι και συστήματα πρέπει να αλληλεπιδρούν. Μπορεί να πρόκειται για απλά RESTful APIs και SDKs ή απλά UI όπως σε διαδικτυακές, κινητές ή εφαρμογές επιφάνειας εργασίας, συμπεριλαμβανομένων των συστημάτων/τερματικών βάσει γραμμής εντολών.

Τα λειτουργικά μοντέλα έκθεσης είναι όπως τα μοντέλα ενσωμάτωσης· επιτρέπουν στον εξωτερικό κόσμο να αλληλεπιδρά με το σύστημά σας. Βρίσκονται στην άλλη άκρη κάθε συστήματος και είναι υπεύθυνα για τον δρομολογισμό κάθε αίτησης, επικοινωνίας ή κλήσης προς τα κατάλληλα λειτουργικά μοντέλα. Τα μοντέλα έκθεσης δεν επικοινωνούν ποτέ απευθείας με τα μοντέλα ενσωμάτωσης και δεν έχουν καμία ρύθμιση εκτός από τις εξαρτήσεις τους που εισάγονται μέσω των δομητών τους.

Τα μοντέλα έκθεσης μπορεί να έχουν τη δική τους γλώσσα όσον αφορά τις λειτουργίες· για παράδειγμα, ένα μοντέλο ενσωμάτωσης μπορεί να χρησιμοποιεί μια γλώσσα όπως το InsertStudent, ενώ ένα μοντέλο έκθεσης για ένα τελικό σημείο API θα χρησιμοποιούσε μια γλώσσα όπως το PostStudent για να εκφράσει την ίδια ακριβώς λειτουργία σε ένα περιβάλλον έκθεσης.

Εδώ έχουμε ένα παράδειγμα μοντέλων έκθεσης:

```csharp
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpPost]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

Το παραπάνω μοντέλο εκθέτει ένα σημείο πρόσβασης API για την RESTful επικοινωνία προκειμένου να προσφέρει τη δυνατότητα εγγραφής φοιτητών σε ένα σύστημα εκπαίδευσης. Θα συζητήσουμε περαιτέρω τους τύπους μοντέλων έκθεσης με βάση το περιβάλλον και τα συστήματα στα οποία εφαρμόζονται.

#### 0.1.2.0.2 Μοντέλα Διαμόρφωσης
Ο τελευταίος τύπος μοντέλου σε οποιοδήποτε σύστημα είναι το μοντέλο διαμόρφωσης. Μπορούν να αντιπροσωπεύουν το σημείο εισόδου σε ένα σύστημα, να καταγράφουν εξαρτήσεις για οποιοδήποτε σύστημα, ή να λειτουργήσουν ως ενδιάμεσα επιπέδα για τη δρομολόγηση των διευθύνσεων URL στην αντίστοιχη λειτουργία τους εντός ενός μοντέλου έκθεσης.

Τα μοντέλα διαμόρφωσης συνήθως βρίσκονται στην αρχή της εκκίνησης ενός συστήματος, χειρίζονται τις εισερχόμενες και εξερχόμενες επικοινωνίες ή τις καταστάσεις του υποκείμενου συστήματος, όπως τη μνήμη cache, τη διαχείριση νημάτων κ.λπ.

Σε μια απλή εφαρμογή API, μπορεί να δείτε μοντέλα που μοιάζουν με αυτά:

```csharp
public class Startup
{
	public void ConfigureServices(IServices services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

Όπως μπορείτε να δείτε από το απόσπασμα κώδικα παραπάνω, το μοντέλο διαμόρφωσης Startup προσφέρει δυνατότητες για τη διαχείριση της εγγραφής βάσει ενσωμάτωσης εξαρτήσεων στις συγκεκριμένες υλοποιήσεις των συμβάσεων. Μπορεί να αναλάβει την προσθήκη ασφάλειας ή τη δημιουργία μιας ενδιάμεσης παραμετροποιημένης διαδικασίας. Τα μοντέλα διαμόρφωσης είναι εξαρτημένα από την τεχνολογία. Μπορεί να διαφέρουν από το πλαίσιο Play σε Scala μέχρι ένα Spring ή Flex σε Python ή Java. Θα περιγράψουμε υψηλού επιπέδου κανόνες σύμφωνα με το Πρότυπο για τα μοντέλα διαμόρφωσης, αλλά δεν θα εμβαθύνουμε στις λεπτομέρειες της υλοποίησης κανενός από αυτά.

## 0.1.3 Προσομοίωση

Η πτυχή της προσομοίωσης στη μηχανική λογισμικού είναι η ικανότητά μας να μοιάζουμε τις αλληλεπιδράσεις προς και από τα μοντέλα. Για παράδειγμα, στο παράδειγμα του καταστήματος τροφίμων, μια προσομοίωση θα ήταν η ενέργεια της πώλησης του αντικειμένου. Η πώληση του αντικειμένου απαιτεί πολλές τροποποιήσεις του αντικειμένου όσον αφορά τη μείωση του αριθμού των διαθέσιμων αντικειμένων και την επανατακτοποίηση των αντικειμένων που απομένουν βάσει του πιο αξιόλογου διαθέσιμου αντικειμένου.

Μπορούμε να περιγράψουμε τη διαδικασία προσομοίωσης ως την απεικόνιση των σχέσεων μεταξύ των μοντέλων, τα οποία προγραμματίζονται ως συναρτήσεις, μέθοδοι ή ρουτίνες· αυτοί οι όροι σημαίνουν όλοι το ίδιο πράγμα. Εάν έχουμε ένα υπηρεσιακό λογισμικό που είναι υπεύθυνο για τις πωλήσεις αντικειμένων, μια διαδικασία προσομοίωσης θα φαίνεται όπως αυτή:

```csharp
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

Στο παράδειγμα παραπάνω, έχουμε ένα μοντέλο που ονομάζεται SaleService που προσφέρει λειτουργία για να προσομοιώσει τη διαδικασία πώλησης στον πραγματικό κόσμο σε ένα μοντέλο αντικειμένου. Και αυτό είναι πώς περιγράφετε τα πάντα στο αντικειμενοστραφές προγραμματισμό. Τα πάντα είναι αντικείμενα (από ένα μοντέλο) και αυτά τα αντικείμενα αλληλεπιδρούν μεταξύ τους (προσομοίωση).

Η αλληλεπίδραση των αντικειμένων, γενικά, μπορεί να παρατηρηθεί σε τρεις διαφορετικούς τύπους. Ένα μοντέλο πραγματοποιεί μια ενέργεια σε ένα άλλο μοντέλο. Για παράδειγμα, το SaleService εκτελεί μια ενέργεια Πώληση σε ένα μοντέλο Αντικείμενο. Αυτό είναι ένα μοντέλο που αλληλεπιδρά με ένα άλλο μοντέλο. Στο ίδιο παράδειγμα, μια προσομοίωση θα μπορούσε να είναι κάτι που συμβαίνει στο μοντέλο από ένα άλλο μοντέλο, όπως το Αντικείμενο στο παράδειγμα παραπάνω. Και ο τελευταίος τύπος προσομοίωσης είναι ένα μοντέλο που αλληλεπιδρά με τον εαυτό του, όπως τα μοντέλα που αυτο-αποδίδονται μόλις επιτεύχθει ο σκοπός τους, καθώς δεν χρειάζονται πλέον, οπότε αυτοκαταστρέφονται.

Η διαδικασία προσομοίωσης είναι η τρίτη και τελευταία πτυχή της μηχανικής λογισμικού. Θα εμβαθύνουμε σε αυτήν όταν μιλήσουμε για μεσάζοντες, υπηρεσίες και μοντέλα έκθεσης για να επισημάνουμε πώς συμβαίνει η διαδικασία προσομοίωσης του βιομηχανικού λογισμικού.

## 0.1.4 Σύνοψη

Εάν θεωρήσουμε τον *σκοπό* να είναι το πεδίο ή το πλαίσιο στο οποίο τα μοντέλα αλληλεπιδρούν, τότε η παρακάτω απεικόνιση θα απλοποιήσει και θα μεταδώσει λίγο καθαρότερα την εικόνα:

<br />
	<div align=center>
		<img width="50%" src="https://user-images.githubusercontent.com/1453985/148863196-a30ced43-7133-4107-a23f-d0beb3efa6db.png" />
	</div>
<br />

Είναι σημαντικό να κατανοήσουμε ότι το λογισμικό μπορεί να εξυπηρετήσει πολλούς σκοπούς. Το λογισμικό μπορεί να αλληλεπιδρά με άλλο λογισμικό που μοιράζεται κοινούς σκοπούς. Ο σκοπός του λογισμικού γίνεται το μοντέλο, και οι ενσωματώσεις γίνονται οι προσομοιώσεις σε αυτήν την έννοια. Ας δούμε ένα παράδειγμα από ψηλά:

<br />
	<div align=center>
		<img width="75%" src="https://user-images.githubusercontent.com/1453985/148863514-2ed0fe04-1096-42c3-b54a-3b8dbd506e7a.png" />
	</div>
<br />

Η πολυπλοκότητα οποιουδήποτε μεγάλου συστήματος μπορεί να διασπαστεί σε μικρότερα προβλήματα εάν επιβάλλεται το απόλυτο μονοσκοπίας ή μονού ρόλου για κάθε υποσύστημα. Αυτό είναι αυτό που οι σύγχρονες αρχιτεκτονικές λογισμικού θα αποκαλούσαν λεπτοδιάκριση και μοντουλοποίηση, τα οποία θα συζητηθούν σύντομα στην πτυχή της αρχιτεκτονικής του Προτύπου.

[*] [Purposing, Modeling & Simulation (Part 1)](https://www.youtube.com/watch?v=Doul1gZKCuU)
