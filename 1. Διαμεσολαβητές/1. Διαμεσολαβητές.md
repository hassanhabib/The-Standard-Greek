# 1 Μεσίτες

## 1.0 Εισαγωγή
Οι μεσίτες είναι ένας σύνδεσμος μεταξύ της επιχειρηματικής λογικής και του εξωτερικού κόσμου.
Είναι περιτυλίγματα γύρω από εξωτερικές βιβλιοθήκες, πόρους, υπηρεσίες ή API για να ικανοποιήσουν μια τοπική διεπαφή για την επιχείρηση να αλληλεπιδράσει μαζί τους χωρίς να χρειάζεται να είναι στενά συνδεδεμένη με οποιονδήποτε συγκεκριμένο πόρο ή υλοποίηση εξωτερικής βιβλιοθήκης.

Οι μεσίτες, γενικά, προορίζονται να είναι αναλώσιμοι και αντικατάστατοι - χτίζονται με την κατανόηση ότι η τεχνολογία εξελίσσεται και αλλάζει συνεχώς. Ως εκ τούτου, σε κάποιο σημείο στη διάρκεια ζωής μιας δεδομένης εφαρμογής, θα αντικατασταθεί με μια πρόσφατη τεχνολογία που κάνει τη δουλειά πιο γρήγορα.

Αλλά οι μεσίτες διασφαλίζουν επίσης ότι η επιχείρησή σας είναι εναλλάξιμη, απομονώνοντας τυχόν συγκεκριμένες εξαρτήσεις εξωτερικών πόρων από αυτό που προσπαθεί να επιτύχει το λογισμικό σας.

Για παράδειγμα, ας πούμε ότι έχετε μια API που έχει δημιουργηθεί για να καταναλώνει και να παρέχει δεδομένα από μια βάση δεδομένων SQL. Σε κάποιο σημείο, αποφασίσατε ότι μια καλύτερη, πιο οικονομική επιλογή για την API σας είναι να βασιστείτε σε μια τεχνολογία NoSql. Η ύπαρξη μεσίτη για την απομάκρυνση της εξάρτησης από τη SQL θα διευκολύνει πολύ την ενσωμάτωση με το NoSql με τον λιγότερο δυνατό χρόνο και κόστος.

## 1.1 Στο χάρτη
Σε οποιαδήποτε εφαρμογή, κινητή, επιτραπέζια, web ή απλώς API, οι μεσίτες συνήθως βρίσκονται στην "ουρά" οποιασδήποτε εφαρμογής επειδή είναι το τελευταίο σημείο επαφής μεταξύ του κώδικα μας και του εξωτερικού κόσμου.

Είτε ο εξωτερικός κόσμος σε αυτήν την περίπτωση είναι απλώς τοπική αποθήκευση μνήμης είτε ανεξάρτητο σύστημα που βρίσκεται πίσω από ένα API, όλα πρέπει να βρίσκονται πίσω από Μεσίτες σε οποιαδήποτε εφαρμογή.

Στην ακόλουθη χαμηλού επιπέδου αρχιτεκτονική για ένα δεδομένο API - οι μεσίτες βρίσκονται μεταξύ της επιχειρηματικής μας λογικής και του εξωτερικού πόρου:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/148864693-d432be6f-13b1-4def-af95-9c63af430802.png" />
    </p>
<br />

## 1.2 Χαρακτηριστικά
Υπάρχουν μερικοί απλοί κανόνες που διέπουν την implementation οποιουδήποτε μεσίτη - αυτοί οι κανόνες είναι:

### 1.2.0 Εφαρμόζει μια τοπική διεπαφή

Οι μεσίτες πρέπει να ικανοποιούν μια τοπική σύμβαση. Πρέπει να εφαρμόσουν μια τοπική διεπαφή για να επιτρέψουν την αποσύνδεση μεταξύ της υλοποίησής τους και των υπηρεσιών που τις καταναλώνουν.

Για παράδειγμα, εάν έχουμε μια τοπική σύμβαση `IStorageBroker` που απαιτεί την υλοποίηση για οποιαδήποτε δεδομένη λειτουργία CRUD για ένα τοπικό μοντέλο `Student` - η λειτουργία της σύμβασης θα είναι η εξής:

```csharp
    public partial interface IStorageBroker
    {
        IQueryable<Student> SelectAllStudents();
    }
```

Μια υλοποίηση για έναν μεσιτών αποθήκευσης θα ήταν η εξής:

```csharp
    public partial class StorageBroker
    {
        public DbSet<Student> Students { get; set; }

        public IQueryable<Student> SelectAllStudents() =>
            SelectAll<Student>();
    }
```
Μια τοπική υλοποίηση σύμβασης μπορεί να αντικατασταθεί ανά πάσα στιγμή, από τη χρήση του Entity Framework όπως φαίνεται στο προηγούμενο παράδειγμα έως τη χρήση μιας εντελώς διαφορετικής τεχνολογίας όπως το Dapper ή μιας εντελώς διαφορετικής υποδομής όπως μια βάση δεδομένων Oracle ή PostgreSQL.

### 1.2.1 Χωρίς έλεγχο ροής
Οι μεσίτες δεν πρέπει να έχουν καμία μορφή ελέγχου ροής, όπως οι δηλώσεις if, οι βρόγχοι while ή οι περιπτώσεις switch. Αυτό συμβαίνει επειδή ο κώδικας ελέγχου ροής θεωρείται επιχειρηματική λογική και ταιριάζει καλύτερα στο επίπεδο υπηρεσιών όπου πρέπει να βρίσκεται η επιχειρηματική λογική, όχι στους μεσίτες.

Για παράδειγμα, μια μέθοδος μεσολαβητή που ανακτά μια λίστα φοιτητών από μια βάση δεδομένων θα φαινόταν κάπως έτσι:

```csharp
        public IQueryable<Student> SelectAllStudents() => SelectAll<Student>();
```
A simple function that calls the native EntityFramework `DbSet<T>` and return a local model like `Student`. 


### 1.2.2 Χωρίς χειρισμό εξαιρέσεων
Ο χειρισμός εξαιρέσεων είναι μια μορφή ελέγχου ροής. Οι μεσίτες δεν πρέπει να χειρίζονται καμία εξαίρεση, αλλά να αφήσουν την εξαίρεση να διαδοθεί στις υπηρεσίες που γειτνιάζουν με τον μεσίτη, όπου αυτές οι εξαιρέσεις μπορούν να χαρτογραφηθούν και να εντοπιστούν σωστά.


### 1.2.3 Κατέχουν τις διαμορφώσεις τους
Οι μεσίτες πρέπει επίσης να χειρίζονται τις δικές τους διαμορφώσεις. Μπορούν να έχουν Dependency Injection από ένα αντικείμενο διαμόρφωσης για να ανακτήσουν και να ρυθμίσουν τις διαμορφώσεις για οποιονδήποτε εξωτερικό πόρο που ενσωματώνουν.

Για παράδειγμα, οι συμβολοσειρές σύνδεσης στις επικοινωνίες βάσης δεδομένων πρέπει να ανακτηθούν και να περάσουν στον πελάτη βάσης δεδομένων για να δημιουργηθεί μια επιτυχής σύνδεση, ως εξής:

```csharp
    public partial class StorageBroker : EFxceptionsContext, IStorageBroker
    {
        private readonly IConfiguration configuration;

        public StorageBroker(IConfiguration configuration)
        {
            this.configuration = configuration;
            this.Database.Migrate();
        }

        ...
        ...

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            string connectionString = this.configuration.GetConnectionString("DefaultConnection");
            optionsBuilder.UseSqlServer(connectionString);
        }
    }
```

### 1.2.4 Natives from Primitives
Οι μεσίτες μπορούν να κατασκευάσουν ένα εξωτερικό μοντέλο αντικειμένου με βάση τους πρωτόγονους τύπους που περνούν οι υπηρεσίες που γειτνιάζουν με τον μεσίτη.

Για παράδειγμα, σε έναν μεσίτη ειδοποίησης ηλεκτρονικού ταχυδρομείου, οι παράμετροι εισόδου για μια λειτουργία .Send(...) απαιτούν τις βασικές παραμέτρους εισόδου όπως το θέμα, το περιεχόμενο ή τη διεύθυνση. Ακολουθεί ένα παράδειγμα:

```csharp
    public async ValueTask SendMailAsync(List<string> recipients, string subject, string content)
    {
        Message message = BuildMessage(recipients, ccRecipients, subject, content);
        await SendEmailMessageAsync(message);
    }
```

Οι `(primitive)` πρωτόγονες παράμετροι εισόδου θα διασφαλίσουν ότι δεν υπάρχουν ισχυρές εξαρτήσεις μεταξύ των υπηρεσιών που γειτνιάζουν με τον μεσίτη και των εξωτερικών μοντέλων.
Ακόμη και σε περιπτώσεις όπου ο μεσίτης είναι απλώς ένα σημείο ολοκλήρωσης μεταξύ της εφαρμογής σας και μιας εξωτερικής RESTful API, συνιστάται ιδιαίτερα να δημιουργήσετε τα δικά σας εγγενή μοντέλα για να αντανακλούν το ίδιο JSON αντικείμενο που αποστέλλεται ή επιστρέφεται από την API αντί να βασίζεστε σε βιβλιοθήκες NuGet, DLL ή κοινά έργα για να επιτύχετε τον ίδιο στόχο.

### 1.2.5 Naming Conventions
**Οι συμβάσεις για τους μεσίτες θα πρέπει να παραμένουν όσο το δυνατόν πιο γενικές για να υποδηλώνουν τη συνολική λειτουργικότητα ενός μεσίτη. Για παράδειγμα, λέμε IStorageBroker αντί για ISqlStorageBroker για να υποδείξουμε μια συγκεκριμένη τεχνολογία ή υποδομή.

Με έναν μόνο μεσιτών αποθήκευσης, μπορεί να είναι πιο βολικό να διατηρηθεί το ίδιο όνομα με τη σύμβαση. Αλλά στην περίπτωση συγκεκριμένων υλοποιήσεων μεσιτών, όλα εξαρτώνται από τον αριθμό των μεσιτών που παρέχουν παρόμοια λειτουργικότητα. Στην περίπτωσή μας, έχουμε μια συγκεκριμένη υλοποίηση του IStorageBroker, επομένως το όνομα θα είναι StorageBroker.

Ωστόσο, εάν η εφαρμογή σας υποστηρίζει πολλαπλές ουρές, αποθήκευση ή παρόχους υπηρεσιών ηλεκτρονικού ταχυδρομείου, ενδέχεται να χρειαστεί να αρχίσετε να προσδιορίζετε το συνολικό στόχο του εξαρτήματος. Για παράδειγμα, ένας IQueueBroker θα είχε πολλαπλές υλοποιήσεις όπως NotificationQueueBroker και OrdersQueueBroker.

Αλλά αν οι συγκεκριμένες υλοποιήσεις στοχεύουν στο ίδιο μοντέλο και επιχειρηματική λογική, τότε μια απόκλιση στην τεχνολογία μπορεί να είναι πιο κατάλληλη. Σε αυτή την περίπτωση, για παράδειγμα, IStorageBroker, δύο διαφορετικές συγκεκριμένες υλοποιήσεις θα μπορούσαν να είναι SqlStorageBroker και MongoStorageBroker. Αυτή η περίπτωση είναι τυπική σε καταστάσεις όπου η πρόθεση είναι να μειωθεί το κόστος υποδομής παραγωγής.**

### 1.2.6 Γλώσσα
Οι μεσίτες μιλούν τη γλώσσα των τεχνολογιών που υποστηρίζουν.
Για παράδειγμα, σε έναν μεσίτη αποθήκευσης, λέμε SelectById για να ταιριάξουμε με την εντολή SQL Select, και σε έναν μεσιτών ουρών, λέμε Enqueue για να ταιριάξουμε με τη γλώσσα.

Εάν ένας μεσίτης υποστηρίζει ένα endpoint API, τότε θα πρέπει να ακολουθήσει τις σημασίες RESTFul, όπως POST, GET ή PUT. Ακολουθεί ένα παράδειγμα:

```csharp

    public async ValueTask<Student> PostStudentAsync(Student student) =>
        await this.PostAsync(RelativeUrl, student);

```

### 1.2.7 Up & Sideways
Οι μεσίτες δεν μπορούν να καλούν άλλους μεσίτες· επειδή οι μεσίτες είναι το πρώτο σημείο αφαίρεσης, δεν απαιτούν πρόσθετες αφηρημένες έννοιες ή εξαρτήσεις εκτός από ένα μοντέλο πρόσβασης διαμόρφωσης.

Οι μεσίτες δεν μπορούν επίσης να έχουν υπηρεσίες ως εξαρτήσεις, καθώς η ροή σε οποιοδήποτε δεδομένο σύστημα πρέπει να προέρχεται από τις υπηρεσίες προς τους μεσίτες και όχι το αντίστροφο.

Για παράδειγμα, ακόμη και όταν ένα μικρο-υπηρεσία έχει να εγγραφεί σε μια ουρά, οι μεσίτες θα μεταβιβάσουν μια μέθοδο ακροατή για την επεξεργασία εισερχόμενων συμβάντων, αλλά δεν θα καλούν τις υπηρεσίες που παρέχουν τη λογική επεξεργασίας.

Ο γενικός κανόνας εδώ είναι ότι μόνο οι υπηρεσίες μπορούν να καλούν μεσίτες· ενώ οι μεσίτες μπορούν να καλούν μόνο εξωτερικές native εξαρτήσεις.

## 1.3 Οργάνωση
Οι μεσίτες που υποστηρίζουν πολλαπλές οντότητες, όπως οι μεσίτες αποθήκευσης, θα πρέπει να αξιοποιούν τις μερικές τάξεις για να διασπάσουν τις ευθύνες ανά οντότητα.

Για παράδειγμα, εάν έχουμε έναν μεσίτη αποθήκευσης που παρέχει όλες τις λειτουργίες CRUD για τα μοντέλα Student και Teacher, τότε η οργάνωση των αρχείων θα πρέπει να είναι η εξής:

- IStorageBroker.cs
  - IStorageBroker.Students.cs
  - IStorageBroker.Teachers.cs
- StorageBroker.cs
  - StorageBroker.Students.cs
  - StorageBroker.Teachers.cs

Ο πρωταρχικός σκοπός αυτής της συγκεκριμένης οργάνωσης, αξιοποιώντας τις μερικές τάξεις, είναι να διαχωρίσει την ανησυχία για κάθε οντότητα σε ένα λεπτότερο επίπεδο, το οποίο θα πρέπει να κάνει τη συντήρηση του λογισμικού πολύ υψηλότερη.

Αλλά οι ονομασίες των αρχείων και των φακέλων μεσολαβητών επικεντρώνονται αυστηρά στην πληθυντικό των οντοτήτων που υποστηρίζουν και στην ενικότητα για τον συνολικό πόρο που υποστηρίζεται.

Για παράδειγμα, λέμε IStorageBroker.Students.cs. Και λέμε επίσης IEmailBroker ή IQueueBroker.Notifications.cs - ενικός για τον πόρο και πληθυντικό οντότητες.

Η ίδια έννοια ισχύει και για τους φακέλους ή τους χώρους ονομάτων που περιέχουν αυτούς τους μεσάζοντες.

Για παράδειγμα:

```csharp
namespace OtripleS.Web.Api.Brokers.Storages
{
    ...
}
```

Και λέμε:
```csharp
namespace OtripleS.Web.Api.Brokers.Queues
{
    ...
}
```

## 1.4 Τύποι Μεσιτών
Στις περισσότερες από τις εφαρμογές που δημιουργούνται σήμερα, ορισμένοι κοινοί Μεσίτες είναι συνήθως απαραίτητοι για την εκκίνηση μιας εφαρμογής επιχείρησής - ορισμένοι από αυτούς είναι Αποθήκευση, Χρόνος, API, Καταγραφή και Ουρές.

Μερικοί μεσίτες αλληλεπιδρούν με υπάρχοντες πόρους στο σύστημα, όπως ο χρόνος για να επιτρέψουν στις υπηρεσίες που γειτνιάζουν με τον μεσίτη να αντιμετωπίζουν τον χρόνο ως εξάρτηση και να ελέγχουν πώς θα συμπεριφέρεται μια συγκεκριμένη υπηρεσία με βάση την τιμή του χρόνου σε οποιοδήποτε σημείο στο παρελθόν, παρόν ή μέλλον.

### 1.4.0 Μεσίτες Οντοτήτων
Οι μεσίτες οντοτήτων παρέχουν σημεία διασύνδεσης με εξωτερικούς πόρους που χρειάζεται το σύστημα για να εκπληρώσει τις επιχειρηματικές απαιτήσεις.

Για παράδειγμα, οι μεσίτες οντοτήτων ενσωματώνονται με την αποθήκευση, παρέχοντας δυνατότητες αποθήκευσης ή ανάκτησης εγγραφών από μια βάση δεδομένων.

Οι μεσίτες οντοτήτων είναι επίσης παρόμοιοι με τους μεσάζοντες ουρών, παρέχοντας ένα σημείο διασύνδεσης για την αποστολή μηνυμάτων σε μια ουρά για άλλες υπηρεσίες για να τα καταναλώσουν και να τα επεξεργαστούν για να εκπληρώσουν τη λογική της επιχείρησής τους.

Οι υπηρεσίες που γειτνιάζουν με τον μεσίτη μπορούν να καλούν μόνο μεσίτες οντοτήτων επειδή απαιτούν ένα επίπεδο επικύρωσης στα δεδομένα που λαμβάνουν ή παρέχουν πριν προχωρήσουν περαιτέρω.

### 1.4.1 Μεσίτες Υποστήριξης
Οι μεσίτες υποστήριξης είναι γενικοί μεσίτες, παρέχουν λειτουργικότητα για την υποστήριξη υπηρεσιών, αλλά δεν έχουν καμία χαρακτηριστικό που τους κάνει διαφορετικούς από οποιοδήποτε άλλο σύστημα.

Ένα καλό παράδειγμα μεσιτών υποστήριξης είναι ο DateTimeBroker - ένας μεσίτης ειδικά κατασκευασμένος για να απομονώσει την ισχυρή εξάρτηση της επιχειρηματικής λογικής από το χρονισμό του συστήματος.

Οι μεσίτες χρόνου δεν στοχεύουν σε καμία συγκεκριμένη οντότητα και είναι σχεδόν πανομοιότυποι σε πολλά συστήματα.

Ένα άλλο παράδειγμα μεσιτών υποστήριξης είναι ο LoggingBroker - παρέχουν δεδομένα σε συστήματα καταγραφής και παρακολούθησης για να επιτρέψουν στους μηχανικούς του συστήματος να απεικονίσουν τη συνολική ροή δεδομένων σε όλο το σύστημα και να ειδοποιηθούν σε περίπτωση που συμβούν τυχόν προβλήματα.

Οι μεσίτες υποστήριξης μπορούν να καλούνται σε ολόκληρο το επιχειρηματικό στρώμα: σε υπηρεσίες θεμελίωσης, επεξεργασίας, ορχήστρας, συντονισμού, διαχείρισης ή συσσώρευσης, σε αντίθεση με τους μεσίτες οντοτήτων. Αυτό συμβαίνει επειδή οι μεσίτες καταγραφής απαιτούνται ως υποστηρικτικό συστατικό στο σύστημα για να παρέχουν όλες τις δυνατότητες που χρειάζονται οι υπηρεσίες για να καταγράψουν τα σφάλματά τους ή να υπολογίσουν μια ημερομηνία ή οποιαδήποτε άλλη υποστηρικτική λειτουργικότητα.

Μπορείτε να βρείτε πραγματικά παραδείγματα μεσιτών στο έργο OtripleS [εδώ](https://github.com/hassanhabib/OtripleS/tree/master/OtripleS.Web.Api/Brokers).

## 1.5 Yλοποίηση
Εδώ είναι μια πραγματική υλοποίηση ενός πλήρους μεσίτη αποθήκευσης για όλες τις λειτουργίες CRUD για την οντότητα `Student`:

###### For IStorageBroker.cs:
```csharp
namespace OtripleS.Web.Api.Brokers.Storages
{
    public partial interface IStorageBroker
    {
    }
}

```

###### For StorageBroker.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using EFxceptions.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using OtripleS.Web.Api.Models.Users;

namespace OtripleS.Web.Api.Brokers.Storages
{
    public partial class StorageBroker : EFxceptionsIdentityContext<User, Role, Guid>, IStorageBroker
    {
        private readonly IConfiguration configuration;

        public StorageBroker(IConfiguration configuration)
        {
            this.configuration = configuration;
            this.Database.Migrate();
        }

        private async ValueTask<T> InsertAsync<T>(T @object)
        {
            this.Entry(@object).State = EntityState.Added;
            await this.SaveChangesAsync();

            return @object;
        }

        private IQueryable<T> SelectAll<T>() where T : class => this.Set<T>();

        private async ValueTask<T> SelectAsync<T>(params object[] @objectIds) where T : class =>
            await this.FindAsync<T>(objectIds);

        private async ValueTask<T> UpdateAsync<T>(T @object)
        {
            this.Entry(@object).State = EntityState.Modified;
            await this.SaveChangesAsync();

            return @object;
        }

        private async ValueTask<T> DeleteAsync<T>(T @object)
        {
            this.Entry(@object).State = EntityState.Deleted;
            await this.SaveChangesAsync();

            return @object;
        }

        ...

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
            string connectionString = this.configuration.GetConnectionString("DefaultConnection");
            optionsBuilder.UseSqlServer(connectionString);
        }
    }
}
```

###### For IStorageBroker.Students.cs:
```csharp
using system;
using system.Linq;
using system.Threading.Tasks;
using OtripleS.Web.Api.Models.Students;

namespace OtripleS.Web.Api.Brokers.Storages
{
    public partial interface IStorageBroker
    {
        public ValueTask<Student> InsertStudentAsync(Student student);
        public IQueryable<Student> SelectAllStudents();
        public ValueTask<Student> SelectStudentByIdAsync(Guid studentId);
        public ValueTask<Student> UpdateStudentAsync(Student student);
        public ValueTask<Student> DeleteStudentAsync(Student student);
    }
}
``` 

###### For StorageBroker.Students.cs:
```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using OtripleS.Web.Api.Models.Students;

namespace OtripleS.Web.Api.Brokers.Storages
{
    public partial class StorageBroker
    {
        public DbSet<Student> Students { get; set; }

        public async ValueTask<Student> InsertStudentAsync(Student student) =>
            await InsertAsync(student);

        public IQueryable<Student> SelectAllStudents() => SelectAll<Student>();

        public async ValueTask<Student> SelectStudentByIdAsync(Guid studentId) =>
            await SelectAsync<Student>(studentId);

        public async ValueTask<Student> UpdateStudentAsync(Student student) =>
            await UpdateAsync(student);

        public async ValueTask<Student> DeleteStudentAsync(Student student) =>
            await DeleteAsync(student);
    }
}
```

## 1.6 Περίληψη
Οι μεσίτες είναι το πρώτο επίπεδο αφαίρεσης μεταξύ της επιχειρηματικής λογικής σας και του εξωτερικού κόσμου. Αλλά δεν είναι το μόνο επίπεδο αφαίρεσης· επειδή θα υπάρχουν ακόμα λίγα εγγενή μοντέλα που διαρρέουν από τους μεσίτες σας στις υπηρεσίες που γειτνιάζουν με τον μεσίτη. Είναι φυσικό να αποφεύγουμε να κάνουμε οποιεσδήποτε αντιστοιχίσεις εκτός του πεδίου της λογικής· στην περίπτωσή μας, εδώ, οι υπηρεσίες θεμελίωσης.

Για παράδειγμα, σε έναν μεσίτη αποθήκευσης, ανεξάρτητα από το ORM που χρησιμοποιείται, θα συμβούν ορισμένες εγγενείς εξαιρέσεις από το ORM σας (π.χ. EntityFramework), όπως DbUpdateException ή SqlException. Σε αυτήν την περίπτωση, χρειαζόμαστε άλλο ένα επίπεδο αφαίρεσης για να παίξει το ρόλο ενός χάρτη μεταξύ αυτών των εξαιρέσεων και της βασικής μας λογικής για να τις μετατρέψει σε τοπικά μοντέλα εξαιρέσεων.

Αυτή η ευθύνη ανήκει στις υπηρεσίες που γειτνιάζουν με τον μεσίτη. Τους αποκαλώ επίσης υπηρεσίες θεμελίωσης, αυτές οι υπηρεσίες είναι το τελευταίο σημείο αφαίρεσης πριν από τη βασική σας λογική που αποτελείται από τοπικά μοντέλα και συμβάσεις.

## 1.7 Συχνές Ερωτήσεις
Με την πάροδο του χρόνου, προέκυψαν ορισμένες κοινές ερωτήσεις από τους μηχανικούς με τους οποίους συνεργάστηκα καθ' όλη τη διάρκεια της καριέρας μου. Δεδομένου ότι ορισμένες από αυτές τις ερωτήσεις επανεμφανίστηκαν σε αρκετές περιπτώσεις, σκέφτηκα ότι θα ήταν χρήσιμο να τις συγκεντρώσω εδώ για να μάθει ο καθένας για άλλες απόψεις γύρω από τους μεσολαβητές.

#### 1.7.0 Είναι το πρότυπο Brokers το ίδιο με το πρότυπο Repository;
Όχι ακριβώς, τουλάχιστον από λειτουργική άποψη, οι μεσίτες φαίνονται πιο γενικοί από τους αποθεματικούς.

Οι αποθεμές συνήθως στοχεύουν σε λειτουργίες αποθήκευσης, κυρίως προς τις βάσεις δεδομένων. Αλλά οι μεσίτες μπορούν να είναι σημείο ολοκλήρωσης με οποιαδήποτε εξωτερική εξάρτηση όπως υπηρεσίες ηλεκτρονικού ταχυδρομείου, ουρές και άλλες API.

Ένα πιο παρόμοιο πρότυπο για τους μεσίτες είναι το πρότυπο Unit of Work. Επικεντρώνεται κυρίως στην συνολική λειτουργία χωρίς να χρειάζεται να δέσει τον ορισμό ή το όνομα με κάποια συγκεκριμένη λειτουργία.

Όλα αυτά τα πρότυπα, γενικά, προσπαθούν να εφαρμόσουν τις ίδιες αρχές SOLID: διαχωρισμός ανησυχίας, ένεση εξάρτησης και ευθύνη ενός ατόμου.

Αλλά επειδή τα SOLID είναι αρχές και όχι ακριβείς κατευθυντήριες γραμμές, αναμένεται να δούμε όλες τις διαφορετικές υλοποιήσεις και πρότυπα για να επιτευχθεί αυτή η αρχή.

#### 1.7.1 Γιατί οι μεσίτες δεν μπορούν να εφαρμόσουν μια σύμβαση για μεθόδους που επιστρέφουν μια διεπαφή αντί για ένα συγκεκριμένο μοντέλο;
Αυτό θα ήταν μια ιδανική κατάσταση, αλλά θα απαιτούσε επίσης από τους μεσίτες να κάνουν μια μετατροπή ή χαρτογράφηση μεταξύ των εγγενών μοντέλων που επιστρέφονται από τις SDKs ή τις API εξωτερικών πόρων και του εσωτερικού μοντέλου που συμμορφώνεται με την τοπική σύμβαση.

Η πραγματοποίηση αυτού στο επίπεδο του μεσίτη θα απαιτούσε την προώθηση της επιχειρηματικής λογικής σε αυτόν τον τομέα, η οποία είναι εξ ολοκλήρου εκτός του σκοπού αυτού του συστατικού.

Ορίζουμε τον κώδικα επιχειρηματικής λογικής ως οποιονδήποτε προοριζόμενο κωδικό ακολουθίας, επιλογής ή επανάληψης. Οι μεσίτες δεν υφίστανται δοκιμές μονάδας επειδή δεν έχουν καμία επιχειρηματική λογική. Μπορούν να είναι μέρος μιας δοκιμής αποδοχής ή μιας δοκιμής ολοκλήρωσης, αλλά σίγουρα δεν είναι μέρος δοκιμών σε επίπεδο μονάδας - απλώς και μόνο επειδή δεν περιέχουν καμία επιχειρηματική λογική σε αυτά.

#### 1.7.2 Εάν οι μεσίτες ήταν ένα επίπεδο αφαίρεσης από τη λογική της επιχείρησης, γιατί επιτρέπουμε σε εξωτερικές εξαιρέσεις να διαρρεύσουν σε αυτούς στις υπηρεσίες;
Οι μεσίτες είναι μόνο το πρώτο επίπεδο αφαίρεσης, αλλά όχι το μόνο. Οι υπηρεσίες που γειτνιάζουν με τον μεσίτη είναι υπεύθυνες για τη μετατροπή των εγγενών εξαιρέσεων που συμβαίνουν σε έναν μεσίτη σε ένα πιο τοπικό μοντέλο εξαιρέσεων που μπορεί να αντιμετωπιστεί και να επεξεργαστεί εσωτερικά εντός του επιχειρηματικού λογικού πεδίου.

Η επιχειρηματική λογική προκύπτει στις επεξεργασίες, τις ορχηστρώσεις, τον συντονισμό και τις συγκεντρώσεις όπου όλες οι εξαιρέσεις, όλα τα επιστρεφόμενα μοντέλα και όλες οι λειτουργίες είναι τοπικές στο σύστημα.

#### 1.7.3 Γιατί χρησιμοποιούμε μερικές τάξεις για μεσίτες που χειρίζονται πολλαπλές οντότητες;
Αφού οι μεσίτες πρέπει να κατέχουν τις διαμορφώσεις τους, έχει νόημα να μεριζόμαστε όταν είναι δυνατόν για να αποφευχθεί η αναδιαμόρφωση κάθε αποθήκης μεσίτη για κάθε οντότητα.

Οι μερικές τάξεις είναι ένα χαρακτηριστικό της γλώσσας C#, αλλά θα πρέπει να είναι δυνατή η υλοποίηση της ίδιας συμπεριφοράς μέσω κληρονομικότητας σε άλλες γλώσσες προγραμματισμού.

#### 1.7.4 Είναι οι μεσίτες οι ίδιοι με τους παρόχους (Πρότυπο Παρόχου);
Όχι. Οι πάροχοι θολώνουν τη γραμμή μεταξύ υπηρεσιών (επιχειρηματική λογική) και μεσιτών (επίπεδο ολοκλήρωσης) - οι μεσίτες στοχεύουν συγκεκριμένα συστατικά εντός του συστήματος που είναι εύχρηστα. Οι πάροχοι φαίνεται να περιλαμβάνουν περισσότερα από αυτό.


[*] [Implementing Abstract Components (Brokers)](https://www.youtube.com/watch?v=6NlgSskQXSo)

[*] [Implementing Abstract Components (Part 2)](https://www.youtube.com/watch?v=d1cqEKMBmno)

[*] [Generating Model Migrations w/ EntityFramework](https://www.youtube.com/watch?v=6sD5zz9BuOk)
